<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta name="description"/><meta name="keywords"/><title></title><meta property="og:type" content="article"/><meta property="og:title" content="Ballerina - undefined"/><meta property="og:description"/><meta property="og:description"/><meta property="twitter:description"/><meta property="twitter:text:description"/><link rel="stylesheet" href="/spec/ballerina-language-specification.css"/><script type="text/javascript" src="https://www.google-analytics.com/analytics.js"></script><script src="https://www.googletagmanager.com/gtm.js?id=GTM-PSL2TX4"></script><script src="https://www.googletagmanager.com/gtag/js?id=UA-92163714-2"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@docsearch/js@alpha"></script><meta name="next-head-count" content="16"/><meta name="robots" content="noindex"/><meta name="googlebot" content="noindex"/><meta name="author" content="WSO2, Inc."/><meta property="og:image" content="/images/ballerina-swan-lake-sm-banner-general.png"/><meta property="og:title" content="Ballerina"/><meta property="og:image" content="/images/ballerina-swan-lake-sm-banner-general.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@ballerinalang"/><meta name="twitter:creator" content="@ballerinalang"/><meta name="twitter:title" content="Ballerina"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:image" content="/images/ballerina-swan-lake-sm-banner-general.png"/><meta property="twitter:image" content="/images/ballerina-swan-lake-sm-banner-general.png"/><link rel="shortcut icon" href="/images/favicon.ico"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css"/><link rel="stylesheet" href="/css/ballerina-search-button.css"/><link rel="stylesheet" href="/css/ballerina-search-modal.css"/><link rel="stylesheet" href="/css/ballerina-search-variables.css"/><link rel="stylesheet" href="/css/ballerina-search-style.css"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/_next/static/css/732cb9c2a490d939.css" as="style"/><link rel="stylesheet" href="/_next/static/css/732cb9c2a490d939.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-ae8188ec2180b3e7.js" defer=""></script><script src="/_next/static/chunks/framework-a070cbfff3c750c5.js" defer=""></script><script src="/_next/static/chunks/main-dccf02f3d007ade6.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a1e0d68ce78e316c.js" defer=""></script><script src="/_next/static/chunks/7621-d7c612e69c24f697.js" defer=""></script><script src="/_next/static/chunks/pages/spec/lang/%5B...slug%5D-a75bf384ce5a427f.js" defer=""></script><script src="/_next/static/XA3UMLKYkN8BkU_Lfr_oH/_buildManifest.js" defer=""></script><script src="/_next/static/XA3UMLKYkN8BkU_Lfr_oH/_ssgManifest.js" defer=""></script><script src="/_next/static/XA3UMLKYkN8BkU_Lfr_oH/_middlewareManifest.js" defer=""></script><style data-href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap">@font-face{font-family:'Roboto';font-style:italic;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOiCnqEu92Fr1Mu51QrIzQ.woff) format('woff')}@font-face{font-family:'Roboto';font-style:italic;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TjARc-.woff) format('woff')}@font-face{font-family:'Roboto';font-style:italic;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOkCnqEu92Fr1Mu52xM.woff) format('woff')}@font-face{font-family:'Roboto';font-style:italic;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51S7ABc-.woff) format('woff')}@font-face{font-family:'Roboto';font-style:italic;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TzBhc-.woff) format('woff')}@font-face{font-family:'Roboto';font-style:italic;font-weight:900;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TLBBc-.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOkCnqEu92Fr1MmgWxM.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5vAA.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Me5g.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9vAA.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlvAA.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:900;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmYUtvAA.woff) format('woff')}@font-face{font-family:'Roboto';font-style:italic;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOiCnqEu92Fr1Mu51QrEz0dL-vwnYh2eg.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:italic;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOiCnqEu92Fr1Mu51QrEzQdL-vwnYh2eg.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:italic;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOiCnqEu92Fr1Mu51QrEzwdL-vwnYh2eg.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:italic;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOiCnqEu92Fr1Mu51QrEzMdL-vwnYh2eg.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:italic;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOiCnqEu92Fr1Mu51QrEz8dL-vwnYh2eg.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:italic;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOiCnqEu92Fr1Mu51QrEz4dL-vwnYh2eg.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:italic;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOiCnqEu92Fr1Mu51QrEzAdL-vwnYg.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:italic;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TjASc3CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:italic;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TjASc-CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:italic;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TjASc2CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:italic;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TjASc5CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:italic;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TjASc1CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:italic;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TjASc0CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:italic;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TjASc6CsTYl4BO.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:italic;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOkCnqEu92Fr1Mu51xFIzIXKMnyrYk.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:italic;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOkCnqEu92Fr1Mu51xMIzIXKMnyrYk.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:italic;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOkCnqEu92Fr1Mu51xEIzIXKMnyrYk.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:italic;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOkCnqEu92Fr1Mu51xLIzIXKMnyrYk.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:italic;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOkCnqEu92Fr1Mu51xHIzIXKMnyrYk.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:italic;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOkCnqEu92Fr1Mu51xGIzIXKMnyrYk.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:italic;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOkCnqEu92Fr1Mu51xIIzIXKMny.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:italic;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51S7ACc3CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:italic;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51S7ACc-CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:italic;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51S7ACc2CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:italic;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51S7ACc5CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:italic;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51S7ACc1CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:italic;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51S7ACc0CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:italic;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51S7ACc6CsTYl4BO.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:italic;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TzBic3CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:italic;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TzBic-CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:italic;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TzBic2CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:italic;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TzBic5CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:italic;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TzBic1CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:italic;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TzBic0CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:italic;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TzBic6CsTYl4BO.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:italic;font-weight:900;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TLBCc3CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:italic;font-weight:900;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TLBCc-CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:italic;font-weight:900;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TLBCc2CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:italic;font-weight:900;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TLBCc5CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:italic;font-weight:900;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TLBCc1CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:italic;font-weight:900;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TLBCc0CsTYl4BOQ3o.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:italic;font-weight:900;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOjCnqEu92Fr1Mu51TLBCc6CsTYl4BO.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOkCnqEu92Fr1MmgVxFIzIXKMnyrYk.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOkCnqEu92Fr1MmgVxMIzIXKMnyrYk.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOkCnqEu92Fr1MmgVxEIzIXKMnyrYk.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOkCnqEu92Fr1MmgVxLIzIXKMnyrYk.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOkCnqEu92Fr1MmgVxHIzIXKMnyrYk.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOkCnqEu92Fr1MmgVxGIzIXKMnyrYk.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOkCnqEu92Fr1MmgVxIIzIXKMny.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fCRc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fABc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fCBc4AMP6lbBP.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fBxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fCxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fChc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fBBc4AMP6lQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu72xKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu5mxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu7mxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4WxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu7WxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu7GxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fCRc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fABc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fCBc4AMP6lbBP.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fBxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fCxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fChc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfCRc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfABc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfCBc4AMP6lbBP.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfBxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfCxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfChc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfBBc4AMP6lQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:900;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmYUtfCRc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:900;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmYUtfABc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:900;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmYUtfCBc4AMP6lbBP.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:900;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmYUtfBxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:900;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmYUtfCxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:900;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmYUtfChc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:900;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmYUtfBBc4AMP6lQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next" data-reactroot=""><div class="main-wrapper spec vstack gap-0"><div class="wrap-page-content container"><div class="row"><div class="mdContentSpec col-12"><div><!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Ballerina Language Specification, 2019R1</title>
  <meta charset="utf-8" />
  <link rel="shortcut icon" href="/img/favicon.ico">
  <style type="text/css">
    body { font-family: sans-serif; line-height: 1.38;  }
    pre.grammar code, code.grammar { background-color: #00FFFF; }
    pre, code { font-family: Consolas, monospace; }
    table { border: solid thin; border-collapse: collapse; }
    td, th { border: solid thin; padding: 0.5em; }
    p.status { font-size: large; font-weight: bold; }
  </style>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:100,100i,300,300i,400,400i,500,500i,700,700i,900,900i&amp;display=swap">
<link rel="stylesheet" href="style/ballerina-language-specification.css">
<script src="https://code.jquery.com/jquery-2.2.4.min.js"></script><script src="style/ballerina-language-specification.js"></script>
</head>
<body>
<h1>Ballerina Language Specification, 2019R1</h1>
<p>
Primary contributors:
</p>
<ul>
<li>James Clark, <a href="mailto:jjc@jclark.com">jjc@jclark.com</a></li>
<li>Sanjiva Weerawarana, <a href="mailto:sanjiva@weerawarana.org">sanjiva@weerawarana.org</a></li>
<li>Sameera Jayasoma, <a href="mailto:sameera@wso2.com">sameera@wso2.com</a></li>
<li>Hasitha Aravinda, <a href="mailto:hasitha@wso2.com">hasitha@wso2.com</a></li>
</ul>
<p>
(Other contributors are listed in <a href="#contributors">Appendix C</a>.)
</p>
<p>
Copyright © 2018, 2019 <a href="https://wso2.com/">WSO2</a>
</p>
<p>
Licensed under the <a
href="https://creativecommons.org/licenses/by-nd/4.0/">Creative Commons
Attribution-NoDerivatives 4.0 International</a> license
</p>
<p class="status">
Language and document status
</p>
<p>
The design of the Ballerina language is approaching stability.
</p>
<p>
Some language features described by this specification are less stable than the
rest of the language. These are marked with either as having either "preview" or
"experimental" status. Preview status means that we expect the final design to
be close enough to the current design that it will be straightforward to update
code that makes uses the current design to the final design. Experimental status
means that we believe that we want to have similar functionality, but we are not
yet confident about how close the final design will be to the feature as
currently described.
</p>
<p>
In addition, we know there are some areas where the specification needs to
provide more details about the semantics of the language.
</p>
<p>
Comments on this document are welcome and should be made by creating an issue in
<code><a href="https://github.com/ballerina-platform/ballerina-spec"
>https://github.com/ballerina-platform/ballerina-spec</a></code>, which is the
GitHub repository where this specification is maintained. The design of the
language may also be discussed in the <a
href="mailto:ballerina-dev@googlegroups.com">ballerina-dev@googlegroups.com</a>
mailing list.
</p>
<h2 class="toc">Table of Contents</h2>
<p><a href="#introduction">1. Introduction</a></p>
<p><a href="#notation">2. Notation</a></p>
<p><a href="#program_structure">3. Program structure</a></p>
<p><a href="#lexical_structure">4. Lexical structure</a></p>
<p><a href="#values_types">5. Values, types and variables</a></p>
<p><a href="#expressions">6. Expressions</a></p>
<p><a href="#actions_statements">7. Actions and statements</a></p>
<p><a href="#built-in_methods">8. Built-in methods</a></p>
<p><a href="#module_level">9. Module-level declarations</a></p>
<p><a href="#querying">10. [Experimental] Querying</a></p>
<p><a href="#transactions">11. [Experimental] Transactions</a></p>
<p><a href="#metadata">12. Metadata</a></p>
<p><a href="#references">A. References</a></p>
<p><a href="#changes">B. Changes since previous versions</a></p>
<p><a href="#contributors">C. Other contributors</a></p>
<h2 id="introduction">1. Introduction</h2>
<p>
Ballerina is a programming language intended for network distributed
applications. It is a statically typed, concurrent programming language with all
functionality expected of a modern, general purpose programming language. But it
also has several unusual aspects that make it particularly suitable for its
intended purpose.
</p>
<p>
First, it provides language constructs specifically for consuming and providing
network services. Future versions of Ballerina will add language constructs for
other functionality often needed by network distributed applications such as
security, stream processing, distributed transactions and reliable messaging.
</p>
<p>
Second, it is designed to take advantage of sequence diagrams as a way of
describing the interactions within network distributed applications. There is a
close correspondence between the function-level concurrency-related syntax and
sequence diagrams; this syntax is in effect a syntax for writing sequence
diagrams. This makes it possible to provide an editable graphical representation
of a function as a sequence diagram.
</p>
<p>
Third, it has a type system that is more flexible and allows for looser coupling
that traditional statically typed languages. The type system is structural:
instead of requiring the program to explicitly say which types are compatible
with each other, compatibility of types and values is determined automatically
based on their structure; this is particularly useful when combining data from
multiple, independently-designed systems. In addition, the type system provides
union types and open records. This flexibility allows the type system to be used
as a schema for the data that is exchanged in distributed applications.
Ballerina's data types are designed to work particularly well with JSON; any
JSON value has a direct, natural representation as a Ballerina value. Ballerina
also provides support for XML and relational data.
</p>
<p>
Ballerina is not a research language. It is intended to be a pragmatic language
suitable for mass-market commercial adoption. It tries to feel familiar to
programmers who are used to popular, modern C-family languages, notably Java,
C#, JavaScript. It also borrows ideas from many other existing programming
languages including TypeScript, Go, Rust, D, Kotlin, TypeScript, Swift, Python
and Perl.
</p>
<p>
Ballerina is designed for modern development practices with a module based
development model with namespace management via module repositories, including a
globally shared central repository. Module version management, dependency
management, testing, documentation, building and sharing are part of the
language platform design architecture and not left for later add-on tools.
</p>
<p>
Ballerina is a "batteries included" language: it comes with a standard library,
which includes not only the usual low-level, general-purpose functionality, but
also support for a wide variety of network protocols, interface standards, data
formats and authentication/authorization standards, which make writing secure,
resilient distributed applications significantly easier than with other
languages. The standard library is not specified in this document.
</p>
<h2 id="notation">2. Notation</h2>
<p>
Productions are written in the form:
</p>

<pre>symbol := rhs
</pre>
<p>
where symbol is the name of a nonterminal, and <code>rhs</code> is as follows:
</p>
<ul>
<li><code>0xX</code> means the single character whose Unicode code point is
denoted by the hexadecimal numeral X</li>
<li><code>^x</code> means any single Unicode code point that does not match x
and is not a disallowed character;</li>
<li><code>x..y</code> means any single Unicode character whose code point is
greater than or equal to that of x and less than or equal to that of y</li>
<li><code class="grammar">str</code> means the characters <code>str</code> literally</li>
<li><code>symbol </code>means a reference to production for the nonterminal
<code>symbol</code></li>
<li><code>x|y</code> means x or y</li>
<li><code>x&amp;y</code> means x and y interleaved in any order</li>
<li><code>[x]</code> means zero or one times</li>
<li><code>x?</code> means x zero or one times</li>
<li><code>x*</code> means x zero or more times</li>
<li><code>x+</code> means x one or more times</li>
<li><code>(x)</code> means x (grouping)</li>
</ul>
<p>
The rhs of a symbol that starts with a lower-case letter implicitly allows white
space and comments, as defined by the production <code>TokenWhiteSpace</code>,
between the terminals and nonterminals that it references.
</p>
<h2 id="program_structure">3. Program structure</h2>
<p>
A Ballerina program is divided into modules. A module has a source form and a
binary form. The module is the unit of compilation; a Ballerina compiler
translates the source form of a module into its binary form. A module may
reference other modules. When a compiler translates a source module into a
binary module, it needs access only to the binary form of other modules
referenced from the source module.
</p>
<p>
A binary module can only be referenced if it is placed in a module store. There
are two kinds of module store: a repository and a project. A module stored in a
repository can be referenced from any other module. A module stored in a project
can only be referenced from other modules stored in the same project.
</p>
<p>
A repository organizes binary modules into a 3-level hierarchy:
</p>
<ol>
<li>organization;</li>
<li>module name;</li>
<li>version.</li>
</ol>
<p>
Organizations are identified by Unicode strings, and are unique within a
repository. A module name is a Unicode string and is unique within a repository
organization. A particular module name can have one or more versions each
associated with a separate binary module. Versions are semantic, as described in
the SemVer specification.
</p>
<p>
A project stores modules using a simpler single level hierarchy, in which the
module is associated directly with the module name.
</p>
<p>
A binary module is a sequence of octets. Its format is specified in the
Ballerina Platform Specification.
</p>
<p>
An abstract source module consists of:
</p>
<ul>
<li>an ordered collection of one or more source parts; each source part is a
sequence of octets that is the UTF-8 encoding of part of the source code for the
module</li>
<li>metadata containing the following
<ul>
<li>always required: module name</li>
<li>required only if the source module is to be compiled into a binary module
stored in a repository:
<ul>
<li>organization name</li>
<li>version</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>
An abstract source module can be stored in a variety of concrete forms. For
example, the Ballerina Platform Specification describes a method for storing an
abstract source module in a filesystem, where the source parts are files with a
<code>.bal </code>extension stored in a directory, the module name comes from
the name of that directory, and the version and organization name comes from a
configuration file <code>Ballerina.toml</code> in that directory.
</p>
<h2 id="lexical_structure">4. Lexical structure</h2>
<p>
The grammar in this document specifies how a sequence of Unicode code points is
interpreted as part of the source of a Ballerina module. A Ballerina module part
is a sequence of octets (8-bit bytes); this sequence of octets is interpreted as
the UTF-8 encoding of a sequence of code points and must comply with the
requirements of RFC 3629.
</p>
<p>
After the sequence of octets is decoded from UTF-8, the following two
transformations must be performed before it is parsed using the grammar in this
document:
</p>
<ul>
<li>if the sequence starts with a byte order mark (code point 0xFEFF), it must
be removed</li>
<li>newlines are normalized as follows:
<ul>
<li>the two character sequence 0xD 0xA is replaced by 0xA</li>
<li>a single 0xD character that is not followed by 0xD is replaced by 0xA</li>
</ul>
</li>
</ul>
<p>
The sequence of code points must not contain any of the following disallowed
code points:
</p>
<ul>
<li>surrogates (0xD800 to 0xDFFF)</li>
<li>non-characters (the 66 code points that Unicode designates as
non-characters)</li>
<li>C0 control characters (0x0 to 0x1F and 0x1F) other than whitespace (0x9,
0xA, 0xC, 0xD)</li>
<li>C1 control characters (0x80 to 0x9F)</li>
</ul>
<p>
Note that the grammar notation ^X does not allow the above disallowed code
points.
</p>

<pre
class="grammar">identifier := UndelimitedIdentifier | DelimitedIdentifier
UndelimitedIdentifier :=
   IdentifierInitialChar IdentifierFollowingChar*
DelimitedIdentifier := <code>^"</code> StringChar+ <code>"</code>
IdentifierInitialChar := <code>A</code> .. <code>Z</code> | <code>a</code> .. <code>z</code> | <code>_</code> | UnicodeIdentifierChar
IdentifierFollowingChar := IdentifierInitialChar | Digit
UnicodeIdentifierChar := ^ ( AsciiChar | UnicodeNonIdentifierChar )
AsciiChar := 0x0 .. 0x7F
UnicodeNonIdentifierChar :=
   UnicodePrivateUseChar
   | UnicodePatternWhiteSpaceChar
   | UnicodePatternSyntaxChar
UnicodePrivateUseChar :=
   0xE000 .. 0xF8FF
   | 0xF0000 .. 0xFFFFD
   | 0x100000 .. 0x10FFFD
UnicodePatternWhiteSpaceChar := 0x200E | 0x200F | 0x2028 | 0x2029
UnicodePatternSyntaxChar :=
   character with Unicode property Pattern_Syntax=True
Digit := <code>0</code> .. <code>9</code>
</pre>
<p>
Note that the set of characters allowed in identifiers follows the requirements
of Unicode TR31 for immutable identifiers; the set of characters is immutable in
the sense that it does not change between Unicode versions.
</p>

<pre
class="grammar">TokenWhiteSpace := (Comment | WhiteSpaceChar)*
Comment := <code>//</code> AnyCharButNewline*
AnyCharButNewline := ^ 0xA
WhiteSpaceChar := 0x9 | 0xA | 0xD | 0x20
</pre>
<p>
<code>TokenWhiteSpace</code> is implicitly allowed on the right hand side of
productions for non-terminals whose names start with a lower-case letter.
</p>
<h2 id="values_types">5. Values, types and variables</h2>
<p>
Ballerina programs operate on a rich universe of values. This universe of values
is partitioned into a number of <em>basic types</em>; every value belongs to
exactly one basic type.
</p>
<p>
Values are of three kinds, each corresponding to a kind of basic type:
</p>
<ul>
<li>simple values, like booleans and floating point numbers, which are not
constructed from other values;</li>
<li>structured values, like mappings and lists, which create structures from
other values;</li>
<li>behavioral values, like functions, which allow parts of Ballerina programs
to be handled in a uniform way with other values</li>
</ul>
<p>
Values can be stored in variables or as members of structures. A simple value is
stored directly in the variable or structure. However, for other types of value,
what is stored in the variable or member is a reference to the value; the value
itself has its own separate storage. Non-simple types (i.e. structured types and
behavioral types) are thus collectively called reference types. A reference
value has an identity determined by its storage location. References make it
possible for distinct members of a structure to refer to values that are
identical, in the sense that they are stored in the same location. Thus values
in Ballerina represent not just trees but graphs.
</p>
<p>
Simple values are inherently immutable because they have no identity distinct
from their value. All basic types of structural values, with the exception of
the XML, are mutable, meaning the value referred to by a particular reference
can be changed. Whether a behavioural value is mutable depends on its basic
type: some of the behavioural basic types allow mutation, and some do not.
Mutation cannot change the basic type of a value. Mutation makes it possible for
the graphs of references between values to have cycles.
</p>
<p>
Ballerina programs use types to categorize values both at compile-time and
runtime. Types deal with an abstraction of values, which does not consider
storage location or mutability. This abstraction is called a <em>shape</em>. A
type denotes a set of shapes. Subtyping in Ballerina is <em>semantic</em>: a
type S is a subtype of type T if the set of shapes denoted by S is a subset of
the set of shapes denoted by T. Every value has a corresponding shape. A shape
is specific to a basic type: if two values have different basic types, then they
have different shapes. Since shapes do not deal with storage location, they have
no concept of identity; shapes therefore represent trees rather graphs. For
simple values, there is no difference between a shape and a value, except for
one case: positive and negative zero of a floating point basic type are distinct
values but have the same shape. There are two important relations between a
value and a type:
</p>
<ul>
<li>a value <em>looks like</em> a type at a particular point in the execution of
a program if its shape at that point is a member of the type;</li>
<li>a value <em>belongs to</em> a type if it looks like the type, and it will
necessarily continue to look like the type no matter how the value is mutated.</li>
</ul>
<p>
For an immutable value, looking like a type and belonging to a type are the same
thing.
</p>
<p>
When a Ballerina program declares a variable to have a compile-time type, this
means that the Ballerina compiler together with the runtime system will ensure
that the variable will only ever contain a value that belongs to the type.
Ballerina also provides mechanisms that take a value that looks like a type and
use it to create a value that belongs to a type.
</p>
<p>
Ballerina provides a rich variety of type descriptors, which programs use to
describe types. For example, there is a type descriptor for each simple basic
type; there is a type descriptor that describes as type as a union of two types;
there is a type descriptor that uses a single value to describe a type that
contains a single shape. This means that values can look like and belong to
arbitrarily many types, even though they look like or belong to exactly one
<em>basic</em> type.
</p>
<p>
In addition to describing a type, a type descriptor may also include information
used to construct a value of the type, as well as metadata. Whereas the type
described by a type descriptor is known at compile time, this additional
information may need to be resolved at runtime. The typedesc basic type
represents a type descriptor that has been resolved.
</p>
<p>
Most basic types of structured values (along with one basic type of simple
value) are iterable, meaning that a value of the type can be accessed as a
sequence of simpler values.
</p>
<p>
The following table summarizes the type descriptors provided by Ballerina.
Experimental features are not included.
</p>
<table>
  <tr>
   <td><strong>Kind</strong></td>
   <td><strong>Name</strong></td>
   <td><strong>Set of values denoted by type descriptor</strong></td>
  </tr>
  <tr>
   <td rowspan="6" >basic, simple</td>
   <td>nil</td>
   <td>()</td>
  </tr>
  <tr>
   <td>boolean</td>
   <td>true, false</td>
  </tr>
  <tr>
   <td>int</td>
   <td>64-bit signed integers</td>
  </tr>
  <tr>
   <td>float</td>
   <td>64-bit IEEE 754-2008 binary floating point numbers</td>
  </tr>
  <tr>
   <td>decimal</td>
   <td>128-bit IEEE 754-2008 decimal floating point numbers</td>
  </tr>
  <tr>
   <td>string</td>
   <td>sequences of Unicode code points</td>
  </tr>
  <tr>
   <td rowspan="7" >basic, structured</td>
   <td>array</td>
   <td>an ordered list of values, optionally with a specific length, where a
single type is specified for all members of the list,</td>
  </tr>
  <tr>
   <td>tuple</td>
   <td>an ordered list of values, where a type is specified separately for each
member of the list</td>
  </tr>
  <tr>
   <td>map</td>
   <td>a mapping from keys, which are strings, to values; specifies mappings in
terms of a single type to which all keys are mapped</td>
  </tr>
  <tr>
   <td>record</td>
   <td>a mapping from keys, which are strings, to values; specifies maps in
terms of names of fields (required keys) and value for each field</td>
  </tr>
  <tr>
   <td>table</td>
   <td></td>
  </tr>
  <tr>
   <td>XML</td>
   <td>a sequence of zero or more characters, XML elements, processing
instructions or comments</td>
  </tr>
  <tr>
   <td>error</td>
   <td>an indication that there has been an error, with a string identifying the
reason for the error, and a mapping giving additional details about the error</td>
  </tr>
  <tr>
   <td rowspan="5" >basic, behavioral</td>
   <td>function</td>
   <td>a function with 0 or more specified parameter types and a single return
type</td>
  </tr>
  <tr>
   <td>future</td>
   <td></td>
  </tr>
  <tr>
   <td>object</td>
   <td></td>
  </tr>
  <tr>
   <td>service</td>
   <td></td>
  </tr>
  <tr>
   <td>typedesc</td>
   <td>a type descriptor</td>
  </tr>
  <tr>
   <td rowspan="7" >other</td>
   <td>singleton</td>
   <td>a single value described by a literal</td>
  </tr>
  <tr>
   <td>union</td>
   <td>the union of the component types</td>
  </tr>
  <tr>
   <td>optional</td>
   <td>the underlying type and ()</td>
  </tr>
  <tr>
   <td>any</td>
   <td>all values</td>
  </tr>
  <tr>
   <td>anydata</td>
   <td></td>
  </tr>
  <tr>
   <td>byte</td>
   <td>int in the range 0 to 255 inclusive</td>
  </tr>
  <tr>
   <td>json</td>
   <td>the union of (), int, float, decimal, string, and maps and arrays whose
values are, recursively, json</td>
  </tr>
</table>
<h3>Simple Values</h3>
<p>
A simple value belongs to exactly one of the following basic types:
</p>
<ul>
<li>nil</li>
<li>boolean</li>
<li>int</li>
<li>float</li>
<li>decimal</li>
<li>string</li>
</ul>
<p>
The type descriptor for each simple basic type contains all the values of the
basic type.
</p>

<pre
class="grammar">simple-type-descriptor :=
   nil-type-descriptor
   | boolean-type-descriptor
   | int-type-descriptor
   | floating-point-type-descriptor
   | string-type-descriptor
</pre>
<h4>Nil</h4>

<pre
class="grammar">nil-type-descriptor :=  <code>(</code> <code>)</code>
nil-literal :=  <code>(</code> <code>)</code> | <code>null</code>
</pre>
<p>
The nil type contains a single value, called nil, which is used to represent the
absence of any other value. The nil value is written <code>()</code>. The nil
value can also be written <code>null</code>, for compatibility with JSON; the
use of null should be restricted to JSON-related contexts.
</p>
<p>
The nil type is special, in that it is the only basic type that consists of a
single value. The type descriptor for the nil type is not written using a
keyword, but is instead written <code>() </code>like the value.
</p>
<h4>Boolean</h4>

<pre
class="grammar">boolean-type-descriptor := <code>boolean</code>
boolean-literal := <code>true</code> | <code>false</code>
</pre>
<p>
The boolean type consists of the values true and false.
</p>
<h4>Int</h4>

<pre
class="grammar">int-type-descriptor := <code>int</code>
int-literal := DecimalNumber | HexIntLiteral
DecimalNumber := <code>0</code> | NonZeroDigit Digit*
HexIntLiteral := HexIndicator HexNumber
HexNumber := HexDigit+
HexIndicator := <code>0x</code> | <code>0X</code>
HexDigit := Digit | <code>a</code> .. <code>f</code> | <code>A</code> .. <code>F</code>
Digit := <code>0</code> .. <code>9</code>
NonZeroDigit := <code>1</code> .. <code>9</code>
</pre>
<p>
The int type consists of integers between -9,223,372,036,854,775,808 and
9,223,372,036,854,775,807 (i.e. signed integers than can fit into 64 bits using
a two's complement representation)
</p>
<h4>Floating point types</h4>

<pre
class="grammar">floating-point-type-descriptor := <code>float</code> | <code>decimal</code>
floating-point-literal :=
   DecimalFloatingPointNumber | HexFloatingPointLiteral
DecimalFloatingPointNumber :=
   DecimalNumber Exponent [FloatingPointTypeSuffix]
   | DottedDecimalNumber [Exponent] [FloatingPointTypeSuffix]
   | DecimalNumber FloatingPointTypeSuffix
DottedDecimalNumber :=
   DecimalNumber <code>.</code> Digit*
   | <code>.</code> Digit+
Exponent := ExponentIndicator [Sign] Digit+
ExponentIndicator := <code>e</code> | <code>E</code>
HexFloatingPointLiteral := HexIndicator HexFloatingPointNumber
HexFloatingPointNumber :=
   HexNumber HexExponent
   | DottedHexNumber [HexExponent]
DottedHexNumber :=
   HexDigit+ <code>.</code> HexDigit*
   | <code>.</code> HexDigit+
HexExponent := HexExponentIndicator [Sign] Digit+
HexExponentIndicator := <code>p</code> | <code>P</code>
Sign := <code>+</code> | <code>-</code>
FloatingPointTypeSuffix := DecimalTypeSuffix | FloatTypeSuffix
DecimalTypeSuffix := <code>d</code> | <code>D</code>
FloatTypeSuffix :=  <code>f</code> | <code>F</code>
</pre>
<p>
There are two basic types for floating point numbers:
</p>
<ul>
<li>the float type corresponds to IEEE 754-2008 64-bit binary (radix 2) floating
point numbers</li>
<li>the decimal type corresponds to IEEE 754-2008 128-bit decimal (radix 10)
floating point numbers</li>
</ul>
<p>
The multiple bit patterns that IEEE 754 treats as NaN are considered to be the
same value in Ballerina. Positive and negative zero of a floating point basic
type are distinct values, following IEEE 754, but are defined to have the same
shape, so that they will usually be treated as being equal.
</p>
<p>
IEEE-defined operations on floating point values must be performed using a
rounding-direction attribute of roundTiesToEven (which is the default IEEE
rounding direction, sometimes called <em>round to nearest</em>). All floating
point values, including the intermediate results of expressions, must use the
value space defined for the float and decimal type; implementations must not use
extended precision for intermediate results. This ensures that all
implementations will produce identical results. (This is the same as what is
required by strictfp in Java.)
</p>
<h4>Strings</h4>

<pre
class="grammar">string-type-descriptor := <code>string</code>
string-literal := DoubleQuotedStringLiteral
DoubleQuotedStringLiteral := <code>"</code> (StringChar | StringEscape)* <code>"</code>
StringChar := ^ ( 0xA | 0xD | <code>\</code> | <code>"</code> )
StringEscape := StringSingleEscape | StringNumericEscape
StringSingleEscape := <code>\t</code> | <code>\n</code> | <code>\r</code> | <code>\\</code> | <code>\"</code>
StringNumericEscape := <code>\u[</code> CodePoint <code>]</code>
CodePoint := HexDigit+
</pre>
<p>
A string is an immutable sequences of zero or more Unicode code points. Any code
point in the Unicode range of 0x0 to 0x10FFFF inclusive is allowed other than
surrogates (0xD800 to 0xDFFF inclusive).
</p>
<p>
In a <code>StringNumericEscape</code>, <code>CodePoint</code> must valid Unicode
code point; more precisely, it must  be a hexadecimal numeral denoting an
integer <em>n</em> where 0 &lt;= <em>n</em> &lt; 0xD800 or 0xDFFF &lt; n &lt;=
0x10FFFF.
</p>
<p>
A string is iterable as a sequence of its single code point substrings. String
is the only simple type that is iterable.
</p>
<h3>Structured values</h3>
<p>
There are five basic types of structured value. First, there are three container
basic types: list, mapping and table. Second, there is the xml basic type and
the error basic type, which are both special in different ways.
</p>
<p>
Values of the container basic types are containers for other values, which are
called their members.  Containers are mutable: the members contained in a
particular container can be changed. However, a container value can also be
frozen at runtime or compile time, which prevents any change to its members. A
frozen container value can refer only to immutable values: either other frozen
values or values of basic types that are always immutable. Once frozen, a
container value remains frozen. Values of basic type xml can also be frozen as
described below.
</p>
<p>
The shape of the members of a container value contribute to the shape of the
container. Mutating a member of a container can thus cause the shape of the
container to change.
</p>
<p>
A type descriptor for a container basic type describe the shape of the container
in terms of the shapes of its members.  A container has an inherent type, which
is a type descriptor which is part of the container's runtime value. At runtime,
the container prevents any mutation that might lead to the container having a
shape that is not a member of its inherent type. Thus a container value belongs
to a type if and only if that type is its inherent type or a subset of its
inherent type.
</p>
<p>
A frozen container value belongs to a type if and only if the type contains the
shape of the value. In other words, freezing a container narrows its inherent
type to a type that consists of just its current shape.
</p>

<pre
class="grammar">structured-type-descriptor :=
   list-type-descriptor
   | mapping-type-descriptor
   | table-type-descriptor
   | xml-type-descriptor
   | error-type-descriptor
</pre>
<p>
The following table summarizes the type descriptors for structured types.
</p>
<table>
  <tr>
   <td></td>
   <td>Integer index</td>
   <td>String key</td>
  </tr>
  <tr>
   <td>Basic type</td>
   <td>list</td>
   <td>mapping</td>
  </tr>
  <tr>
   <td>Type descriptor with uniform member type</td>
   <td>array</td>
   <td>map</td>
  </tr>
  <tr>
   <td>Type descriptor with separate member types</td>
   <td>tuple</td>
   <td>record</td>
  </tr>
</table>
<p>
A value is defined to be <em>pure</em> if it either
</p>
<ul>
<li>is a simple value, or</li>
<li>is a structured value, all of whose members are also pure values.</li>
</ul>
<p>
A shape is pure if it is the shape of a pure value. A type is pure if it
contains only pure shapes.
</p>
<h4>Lists</h4>
<p>
A list value is a container that keeps its members in an ordered list. The
number of members of the list is called the <em>length </em>of the list. A
member of a list can be referenced by an integer index representing its position
in the list. For a list of length <em>n</em>, the indices of the members of the
list, from first to last, are 0,1,...,<em>n</em> - 1. The shape of a list value
is an ordered list of the shapes of its members.
</p>
<p>
A list is iterable as a sequence of its members.
</p>
<p>
The type of list values can be described by two kinds of type descriptors.
</p>

<pre
class="grammar">list-type-descriptor :=
   array-type-descriptor | tuple-type-descriptor
</pre>
<p>
The inherent type of a list value must be a <code>list-type-descriptor</code>.
The inherent type of a list value determines a type T<sub><em>i</em></sub> for a
member with index <em>i</em>. The runtime system will enforce a constraint that
a value written to index <em>i</em> will belong to type T<sub><em>i</em></sub>.
Note that the constraint is not merely that the value looks like
T<sub><em>i</em></sub>.
</p>
<p>
Both kinds of type descriptor are covariant in the types of their members.
</p>
<h5>Array types</h5>
<p>
An array type-descriptor describes a type of list value by specifying the type
that the value for all members must belong to, and optionally, a length.
</p>

<pre
class="grammar">array-type-descriptor := member-type-descriptor <code>[</code> [ array-length ] <code>]</code>
member-type-descriptor := type-descriptor
array-length :=
   int-literal
   | constant-reference-expr
   | inferred-array-length
inferred-array-length := <code>*</code>
</pre>
<p>
A type <code>T[]</code> contains a list shape if all members of the list shape
are in <code>T</code>. A type <code>T[n]</code> contains a list shape if in
addition the length of the list shape is n.
</p>
<p>
A <code>constant-reference-expr</code> in an <code>array-length</code> must
evaluate to a non-negative integer. An array length of <code>*</code> means that
the length of the array is to be inferred from the context; this is allowed only
within a type descriptor occurring in a context that is specified to be
inferable; its meaning is the same as if the length was specified explicitly.
</p>
<p>
Note also that <code>T[n]</code> is a subtype of <code>T[]</code>, and that if
<code>S</code> is a subtype of <code>T</code>, then <code>S[]</code> is a
subtype of <code>T[]</code>; this is a consequence of the definition of
subtyping in terms of subset inclusion of the corresponding sets of shapes.
</p>
<p>
An array <code>T[]</code> is iterable as a sequence of values of type
<code>T</code>.
</p>
<h5>Tuple types</h5>
<p>
A tuple type descriptor describes a type of list value by specifying a separate
type for each member of the list.
</p>

<pre
class="grammar">tuple-type-descriptor :=
   <code>[</code> tuple-member-type-descriptors <code>]</code>
tuple-member-type-descriptors :=
   member-type-descriptor (<code>,</code> member-type-descriptor)* [<code>,</code> tuple-rest-descriptor]
   | [ tuple-rest-descriptor ]
tuple-rest-descriptor := type-descriptor <code>...</code>

</pre>
<p>
A tuple type descriptor T with m member type descriptors contains a list shape L
of length n if and only if:
</p>
<ul>
<li>m is less than or equal to n</li>
<li>the i-th member type descriptor of T contains the i-th member of L for each
i from 1 to m;</li>
<li>if n is greater than m, then T has a tuple-rest-descriptor
R<code>...</code>, and R contains the j-th member of L for each j from m + 1 to
n.</li>
</ul>
<p>
Note that a tuple type where all the <code>member-type-descriptor</code>s are
the same and there is no tuple-rest-descriptor is equivalent to an
array-type-descriptor with a length.
</p>
<h4>Mappings</h4>
<p>
A mapping value is a container where each member has a key, which is a string,
that uniquely identifies within the mapping. We use the term <em>field</em> to
mean the member together its key; the name of the field is the key, and the
value of the field is that value of the member; no two fields in a mapping value
can have the same name.
</p>
<p>
The shape of a mapping value is an unordered collection of field shapes one for
each field. The field shape for a field f has a name, which is the same as the
name of f, and a shape, which is the shape of the value of f.
</p>
<p>
A mapping is iterable as sequence of fields, where each field is represented by
a 2-tuple <code>(<em>s</em>, <em>val</em>)</code> where <code><em>s
</em></code>is a string for the name of a field, and <code><em>val</em></code>
is the value of  the field. The order of the fields in the sequence is
implementation-dependent, but implementations are encouraged to preserve and use
the order in which the fields were added.
</p>

<p>
The type of mapping values can be described by two kinds of type descriptors.
</p>

<pre
class="grammar">mapping-type-descriptor :=
   map-type-descriptor | record-type-descriptor
</pre>
<p>
The inherent type of a mapping value must be a
<code>mapping-type-descriptor</code>. The inherent type of a mapping value
determines a type T<sub><em>f</em></sub> for the value of the field with name
<em>f</em>. The runtime system will enforce a constraint that a value written to
field <em>f</em> will belong to type T<sub><em>f</em></sub>. Note that the
constraint is not merely that the value looks like T<sub><em>f</em></sub>.
</p>
<p>
Both kinds of type descriptor are covariant in the types of their members.
</p>
<h5>Map types</h5>
<p>
A map type-descriptor describes a type of mapping value by specifying the type
that the value for all fields must belong to.
</p>

<pre
class="grammar">map-type-descriptor := <code>map</code> type-parameter
type-parameter := <code>&lt;</code> type-descriptor <code>></code>
</pre>
<p>
A type <code>map&lt;T></code> contains a mapping shape <em>m</em> if every field
shape in <em>m</em> has a value shape that is in <code>T</code>.
</p>
<p>
A value belonging to type <code>map&lt;T></code> is iterable as a sequence of
values of type <code>(string, T)</code>.
</p>
<h5>Record types</h5>
<p>
A record type descriptor describes a type of mapping value by specifying a type
separately for the value of each field.
</p>

<pre
class="grammar">record-type-descriptor :=
   inclusive-record-type-descriptor | exclusive-record-type-descriptor
inclusive-record-type-descriptor :=
   <code>record</code> <code>{</code> field-descriptor* <code>}</code>
exclusive-record-type-descriptor :=
   <code>record</code> <code>{|</code> field-descriptor* [record-rest-descriptor] <code>|}</code>
field-descriptor :=
   individual-field-descriptor | record-type-reference
individual-field-descriptor :=
   type-descriptor field-name [<code>?</code> | default-value] <code>;</code>
default-value := <code>=</code> expression
record-type-reference := <code>*</code> type-descriptor-reference <code>;</code>
record-rest-descriptor := type-descriptor <code>...</code> <code>;</code>
</pre>
<p>
Each <code>individual-field-descriptor</code> specifies an additional constraint
that a mapping value shape must satisfy for it to be a member of the described
type. The constraint depends on whether <code>?</code> is present:
</p>
<ul>
<li>if <code>?</code> is not present, then the constraint is that the mapping
value shape must have a field shape with the specified field-name and with a
value shape that is a member of the specified type-descriptor; this is called a
required field;</li>
<li>if <code>?</code> is present, then the constraint is that if the mapping
value shape has a field shape with the specified field-name, then its value
shape must be a member of the specified type-descriptor; this is called an
optional field.</li>
</ul>
<p>
The order of the <code>individual-field-descriptor</code>s within a
<code>record-type-descriptor</code> is not significant. Note that the delimited
identifier syntax allows the field name to be any non-empty string.
</p>
<p>
An exclusive-record-type-descriptor, which uses the <code>{|</code> and
<code>|}</code> delimiters, allows exclusively the fields described. More
precisely, for a mapping value shape and a record-type-descriptor, let the extra
field shapes be the field shapes of the mapping value shapes whose names are not
the same as field-name of any individual-field-descriptor; a mapping value shape
is a member of the type described by an exclusive-record-type-descriptor only if
either:
</p>
<ul>
<li>there are no extra fields shapes, or</li>
<li>there is a record-rest-descriptor <code>T...</code>, and the value shape of
every extra field shape is a member of <code>T</code>.</li>
</ul>
<p>
An inclusive-record-type-descriptor, which uses the <code>{</code> and
<code>}</code> delimiters, allows any mapping value that includes the fields
described. More precisely, a type descriptor <code>record { F };</code> is
equivalent to <code>record {| F; T...; |}</code>, where T is the type that
contains all pure shapes (which can be written as <code>anydata|error</code>).
</p>
<p>
A record type descriptor that either is an inclusive-record-type-descriptor or
is an exclusive-record-type-descriptor with a record-rest-descriptor is called
<em>open</em>; a record type descriptor that is not open is called
<em>closed</em>.
</p>
<p>
A <code>default-value</code> specifies a default value for the field, which is
used when the record type descriptor is used to construct a mapping value but no
value is specified explicitly for the field. The type descriptor contains a
0-argument function closure for each default value. The closure is created from
the expression when the type descriptor is resolved. The closure is evaluated to
create a field value each time the default is used in the construction of a
mapping value. The default value does not affect the type described by the type
descriptor.
</p>
<p>
A <code>record-type-reference</code> pulls in fields from a named record type.
The <code>type-descriptor-reference</code> must reference a type defined by a
<code>record-type-descriptor</code>. The <code>field-descriptor</code>s and any
<code>record-rest-descriptor</code> are copied into the type being defined; the
meaning is the same as if they had been specified explicitly. For default
values, the closure rather than the expression is copied in. A
<code>record-rest-descriptor</code> in the referencing type overrides any
<code>record-rest-descriptor</code> in the referenced type. For the purposes of
resolving a <code>record-type-reference</code>, a referenced or referencing type
that is an <code>inclusive-record-type-descriptor</code> is treated as if it
were the equivalent <code>exclusive-record-type-descriptor</code> with an
explicit <code>record-rest-descriptor</code>.
</p>
<h4>[Preview] Tables</h4>
<p>
A table is intended to be similar to the table of relational database table. A
table value contains an immutable set of column names and a mutable bag of rows.
Each column name is a string; each row is a mapping that associates a value with
every column name; a bag of rows is a collection of rows that is unordered and
allows duplicates.
</p>
<p>
A table value also contains a boolean flag for each column name saying whether
that column is a primary key for the table; this flag is immutable. If no
columns have this flag, then the table does not have a primary key. Otherwise
the value for all primary keys together must uniquely identify each row in the
table; in other words, a table cannot have two rows where for every column
marked as a primary key, that value of that column in both rows is the same.
</p>

<pre
class="grammar">table-type-descriptor := <code>table</code> <code>{</code> column-type-descriptor+ <code>}</code>
column-type-descriptor :=
   individual-column-type-descriptor
   | column-record-type-reference
individual-column-type-descriptor :=
   [<code>key</code>] type-descriptor column-name <code>;</code>
column-record-type-reference :=
   <code>*</code> type-reference [key-specifier (<code>,</code> key-specifier)*] <code>;</code>
key-specifier := <code>key</code> column-name
column-name := identifier
</pre>
<p>
A table type descriptor has a descriptor for each column, which specifies the
name of the column, whether that column is part of a primary key and the type
that values in that column must belong to. The type descriptor for the column
must be a pure type. If a column is part of a primary key, then the type
descriptor for the column must also allow only non-nil simple values.
</p>
<p>
Note that a table type T' will be a subtype of a table type T if and only if:
</p>
<ul>
<li>T and T' have the same set of column names;</li>
<li>T and T' have the same set of primary keys; and</li>
<li>for each column, the type for that column in T' is a subtype of the type of
that column in T.</li>
</ul>
<p>
A table is iterable as a sequence of mapping values, one for each row, where
each mapping value has a field for each column, with the column as the field
name and the value of that column in that row as the field value. The mapping
values will belong to a closed record type.
</p>
<p>
Issues:
</p>
<ul>
<li>Need to say that unique constraint is part of the value.</li>
<li>Do we want to allow values that are distinct but numerically equal e.g. -0.0
and +0.0 or 1.0 and 1 in primary key columns?</li>
</ul>
<h4>XML</h4>

<pre class="grammar">xml-type-descriptor := <code>xml</code>
</pre>
<p>
An XML value represents an immutable sequence of zero or more of the items that
can occur inside an XML element, specifically:
</p>
<ul>
<li>elements</li>
<li>characters</li>
<li>processing instructions</li>
<li>comments</li>
</ul>
<p>
The attributes of an element are represented by a map&lt;string>. The content of
each element in the sequence is itself a distinct XML value. Although the
sequence is immutable, an element can be mutated to change its content to be
another XML value.
</p>
<p>
An XML value is iterable as a sequence of its items, where each character item
is represented by a string with a single code point and other items are
represented by a singleton XML value. A single XML item, such as an element, is
represented by a sequence consisting of just that item.
</p>
<h4>Error</h4>

<pre
class="grammar">error-type-descriptor := <code>error</code> [error-type-params]
error-type-params := <code>&lt;</code> (explicit-error-type-params | inferred-error-type-param) <code>&gt;</code>
explicit-error-type-params := reason-type-descriptor [<code>,</code> detail-type-descriptor]
reason-type-descriptor := type-descriptor
detail-type-descriptor := type-descriptor
inferred-error-type-param := <code>*</code>
</pre>
<p>
An error value belongs to the error basic type, which is a basic type which is
distinct from other structured types and is used only for representing errors.
An error value contains the following information:
</p>
<ul>
<li>a reason, which is a string identifier for the category of error</li>
<li>a detail, which is a frozen mapping providing additional information about
the error</li>
<li>a stack trace</li>
</ul>
<p>
An error value is immutable, since the detail is frozen and the stack trace
information cannot be changed.
</p>
<p>
The shape of an error value consists of the shape of the reason and the shape of
the detail; the stack trace is not part of the shape. A type descriptor
error&lt;<var>r</var>, <var>d</var>&gt; contains an error shape if <var>r</var>
contains the shape's reason, and <var>d</var>, if present, contains the shape's
detail. The bare type error contains all error shapes. The
reason-type-descriptor must be a subtype of string; the detail-type-descriptor
must be a subtype of <code>record { }</code> (which is equivalent to
<code>map&lt;anydata|error&gt;</code>).
</p>
<p>
A type of <code>error&lt;*&gt;</code> means that the type is a subtype of error,
where the precise subtype is to be inferred from the context. This is allowed
only within type descriptors occurring in a context that is specified to be
inferable.
</p>
<p>
Error is the only structured basic type that is not iterable.
</p>
<h3>Behavioral values</h3>

<pre
class="grammar">behavioral-type-descriptor :=
   function-type-descriptor
   | object-type-descriptor
   | future-type-descriptor
   | service-type-descriptor
   | stream-type-descriptor
   | typedesc-type-descriptor
</pre>
<h4 id="functions">Functions</h4>

<pre
class="grammar">function-type-descriptor := <code>function</code> function-signature
function-signature := <code>(</code> param-list <code>)</code> return-type-descriptor
return-type-descriptor := [ <code>returns</code> annots type-descriptor ]
param-list :=
   required-params [<code>,</code> defaultable-params] [<code>,</code> rest-param]
   | defaultable-params [<code>,</code> rest-param]
   | [rest-param]
required-params := required-param (<code>,</code> required-param)*
required-param := annots type-descriptor param-name
defaultable-params := defaultable-param (<code>,</code> defaultable-param)*
defaultable-param := annots type-descriptor param-name default-value
rest-param := annots type-descriptor <code>...</code> [param-name]
</pre>
<p>
A function is a part of a program that can be explicitly executed. In Ballerina,
a function is also a value, implying that it can be stored in variables, and
passed to or returned from functions. When a function is executed, it is passed
an argument list as input and returns a value as output.
</p>
<p>
When the execution of a function returns to its caller, it returns exactly one
value. A function that would in other programming languages not return a value
is represented in Ballerina by a function returning <code>()</code>. Note that
the function definition does not have to explicitly return <code>()</code>; a
return statement or falling off the end of the function body will implicitly
return <code>()</code>.
</p>
<p>
The argument list passed to a function consists of zero or arguments in order;
each argument is a value, but the argument list itself is not passed as a value.
The argument list must conform to the param-list as described in this section.
Usually, the compiler's type checking will ensure that this is the case; if not,
the function will panic.
</p>
<p>
It is convenient to consider the complete param-list as having a type. This type
is described by a tuple-type-descriptor that has a member-type-descriptor for
each required-param and defaultable-param, and has a tuple-rest-descriptor if
and only if there is a rest-param. The i-th member-type-descriptor of the tuple
type descriptor is the same as the type-descriptor of the i-th member of the
param-list; the type-descriptor of the tuple-rest-descriptor, if present, is the
same as the type-descriptor of the rest-param.
</p>
<p>
An argument list consisting of values v<sub>1</sub>,..., v<sub>n</sub> conforms
to a param-list that has type P, if and only if for each i with 1 &lt;= i &lt;=
n, vi belongs to T<sub>i</sub>, where T<sub>i</sub> is defined to be the type
that contains a shape s if and only if P contains a list shape whose i-th member
is s.
</p>
<p>
When an argument list is passed to a function, the non-rest parameters are
initialized from the arguments in the argument list in order. The conformance of
the argument list to the param-list declared for the function ensures that each
parameter will be initialized to a value that belongs to the declared type of
the parameter. If there is a rest-param, then that is a initialized to a newly
created lists containing the remaining arguments in the argument-list; the
inherent type of this list will be T[] where T is the type of the rest-param.
The conformance of the argument list ensures that the members of this list will
belong to type T.
</p>
<p>
A defaultable-param is a parameter for which a default value is specified. The
expression specifying the default value may refer to previous parameters by
name. For each defaultable parameter, the function's type descriptor includes a
closure that computes the default value for the parameter using the values of
previous parameters. The caller of the function uses the closures in the
function's type descriptor to compute default values for any defaultable
arguments that were not specified explicitly. These default values are included
in the argument list passed to the function. Whether a parameter is defaultable,
and what its default is, do not affect the shape of the function and thus do not
affect typing. The closures computing the defaultable parameters are created
when the type descriptor is resolved; the default value is computed by calling
the closure each time the function is called and the corresponding parameter is
not specified. Whether a parameter is defaultable is used at compile time, but
the closure that computes the default value is only used at runtime.
</p>
<p>
The name of each parameter is included in the function's type descriptor. A
caller of the function may specify parameters by name. In this case, the caller
uses the parameter name at compile time in conjunction with the type descriptor
to create the argument list. The parameter names do not affect the shape of the
function and thus do not affect typing.
</p>
<p>
The process by which the function caller creates an argument list, which may
make use of arguments specified both by position and by name, is described in
more detail in the <a href="#function_call">section on function calls</a>.
</p>
<p>
Function types are covariant in their return types and contravariant in the type
of their parameter lists. More precisely, a function type with return type R and
parameter list type P is a subtype of a function type with return type R' and
parameter list type P' if and only if R is a subtype of R' and P' is a subtype
of P. A function value f belongs to a function type T if the declared type of f
is a subtype of T.
</p>
<h4>Objects</h4>
<p>
Objects are a combination of fields along with a set of associated functions,
called methods, which can be used to manipulate them. An object's methods are
associated with the object when the object is constructed and cannot be changed
thereafter. The fields and methods of an object are in separate namespaces, so
it is possible for an object to have a field and a method with the same name.
</p>
<p>
An object type descriptor, in addition to describing the object type, also
defines a way to construct an object of this type, in particular it provides the
method definitions that are associated with the object when it is constructed.
</p>
<p>
It is also possible to have an object type descriptor that only describes an
object type and cannot be used to construct an object; this is called an
abstract object type descriptor.
</p>

<pre
class="grammar">object-type-descriptor :=
   object-type-quals <code>object</code> <code>{</code>
      object-member-descriptor*    <code>}</code>
object-type-quals :=
   [<code>abstract</code>] [<code>client</code>] | [<code>client</code>] <code>abstract</code>
object-member-descriptor :=
   object-field-descriptor
   | object-method
   | object-type-reference
</pre>
<p>
If <code>object-type-quals</code> contains the keyword <code>abstract</code>,
then the object type descriptor is an abstract object type descriptor. An
abstract object type descriptor must not have an object-ctor-function.
</p>
<p>
If <code>object-type-quals</code> contains the keyword <code>client</code>, then
the object type is a client object type. A client object type may have remote
methods; other objects types must not.
</p>
<h5>Fields</h5>

<pre
class="grammar">object-field-descriptor :=
   object-visibility-qual type-descriptor field-name [default-value]<code>;</code>
</pre>
<p>
An <code>object-field-descriptor</code> specifies a field of the object. The
names of all the fields of an object must be distinct.
</p>
<h5>Methods</h5>
<p>
Methods are functions that are associated to the object and are called via a
value of that type using a <code>method-call-expr</code>.
</p>

<pre
class="grammar">object-method := method-decl | method-defn
method-decl :=
   metadata
   object-visibility-qual [<code>remote</code>]
   <code>function</code> method-name function-signature <code>;</code>
method-defn :=
   metadata
   method-defn-quals
   <code>function</code> method-name function-signature method-body
method-defn-quals := object-visibility-qual [<code>remote</code>]
method-name := identifier
method-body := function-body
</pre>
<p>
The names of all the methods of an object must be distinct: there is no method
overloading. Method names beginning with two underscores are reserved for use by <a
href="#built-in_abstract_object_types">built-in abstract object types</a>.
</p>
<p>
Within a <code>method-body</code>, the fields and methods of the object are not
implicitly in-scope; instead the keyword <code>self</code> is bound to the
object and can be used to access fields and methods of the object.
</p>
<p>
All the methods of an object type must be either declared or defined in the
object. A <code>method-decl</code> declares a method without defining it; a
<code>method-defn</code> also supplies a definition.  An abstract object type
descriptor must not contain a <code>method-defn</code>.
</p>
<p>
A method that is declared or defined with the remote qualifier is a remote
method. A remote method is allowed only in a client object. A remote method is
invoked using a different syntax from a non-remote method.
</p>
<p>
Any method that is declared but not defined within an object that is not
abstract must be defined outside the object at the top-level of the module:
</p>

<pre
class="grammar">outside-method-defn :=
   annots
   method-defn-quals
   <code>function</code> qual-method-name function-signature function-body
qual-method-name := object-type-name <code>.</code> method-name
</pre>
<p>
The <code>method-defn-quals</code> on an outside-method-defn must contain the
same qualifiers (both <code>remote</code> and visibility qualifiers) as the
declaration of the method within the object.
</p>
<h5>Visibility</h5>

<pre
class="grammar">object-visibility-qual := [explicit-visibility-qual]
explicit-visibility-qual := <code>public</code> | <code>private</code>
</pre>
<p>
Each field and method of an object type is visible within and can be accessed
from a specific region of code, which is specified by its object-visibility-qual
as follows:
</p>
<ul>
<li>if the object-visibility qual is <code>private</code>, then the visibility
region consists of the methods defined by this object type descriptor;</li>
<li>if the object-visibility-qual is empty, then the visibility region is the
entire module containing this object type descriptor; this is called
module-level visibility;</li>
<li>if the object-visibility-qual is <code>public</code>, then the visibility region
contains all modules.</li>
</ul>
<p>
The visibility of a method or field of an abstract object type cannot be
<code>private</code>.
</p>
<h5>Typing</h5>

<p>
The shape of an object consists of an unordered collection of object field
shapes and an unordered collection of object method shapes. An object field
shape or object method shape is a triple consisting of the name of the field or
method, the visibility region, and a shape for the value of the field or for the
method's function.
</p>
<p>
An object type is inclusive, in a similar way to an
inclusive-record-type-descriptor: an object shape belongs to an object type if
it has at least the fields and methods described in the object-type-descriptor.
Thus all object values belong to the type <code>object { }</code>.
</p>
<p>
An object-type-descriptor that has a field with name f, visibility region R and
type T contains an object shape only if the object shape contains an object
field shape that has name f, visibility region R and a value shape that is
contained in T. An object-type-descriptor that has a method with name m,
visibility region R and function type T contains an object shape only if the
object shape contains an object method shape that has name m, visibility region
R and a function value that belongs to type T.
</p>
<p>
Thus an object type T' is a subtype of an object type T only if for each field
or method f of T there is a corresponding field or method f' of T such that the
type of f' in T' is a subtype of the type of f in T and the visibility region of
f' in T' is the same as the visibility region of f in T.
</p>
<p>
This implies that:
</p>
<ul>
<li>if an object type descriptor T has private fields or methods, then it is not
possible to define another object type descriptor that is a subtype of T,
and</li>
<li>if an object type descriptor T has fields or methods with module-level
visibility, then it is possible to define another object type descriptor that is
a subtype of T only within the same module as T.</li>
</ul>
 
<h5>Initialization</h5>
<p>
A non-abstract object type provides a way to initialize an object of the type.
An object is initialized by:
</p>
<ol>
<li>allocating storage for the object</li>
<li>initializing each field with its default value, if it has one</li>
<li>initializing the methods of the object using the type's method definitions</li>
<li>calling the object's <code>__init</code> method, if there is one</li>
</ol>
<p>
The return type of the <code>__init</code> method must be a subtype of the union
of error and nil, and must contain nil; if <code>__init</code> returns an error,
it means that initialization of the object failed. The <code>__init</code>
method can declare parameters in the same way as any other method.
</p>
<p>
At any point in the body of a <code>__init</code> method, the compiler
determines which fields are potentially uninitialized. A field is potentially
uninitialized at some point if that field does not have a default value and it
is not definitely assigned at that point. It is a compile error if a
<code>__init</code> method:
</p>
<ul>
<li>accesses a field at a point where it is potentially initialized, or</li>
<li>at a point where there is any potentially uninitialized value
<ul>
<li>returns nil, or</li>
<li>uses the <code>self</code> variable other than to access or modify the value of a field.</li>
</ul>
</li>
</ul>
<p>
An object must have a __init method unless all its fields have a default value.
An object without a __init method behaves as it had a __init method with no
parameters and an empty body (which will always return nil).
</p>
<p>
The visibility of the <code>__init</code> method cannot be <code>private</code>.
</p>
<h5>Object type references</h5>

<pre
class="grammar">object-type-reference :=
   <code>*</code> type-descriptor-reference <code>;</code>
</pre>
<p>
The <code>type-descriptor-reference</code> in an
<code>object-type-reference</code> must reference an abstract object type. The
object-member-descriptors from the referenced type are copied into the type
being defined; the meaning is the same as if they had been specified explicitly.
</p>
<p>
If a non-abstract object type T<sub>o</sub> has a type reference to an abstract
object type T<sub>a</sub>, then each method declared in T<sub>a</sub> must be
defined in T<sub>o</sub> using either a <code>method-defn</code> or an
<code>outside-method-defn</code> with the same visibility. If T<sub>a</sub> has
a method or field with module-level visibility, the T<sub>o</sub> must be in the
same module.
</p>
<h4>Futures</h4>

<pre
class="grammar">future-type-descriptor := <code>future</code> [type-parameter]
</pre>
<p>
A future value represents a value to be returned by a named worker.  A future
value belongs to a type <code>future&lt;T></code> if the value to be returned
belongs to T.
</p>
<p>
A value belongs to a type <code>future</code> (without the type-parameter)
if it has basic type future.
</p>
<h4>[Preview] Services</h4>

<pre
class="grammar">service-type-descriptor := <code>service</code>
</pre>
<p>
A service value contains resources and methods. A service method is similar to
an object method. A resource is a special kind of method, with associated
configuration data, that is invoked in response to network input received by a
Listener.
</p>
<p>
All service values belong to the type <code>service</code>.
</p>
<p>
It is planned that a future version of Ballerina will provide a mechanism that
allows more precise typing of services. In the meantime, implementations can use
annotations on type definitions to support this.
</p>
<h4>[Preview] Streams</h4>

<pre
class="grammar">stream-type-descriptor := <code>stream</code> [type-parameter]
</pre>
<p>
A value of type <code>stream&lt;T></code> is a distributor for values of type
<code>T</code>: when a value v of type T is put into the stream, a function will
be called for each subscriber to the stream with v as an argument. T must be a
pure type.
</p>
<p>
A value belongs to a type <code>stream</code> (without the type-parameter)
if it has basic type stream.
</p>

<h4>Type descriptors</h4>
<pre
class="grammar">typedesc-type-descriptor := <code>typedesc</code> [type-parameter]
</pre>
<p>
A type descriptor value is an immutable value representing a resolved type
descriptor. The type typedesc contains all values with basic type typedesc. A
typedesc value <var>t</var> belongs to a type typedesc&lt;<var>T</var>&gt; if
and only if the type described by <code>t</code> is a subtype of <var>T</var>.
The typedesc type is thus covariant with its type parameter.
</p>
<p>
Referencing an identifier defined by a type definition in an expression context
will result in a type descriptor value.
</p>

<h3>Type descriptors</h3>
<pre
class="grammar">type-descriptor :=
   simple-type-descriptor
   | structured-type-descriptor
   | behavioral-type-descriptor
   | singleton-type-descriptor
   | union-type-descriptor
   | optional-type-descriptor
   | any-type-descriptor
   | anydata-type-descriptor
   | byte-type-descriptor
   | json-type-descriptor
   | type-descriptor-reference
   | <code>(</code> type-descriptor <code>)</code>
type-descriptor-reference := qualified-identifier
</pre>
<p>
It is important to understand that the type descriptors specified in this
section do not add to the universe of values. They are just adding new ways to
describe subsets of this universe.
</p>
<h4>Singleton types</h4>

<pre
class="grammar">singleton-type-descriptor := simple-const-expr

</pre>
<p>
A singleton type is a type containing a single shape. A singleton type is
described using an compile-time constant expression for a single value: the type
contains the shape of that value. Note that it is possible for the
variable-reference within the simple-const-expr to reference a structured value.
</p>
<h4>Union types</h4>

<pre
class="grammar">union-type-descriptor := type-descriptor <code>|</code> type-descriptor
</pre>
<p>
The value space of a union type <code>T1|T2</code> is the union of
<code>T1</code> and <code>T2</code>.
</p>
<h4>Optional types</h4>

<pre
class="grammar">optional-type-descriptor := type-descriptor <code>?</code>
</pre>
<p>
A type <code>T?</code> means T optionally, and is exactly equivalent to
<code>T|()</code>.
</p>
<h4>Any Type</h4>

<pre class="grammar">any-type-descriptor := <code>any</code>
</pre>
<p>
The type descriptor <code>any</code> describes the type consisting of all values
other than errors. A value belongs to the any type if and only if its basic type
is not error. Thus all values belong to the type <code>any|error</code>. Note
that a structure with members that are errors belongs to the <code>any</code>
type.
</p>
<h4>Anydata type</h4>

<pre
class="grammar">anydata-type-descriptor := <code>anydata</code>
</pre>
<p>
The type descriptor <code>anydata</code> describes the type of all pure values
other than errors. The type <code>anydata</code> contains a shape if and only if
the shape is pure and is not the shape of an error value.
</p>
<p>
Thus the type <code>anydata|error</code> is the supertype of all pure types. The
type <code>anydata</code> is equivalent to the union
</p>

<pre
>  () | boolean | int | float | decimal | string
    | (anydata|error)[] | map&lt;anydata|error>
    | xml | table
</pre>
<h4>Byte type</h4>

<pre class="grammar">byte-type-descriptor := <code>byte</code>
</pre>
<p>
The byte type is an abbreviation for a union of the int values in the range 0 to
255 inclusive.
</p>
<h4>JSON types</h4>

<pre
class="grammar">json-type-descriptor := json

json means  () | boolean | int | float | decimal | string | json[] | map&lt;json>
</pre>
<h3 id="built-in_abstract_object_types">Built-in abstract object types</h3>
<p>
There are several abstract object types that are built-in in the sense that the
language treats objects with these types specially. Note that it is only the
types that are built-in; the names of these types are not built-in.
</p>
<p>
<strong>Note</strong> It is likely that a future version of this specification
will provide generic types, so that a library can provide definitions of these
built-in types.
</p>
<h4>Iterator</h4>
<p>
A value that is iterable as a sequence of values of type T provides a way of
creating an iterator object that matches the type
</p>

<pre
>    abstract object {
       public next() returns record {| T value; |}?;
    }
</pre>
<p>
In this specification, we refer to this type as Iterator&lt;T>.
</p>
<p>
Conceptually an iterator represents a position between members of the sequence.
Possible positions are at the beginning (immediately before the first member if
any), between members and at the end (immediately after the last member if any).
A newly created iterator is at the beginning position. For an empty sequence,
there is only one possible position which is both at the beginning and at the
end.
</p>
<p>
The <code>next()</code> method behaves as follows:
</p>
<ul>
<li>if the iterator is currently at the end position, return nil</li>
<li>otherwise
<ul>
<li>move the iterator to next position, and</li>
<li>return a record <code>{ value: v }</code> where v is the member of the
sequence between the previous position and the new position</li>
</ul>
</li>
</ul>
<p>
Note that it is not possible for the <code>next()</code> method simply to return
a member of the sequence, since a nil member would be indistinguishable from the
return value for the end position.
</p>
<h4>Iterable</h4>
<p>
An object can make itself be iterable as a sequence of values of type T by
providing a method named <code>__iterator</code> which returns a value that is a
subtype of Iterator&lt;T>. In this specification, we refer to this type as
Iterable&lt;T>.
</p>
<h4>Collection</h4>
<p>
An object can declare itself to be a collection of values of type V indexed by
keys of type K, but defining a <code>__get(K k)</code> method returning a value
of type V, that returns the value associated with key k. If the collection is
mutable, then the object can also declare a <code>__put(K k, V v)</code> method
that changes the value associated with key k to to value v. In this
specification, we refer to these types as ImmutableCollection&lt;T> and
MutableCollection&lt;T>.
</p>
<h4>Listener</h4>
<p>
The Listener type is defined as follows.
</p>

<pre>abstract object {
   function __attach (service s, string? name = ()) returns error?;
   function __start () returns error?;
   function __stop () returns error?;
}
</pre>
<p>
Note that if an implementation does precise service typing using annotations on
type definitions, it will need to treat Listener as being parameterized in the
precise service type that is used to the first argument to
<code>__attach</code>.
</p>
<h3>Abstract operations</h3>
<p>
These section specifies a number of operations that can be performed on values.
These operations are for internal use by the specification.  These operations
are named in CamelCase to distinguish them from built-in methods.
</p>
<h4>Freeze</h4>
<p>
Freeze(v) is defined for any pure value v. The result of Freeze(v) is always v.
It recursively freezes any structural values and their members, thus maintaining
the invariant that frozen values can only refer to immutable values. Freeze(v)
for a value v is already frozen or is of an immutable type (i.e. a simple type
of error) just returns v without modifying it.  Freeze(v) must terminate for any
pure value v, even if v has cycles.
</p>
<h4>Clone</h4>
<p>
Clone(v) is defined for any pure value v. It performs a deep copy, recursively
copying all structural values and their members. Clone(v) for a value v that is
frozen or of an immutable type (ie a simple type or error) returns v. If v is a
container, Clone(v) has the same inherent type as v.  The graph of references of
Clone(v) must have the same structure as that of v. This implies that the number
of distinct references reachable from Clone(v) must be the same as the number of
distinct references reachable from v.  Clone(v) must terminate for any pure
value v, even if v has cycles.
</p>
<p>
Clone(v) cannot be implemented simply by recursively calling Clone on all
members of v. Rather Clone must maintain a map that records the result of
cloning each reference value. When a Clone operation starts, this map as empty.
When cloning a reference value, it must use the result recorded in the map if
there is one.
</p>
<h4>UnfrozenClone</h4>
<p>
UnfrozenClone works the same as Clone except for its treatment of frozen values.
Whereas for a frozen value v, Clone(v) is v, UnfrozenClone(v) returns a new
value that is not frozen and that has the same shape as v. UnfrozenClone handles
values of immutable types (simple types and errors) in the same way as Clone.
Like Clone, UnfrozenClone preserves graph structure.
</p>
<h4>SameShape</h4>
<p>
SameShape(v1, v2) is defined for any pure values v1, v2. It returns true or
false depending of whether v1 and v2 have the same shape. SameShape(v1, v2) must
terminate for any pure values v1 and v2, even if v1 or v2 have cycles.
SameShape(v1, v2) returns true if v1 and v2 have the same shape, even if the
graphs of references of v1 and v2 have different structures.  If two values v1
and v2 have different basic types, then SameShape(v1, v2) will be false.
</p>
<p>
The possibility of cycles means that SameShape cannot be implemented simply by
calling SameShape recursively on members. Rather SameShape must maintaom a
mapping that records for each pair of references whether it is already in
process of comparing those references. When a SameShape operation starts, this
map is empty. Whenever it starts to compare two references, it should see
whether it has already recorded that pair (in either order), and, if it has,
proceed on the assumption that they compare equal.
</p>
<p>
SameShape(Clone(x), x) is guaranteed to be true for any pure value.
</p>
<h4>NumericConvert</h4>
<p>
NumericConvert(t, v) is defined if t is the typedesc for float, decimal or int,
and v is a numeric value. It converts v to a value in t, or returns an error,
according to the following table.
</p>
<table>
  <tr>
   <td>from  \ to</td>
   <td>float</td>
   <td>decimal</td>
   <td>int</td>
  </tr>
  <tr>
   <td>float</td>
   <td>unchanged</td>
   <td>closest math value</td>
   <td rowspan="2" >round, error for NaN or out of int range</td>
  </tr>
  <tr>
   <td>decimal</td>
   <td>closest math value</td>
   <td>unchanged</td>
  </tr>
  <tr>
   <td>int</td>
   <td>same  math value</td>
   <td>same math value</td>
   <td>unchanged</td>
  </tr>
</table>
<h3>Binding patterns and variables</h3>
<h4>Binding patterns</h4>
<p>
Binding patterns are used to support destructuring, which allows different parts
of a single structured value each to be assigned to separate variables at the
same time.
</p>

<pre
class="grammar">binding-pattern :=
   capture-binding-pattern
   | wildcard-binding-pattern
   | list-binding-pattern
   | mapping-binding-pattern
   | error-binding-pattern
capture-binding-pattern := variable-name
variable-name := identifier
wildcard-binding-pattern := <code>_</code>
list-binding-pattern := <code>[</code> list-member-binding-patterns <code>]</code>
list-member-binding-patterns :=
   binding-pattern (<code>,</code> binding-pattern)* [<code>,</code> rest-binding-pattern]
   | [ rest-binding-pattern ]
mapping-binding-pattern := <code>{</code> field-binding-patterns <code>}</code>
field-binding-patterns :=
   field-binding-pattern (<code>,</code> field-binding-pattern)* [<code>,</code> rest-binding-pattern]
   | [ rest-binding-pattern ] 
field-binding-pattern :=
   field-name <code>:</code> binding-pattern
   | variable-name
rest-binding-pattern := <code>...</code> variable-name
error-binding-pattern := <code>error</code> <code>(</code> error-arg-list-binding-pattern <code>)</code>
error-arg-list-binding-pattern :=
   simple-binding-pattern (<code>,</code> named-arg-binding-pattern)* [<code>,</code> rest-binding-pattern]
   | named-arg-binding-pattern (<code>,</code> named-arg-binding-pattern)* [<code>,</code> rest-binding-pattern]
   | [ rest-binding-pattern ]
simple-binding-pattern :=
   capture-binding-pattern
   | wildcard-binding-pattern
named-arg-binding-pattern := arg-name <code>=</code> binding-pattern
</pre>
<p>
A binding pattern may succeed or fail in matching a value. A successful match
causes values to be assigned to all the variables occurring the binding-pattern.
</p>
<p>
A binding pattern matches a value in any of the following cases.
</p>
<ul>
<li>a capture-binding-pattern always matches a value and causes the matched
value to be assigned to named variable;</li>
<li>a wildcard-binding-pattern matches a value if the value belongs to type any,
in other words if the basic type of the value is not error; it does not cause
any assignments to be made;</li>
<li>a list-binding-pattern with m binding patterns matches a list with n
members if m is less than or equal to m, and the i-th binding pattern matches
the i-th member of the list for each i in 1 to m, and either m is equal to n or
the list-binding-pattern includes a rest-binding-pattern; if there is a
rest-binding-pattern <code>...v</code>, then a successful match causes a new
list value consisting of all members of the matched list except for the the
first m values to be assigned to <code>v</code>;</li>
<li>a mapping-binding-pattern { f<sub>1</sub>: p<sub>1</sub>, f<sub>2</sub>:
p<sub>2</sub>, ..., f<sub>n</sub>: p<sub>n</sub>, r } matches a mapping value m
that includes fields f<sub>1</sub>, f<sub>2</sub>, ... , f<sub>n</sub> if
p<sub>i</sub> matches the value of field f<sub>i</sub> for each i in 1 to n; if
r is <code>...v</code> then a successful match causes a new mapping value
consisting of all the other fields to be assigned to <code>v</code>; a
field-binding-pattern consisting of just a variable-name <code>x</code> is
equivalent to a field-binding-pattern <code>x: x</code>;
</li>
<li>an error-binding-pattern error(p<sub>r</sub>, f<sub>1</sub> = p<sub>1</sub>,
f<sub>2</sub> = p<sub>2</sub>, ..., f<sub>n</sub> = p<sub>n</sub>, r) matches an
error value if it has an error reason string that matches p<sub>r</sub> and a
detail record that has fields f<sub>1</sub>, f<sub>2</sub>, ... , f<sub>n</sub> such
that p<sub>i</sub> matches the value of field f<sub>i</sub> for each i in 1 to
n; if r is <code>...v</code> then a successful match causes a new mapping value
consisting of all fields other than f<sub>1</sub>, f<sub>2</sub>, ... ,
f<sub>n</sub> to be assigned to <code>v</code>;</li>
</ul>
<p>
All the variables in a binding-pattern must be distinct e.g. (x, x) is not
allowed.
</p>
<p>
Given a type descriptor for every variable in a binding-pattern, there is a type
descriptor for the binding-pattern that will contain a value just in case that
the binding pattern successfully matches the value causing each variable to be
assigned a value belonging to the type descriptor for that variable.
</p>
<ul>
<li>for a capture-binding-pattern, the type descriptor is the type descriptor
for that variable;</li>
<li>for a wildcard-binding-pattern, the type descriptor is any</li>
<li>for a list-binding-pattern, the type descriptor is a tuple type descriptor;</li>
<li>for a mapping-binding-pattern, the type descriptor is a record type
descriptor;</li>
<li>for an error-binding-pattern, the type descriptor is an error type
descriptor.</li>
</ul>

<h4>Typed binding patterns</h4>

<pre
class="grammar">typed-binding-pattern := inferable-type-descriptor binding-pattern
inferable-type-descriptor := type-descriptor | <code>var</code>
</pre>
<p>
A typed-binding-pattern combines a type-descriptor and a binding-pattern, and is
used to create the variables occurring in the binding-pattern. If var is used
instead of a type-descriptor, it means the type is inferred. How the type is
inferred depends on the context of the typed-binding-pattern. An
inferable-type-descriptor is an inferable context for a type descriptor, which
means that <code>*</code> can be used with the type descriptor to infer certain
parts of it.
</p>
<p>
The simplest and most common form of a typed-binding-pattern is for the binding
pattern to consist of just a variable name. In this case, the variable is
constrained to contain only values matching the type descriptor.
</p>
<p>
When the binding pattern is more complicated, the binding pattern must be
consistent with the type-descriptor, so that the type-descriptor unambiguously
determines a type for each variable occurring in the binding pattern. A binding
pattern occurring in a typed-binding-pattern must also be irrefutable with
respect to the type of value against which it is to be matched. In other words,
the compiler will ensure that matching such a binding pattern against a value
will never fail at runtime.
</p>
<h4>Variable scoping</h4>
<p>
For every variable, there is place in the program that creates it. Variables are
lexically scoped: every variable has a scope which determines the region of the
program within which the variable can be referenced.
</p>
<p>
There are two kinds of scope: module scope and block scope. A variable with
module scope can be referenced anywhere within a module. Identifiers with module
scope are used to identify not only variables but other module-level entities
such as functions.
</p>
<p>
A variable with block scope can be referenced only within a particular block
(always delimited with curly braces). Block-scope variables are created by a
variety of different constructs, many of which use a typed-binding-pattern.
Parameters are treated as read-only variables with block scope.
</p>
<p>
A variable with block scope can have the same name as a variable with module
scope; the former variable will hide the latter variable while the former
variable is in scope. However, it is a compile error if a variable with block
scope has the same name as another variable with block scope and the two scopes
overlap.
</p>
<h2 id="expressions">6. Expressions</h2>

<pre
class="grammar">expression := 
   literal
   | list-constructor-expr
   | mapping-constructor-expr
   | table-constructor-expr
   | service-constructor-expr
   | string-template-expr
   | xml-expr
   | new-expr
   | variable-reference-expr
   | field-access-expr
   | annot-access-expr
   | index-expr
   | xml-attributes-expr
   | function-call-expr
   | method-call-expr
   | error-constructor-expr
   | anonymous-function-expr
   | arrow-function-expr
   | type-cast-expr
   | typeof-expr
   | unary-expr
   | multiplicative-expr
   | additive-expr
   | shift-expr
   | range-expr
   | numeric-comparison-expr
   | is-expr
   | equality-expr
   | binary-bitwise-expr
   | logical-expr
   | conditional-expr
   | check-expr
   | trap-expr
   | table-query-expr
   | <code>(</code> expression <code>)</code>
</pre>
<p>
For simplicity, the expression grammar is ambiguous. The following table shows
the various types of expression in decreasing order of precedence, together with
associativity.
</p>
<table>
  <tr>
   <td><strong>Operator</strong></td>
   <td><strong>Associativity</strong></td>
  </tr>
  <tr>
   <td>
<code>x.k</code>
<br />
<code>x.@a</code>
<br />
<code>f(x)</code>
<br />
<code>x.f(y)</code>
<br />
<code>x[y]</code>
<br />
<code>new T(x)</code>
   </td>
   <td></td>
  </tr>
  <tr>
   <td>
<code>+x</code>
<br />
<code>-x</code>
<br />
<code>~x</code>
<br />
<code>!x</code>
<br />
<code>&lt;T> x</code>
<br />
<code>typeof x</code>
   </td>
   <td></td>
  </tr>
  <tr>
   <td>
<code>x * y</code>
<br />
<code>x / y</code>
<br />
<code>x % y</code>
   </td>
   <td>left</td>
  </tr>
  <tr>
   <td><code>x + y</code>
<br />
<code>x - y</code>
   </td>
   <td>left</td>
  </tr>
  <tr>
   <td>
<code>x &lt;&lt; y</code>
<br />
<code>x >> y</code>
<br />
<code>>>></code>
   </td>
   <td>left</td>
  </tr>
  <tr>
   <td>
<code>x ... y</code>
<br />
<code>x ..&lt; y</code>
   </td>
   <td>non</td>
  </tr>
  <tr>
   <td>
<code>x &lt; y</code>
<br />
<code>x > y</code>
<br />
<code>x &lt;= y</code>
<br />
<code>x >= y</code>
<br />
<code>x is y</code>
   </td>
   <td>non</td>
  </tr>
  <tr>
   <td>
<code>x == y</code>
<br />
<code>x != y</code>
<br />
<code>x === y</code>
<br />
<code>x !== y</code>
   </td>
   <td>left</td>
  </tr>
  <tr>
   <td><code>x &amp; y</code></td>
   <td>left</td>
  </tr>
  <tr>
   <td><code>x ^ y</code></td>
   <td>left</td>
  </tr>
  <tr>
   <td><code>x | y</code>
   </td>
   <td>left</td>
  </tr>
  <tr>
   <td><code>x &amp;&amp; y</code></td>
   <td>left</td>
  </tr>
  <tr>
   <td><code>x || y</code></td>
   <td>left</td>
  </tr>
  <tr>
   <td><code>x ?: y</code></td>
   <td>right</td>
  </tr>
  <tr>
   <td><code>x ? y : z</code></td>
   <td>right</td>
  </tr>
  <tr>
   <td><code>(x) => y</code></td>
   <td>right</td>
  </tr>
</table>
<h3>Expression evaluation</h3>
<p>
When the evaluation of an expression completes normally, it produces a result,
which is a value. The evaluation of an expression may also complete abruptly.
There are two kinds of abrupt completion: check-fail and panic. With both kinds
of abrupt completion there is an associated value, which always has basic type
error.
</p>
<p>
The following sections describes how each kind expression is evaluated, assuming
that evaluation of subexpressions complete normally. Except where explicitly
stated to the contrary, expressions handle abrupt completion of subexpressions
as follows. If in the course of evaluating an expression E, the evaluation of
some subexpression E1 completes abruptly, then then evaluation of E also
completes abruptly in the same way as E1.
</p>
<h3>Static typing of expressions</h3>
<p>
A type is computed for every expression at compile type; this is called the
static type of the expression. The compiler and runtime together guarantee that
if the evaluation of an expression at runtime completes normally, then the
resulting value will belong to the static type. A type is also computed for
check-fail abrupt completion, which will be a (possibly empty) subtype of error;
however, for panic abrupt completion, no type is computed.
</p>
<p>
The detailed rules for the static typing of expressions are quite elaborate and
are not specified completely in this document. This document only mentions some
key points that programmers might need to be aware of.
</p>
<h4>Contextually expected type</h4>
<p>
For a context in which an expression occurs, there may be a type descriptor that
describes the static type that the expression is expected to have. This is
called the <em>contextually expected type</em>. For example, if a variable is
declared by a type descriptor TD, then TD will be the contextually expected type
for the expression initializing the variable. A type descriptor must be
resolved before it can be used to provide a contextually expected type.</p>
<p>
Many kinds of expression that construct values use the contextually expected
type to determine the type of value constructed, rather than requiring the type
to be specified explicitly. For each such kind of expression, there is a set of
basic types (most often consisting of a single basic type) that the value
constructed by that kind of expression will always belong to. In this case, the
contextually expected type is narrowed by intersecting it with this set of basic
types; this narrowed type is called the <em>applicable</em> contextually
expected type. The narrowing is performed on the type descriptor by first
normalizing the type descriptor into a union, where each member of the union is
not a union and describes shapes from a single basic type, and then eliminating
any members of the union with the wrong basic type; if this leaves no members,
then it is a compile-time error; if it leaves a single member of the union, then
the the applicable contextually expected type is this single member, otherwise
it is a union of the remaining members.
</p>
<p>
Note the language provides a way to say that the type of a variable is to be
inferred from the static type of the expression used to initialize the variable.
In this case, there is no contextually expected type for the evaluation of the
expression. Not having a contextually expected type is different from having a
contextually expected type that allows all values.
</p>
<h4>Precise and broad types</h4>
<p>
There is an additional complexity relating to inferring types. Expressions in
fact have two static types, a precise type and a broad type. Usually, the
precise type is used. However, in a few situations, using the precise type would
be inconvenient, and so Ballerina uses the broad type. In particular, the broad
type is used for inferring the type of an implicitly typed non-final variable.
Similarly, the broad type is used when it is necessary to infer the member type
of the inherent type of a container.
</p>
<p>
In most cases, the precise type and the broad type of an expression are the
same. For a compound expression, the broad type of an expression is computed
from the broad type of the sub-expressions in the same way as the precise type
of the expression is computed from the precise type of sub-expressions.
Therefore in most cases, there is no need to mention the distinction between
precise and broad types.
</p>
<p>
The most important case where the precise type and the broad type are different
is literals. The precise type is a singleton type containing just the shape of
the value that the literal represents, whereas the broad type is the precise
type widened to contain the entire basic type of which it is a subtype. For
example, the precise type of the string literal <code>"X"</code> is the
singleton type <code>"X"</code>, but the broad type is <code>string</code>.
</p>
<p>
For a type-cast-expr, the precise type and the broad type are the type
specified in the cast.
</p>
<h3>Casting and conversion</h3>
<p>
Ballerina makes a sharp distinction between type conversion and type casting.
</p>
<p>
Casting a value does not change the value. Any value always belongs to multiple
types. Casting means taking a value that is statically known to be of one type,
and using it in a context that requires another type; casting checks that the
value is of that other type, but does not change the value.
</p>
<p>
Conversion is a process that takes as input a value of one type and produces as
output a possibly distinct value of another type. Note that conversion does not
mutate the input value.
</p>
<p>
Ballerina always requires programmers to make conversions explicit, even between
different types of number; there are no implicit conversions.
</p>
<h3>Constant expressions</h3>

<pre
class="grammar">const-expr := 
   literal
   | list-constructor-expr
   | mapping-constructor-expr
   | table-constructor-expr
   | string-template-expr
   | xml-expr
   | constant-reference-expr
   | type-cast-expr
   | unary-expr
   | multiplicative-expr
   | additive-expr
   | shift-expr
   | range-expr
   | numeric-comparison-expr
   | is-expr
   | equality-expr
   | binary-bitwise-expr
   | logical-expr
   | conditional-expr
   | <code>(</code> const-expr <code>)</code>
</pre>
<p>
Within a <code>const-expr</code>, any nested expression must also be a
const-expr.
</p>

<pre
class="grammar">constant-reference-expr := variable-reference-expr
</pre>
<p>
A <code>constant-reference-expr</code> must reference a constant defined with
<code>module-const-decl</code>.
</p>
<p>
A <code>const-expr</code> is evaluated at compile-time. The result of a
<code>const-expr</code> is automatically frozen. Note that the syntax of
const-expr does not allow for the construction of error values.
</p>

<pre
class="grammar">simple-const-expr :=
  nil-literal
  | boolean
  | [Sign] int-literal
  | [Sign] floating-point-literal
  | string-literal
  | const-reference-expr
</pre>
<p>
A simple-const-expr is a restricted form of const-expr used in contexts where
various forms of constructor expression would not make sense. Its semantics are
the same as a const-expr.
</p>
<h3>Literals</h3>

<pre
class="grammar">literal :=
   nil-literal
   | boolean-literal
   | numeric-literal
   | string-literal
   | byte-array-literal
numeric-literal := int-literal | floating-point-literal
</pre>
<p>
A numeric-literal represents a value belonging to one of the basic types
int, float or decimal. The basic type to which the value belongs is determined
as follows:
</p>
<ul>
<li>if the numeric-literal includes a <code>FloatTypeSuffix</code>, then the
basic type is float;</li>
<li>if the numeric-literal includes a <code>DecimalTypeSuffix</code>, then the
basic type is decimal;</li>
<li>if the numeric-literal is a <code>HexFloatingPointLiteral</code>, then the
basic type is float;</li>
<li>otherwise, the basic type depends on the applicable expected numeric type
(where the possible basic types are int, float and decimal):
<ul>
<li>if the applicable contextually expected type is a subtype of decimal, then
the basic type is decimal;</li>
<li>if the applicable contextually expected type is a subtype of float, then the
basic type is float;</li>
<li>otherwise, if the numeric literal is an int-literal, then the basic type is
int;</li>
<li>otherwise, the basic type is float.</li>
</ul>
</li>
</ul>
<p>
The precise type of a numeric-literal is the singleton type containing just the
shape of the value that the numeric-literal represents. The broad type is
the basic type of which the precise type is a subset.
</p>

<pre
class="grammar">byte-array-literal := Base16Literal | Base64Literal
Base16Literal := <code>base16</code> WS <code>`</code> HexGroup* WS <code>`</code>
HexGroup := WS HexDigit WS HexDigit
Base64Literal := <code>base64</code> WS <code>`</code> Base64Group* [PaddedBase64Group] WS <code>`</code>
Base64Group :=
   WS Base64Char WS Base64Char WS Base64Char WS Base64Char
PaddedBase64Group :=
   WS Base64Char WS Base64Char WS Base64Char WS PaddingChar
   | WS Base64Char WS Base64Char WS PaddingChar WS PaddingChar
Base64Char := <code>A</code> .. <code>Z</code> | <code>a</code> .. <code>z</code> | <code>0</code> .. <code>9</code> | <code>+</code> | <code>/</code>
PaddingChar := <code>=</code>
WS := WhiteSpaceChar*
</pre>
<p>
The static type of byte-array-literal is <code>byte[N]</code>, where N is the
number of bytes encoded by the Base16Literal or Base64Literal. The inherent type
of the array value created is also <code>byte[N]</code>.
</p>
<h3>List constructor</h3>

<pre
class="grammar">list-constructor-expr := <code>[</code> [ expr-list ] <code>]</code>
expr-list = expression (<code>,</code> expression)*
</pre>
<p>
Creates a new list value. The members of the list come from evaluating each
expression in the expr-list in order.
</p>
<p>
The inherent type of the newly created list is derived from the applicable
contextually expected type. It is an error if there is no contextually expected
type. If the applicable contextually expected type is a list type descriptor,
then that used as the inherent type. If the applicable contextually expected
type is a union type descriptor, then any members of the union that do not
contain list shapes of length N will be ignored, where N is the number of
expressions in the <code>expr-list</code>; it is a compile-time error if this
does not leave a single list type descriptor, which is then used as the inherent
type. The static type of the list-constructor-expr will be the same as the
inherent type.
</p>
<p>
The type that the inherent type requires for each list member provides the
contextually expected type for the expression for the member.
</p>
<p>
Some members of a list can be filled in automatically. A member can be filled in
automatically if its type descriptor, as determined by the inherent type of the
list, provides a way to create a <em>filler</em> value. The following table
specifies the filler value for each kind of type descriptor that provides one.
</p>
<table>
<tr>
<th>Type descriptor</th>
<th>Filler value</th>
<th>When provided</th>
</tr>
<tr>
<td><code>()</code></td>
<td><code>()</code></td>
<td></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>false</code></td>
<td></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>0</code></td>
<td></td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>+0.0f</code></td>
<td></td>
</tr>
<tr>
<td><code>decimal</code></td>
<td><code>+0.0d</code></td>
<td></td>
</tr>
<tr>
<td><code>string</code></td>
<td><code>""</code></td>
<td></td>
</tr>
<tr>
<td>list type descriptor</td>
<td><code>[]</code></td>
<td>if that is a valid constructor for the type</td>
</tr>
<tr>
<td>mapping type descriptor</td>
<td><code>{ }</code></td>
<td>if that is a valid constructor for the type</td>
</tr>
<tr>
<td>table</td>
<td>empty table (with no rows)</td>
<td></td>
</tr>
<tr>
<td>object</td>
<td><code>new T()</code></td>
<td>if this is valid and its static type does not include error, where
<code>T</code> is the object type descriptor (an abstract object type will not
have a filler value)</td>
</tr>
<tr>
<td><code>xml</code></td>
<td><code>xml``</code></td>
<td></td>
</tr>
<tr>
<td><code>stream&lt;T&gt;</code></td>
<td><code>new stream&lt;T&gt;</code></td>
<td></td>
</tr>
<tr>
<td>singleton</td>
<td>the single value used to specify the type</td>
<td></td>
</tr>
<tr>
<td rowspan="2">union</td>
<td><code>()</code></td>
<td>if <code>()</code> is a member of the union</td>
</tr>
<tr>
<td>the filler value for basic type B</td>
<td>if all members of the union belong to a single basic type B,
and the filler value for B also belongs to the union</td>
</tr>
<tr>
<td><code>T?</code></td>
<td><code>()</code></td>
<td></td>
</tr>
<tr>
<td><code>any</code></td>
<td><code>()</code></td>
<td></td>
</tr>
<tr>
<td><code>anydata</code></td>
<td><code>()</code></td>
<td></td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>0</code></td>
<td></td>
</tr>
<tr>
<td><code>json</code></td>
<td><code>()</code></td>
<td></td>
</tr>
</table>
<p>
The inherent type of a list establishes either a fixed length for the list or
just a minimum length for the list, which may be zero. In the latter case, for
each <var>j</var> greater than <var>m</var>, where <var>m</var> is the minimum
length of the list, the inherent type of the list must be such that
<var>j</var>-th member can be filled in automatically. In either case, a list
constructor may specify only the first <var>k</var> members, provided that for
each <var>i</var> from <var>k</var> + 1 up to the fixed length of the list, the
<var>i</var>-th member can be filled in automatically.
</p>

<h3>Mapping constructor</h3>

<pre
class="grammar">mapping-constructor-expr := <code>{</code> [field (<code>,</code> field)*] <code>}</code>
field := (literal-field-name | computed-field-name) <code>:</code> value-expr
literal-field-name := field-name | string-literal
computed-field-name := <code>[</code> expression <code>]</code>
value-expr := expression
</pre>
<p>
A mapping-constructor-expr creates a new mapping value. An expression can be
used to specify the name of a field by enclosing the expression in square
brackets.
</p>
<p>
The inherent type of the newly created mapping is derived from the applicable
contextually expected type. It is an error if there is no contextually expected
type. If the applicable contextually expected type is a mapping type descriptor,
then that used as the inherent type. If the applicable contextually expected
type is a union type descriptor, then any members of the union that are
inconsistent with the field names specified as a literal-field-name in the
mapping-constructor-expr will be ignored; it is a compile-time error if this
does not leave a single mapping type descriptor, which is then used as the
inherent type. The static type of the mapping-constructor-expr will be the same
as the inherent type.
</p>
<p>
If the inherent type descriptor is a record type descriptor, a field will be
added to the constructed value using the default value from the type descriptor
for any field that is not specified explicitly in the mapping constructor and
that has a default value.
</p>
<p>
The type that the inherent type requires for each field provides the
contextually expected type for the value-expr for that field. The contextually
expected type for a computed-field-name is string.
</p>

<h3>[Preview] Table constructor</h3>

<pre
class="grammar">table-constructor-expr :=
   <code>table</code> <code>{</code> [column-descriptors [<code>,</code> table-rows]] <code>}</code>
column-descriptors := <code>{</code> column-descriptor (<code>,</code> column-descriptor)* <code>}</code>
column-descriptor := column-constraint* column-name
column-constraint :=
   <code>key</code>
   | <code>unique</code>
   | <code>auto</code> auto-kind 
auto-kind := auto-kind-increment
auto-kind-increment := <code>increment</code> [<code>(</code>seed<code>,</code> increment<code>)</code>]
seed := integer
increment := integer
table-rows :=  <code>[</code> table-row (<code>,</code> table-row)* <code>]</code>
table-row := <code>{</code> expression (<code>,</code> expression)* <code>}</code>
</pre>
<p>
The contextually expected type of the table-constructor-expr determines the
inherent type of the constructed value.
</p>
<p>
For example,
</p>

<pre>table {
  { key firstName, key lastName, position },
  [ 
    {"Sanjiva", "Weerawarana", "lead" },
    {"James", "Clark", "design co-lead" }
  ]
}
</pre>
<h3>Service constructor</h3>

<pre
class="grammar">service-constructor-expr := annots <code>service</code> service-body-block
service-body-block := <code>{</code> service-method-defn* <code>}</code>
service-method-defn :=
   metadata
   service-method-defn-quals
   function identifier function-signature method-body
service-method-defn-quals :=
   [explicit-visibility-qual | <code>resource</code>]
</pre>
<p>
A <code>service-constructor-expr</code> constructs a service value. The result
of evaluating a service-constructor-expr is a value of type service. If a
service-method-defn contains a resource qualifier, then it defines a resource,
otherwise it defines a method. The self variable can be used in a method-body of
a service-method-defn in the same way as for objects.
</p>
<p>
Each service value has a distinct type descriptor. (Evaluating a service
constructor thus has an effect analogous to defining an anonymous object type
and then creating a value of that type.)
</p>
<p>
The return type of a resource must be a subtype of <code>error?</code> and must contain
nil.
</p>
<h3>String template expression</h3>

<pre
class="grammar">string-template-expr := <code>string</code> BacktickString
BacktickString :=
  <code>`</code> BacktickItem* Dollar* <code>`</code>
BacktickItem :=
   BacktickSafeChar
   | BacktickDollarsSafeChar
   | Dollar* interpolation
interpolation := <code>${</code> expression <code>}</code>
BacktickSafeChar := ^ ( <code>`</code> | <code>$</code> )
BacktickDollarsSafeChar :=  <code>$</code>+ ^ ( <code>{</code> | <code>`</code> | <code>$</code>)
Dollar := <code>$</code>
</pre>
<p>
A <code>string-template-expr</code> interpolates the results of evaluating
expressions into a literal string. The static type of the expression in each
interpolation must be a simple type and must not be nil. Within a
<code>BacktickString</code>, every character that is not part of an
<code>interpolation</code> is interpreted as a literal character. A
string-template-expr is evaluated by evaluating the expression in each
interpolation in the order in which they occur, and converting the result of the
each evaluation to a string as if using by <code>&lt;string></code>. The result
of evaluating the <code>string-template-expr</code> is a string comprising the
literal characters and the results of evaluating and converting the
interpolations, in the order in which they occur in the
<code>BacktickString</code>.
</p>
<p>
A literal <code>`</code> can be included in string template by using an
interpolation <code>${"`"}</code>.
</p>
<h3>XML expression</h3>

<pre
class="grammar">xml-expr := <code>xml</code> BacktickString
</pre>
<p>
An XML expression creates an XML value as follows:
</p>
<ol>
<li>The backtick string is parsed to produce a string of literal characters with
interpolated expressions</li>
<li>The result of the previous step is parsed as XML content. More precisely, it
is parsed using the production <code>content</code> in the W3C XML
Recommendation. For the purposes of parsing as XML, each interpolated expression
is interpreted as if it were an additional character allowed by the CharData and
AttValue productions but no other. The result of this step is an XML Infoset
consisting of an ordered list of information items such as could occur as the
[children] property of an element information item, except that interpolated
expressions may occur as Character Information Item or in the [normalized value]
of an Attribute Information Item. Interpolated expressions are not allowed in
the value of a namespace attribute.</li>
<li>This infoset is then converted to an XML value, together with an ordered
list of interpolated expressions, and for each interpolated expression a
position within the XML value at which the value of the expression is to be
inserted.</li>
<li>The static type of an expression occurring in an attribute value must be a
simple type and must not be nil. The static type type of an expression occurring
in content can either be xml or a non-nil simple type.</li>
<li>When the xml-expr is evaluated, the interpolated expressions are evaluated
in the order in which they occur in the <code>BacktickString</code>, and
converted to strings if necessary. A new copy is made of the XML value and the
result of the expression evaluations are inserted into the corresponding
position in the newly created XML value. This XML value is the result of the
evaluation.</li>
</ol>
<h3>New expression</h3>

<pre
class="grammar">new-expr := explicit-new-expr | implicit-new-expr
explicit-new-expr := new type-descriptor <code>(</code> arg-list <code>)</code>
</pre>
<p>
A new-expr constructs a new object.</p>
<p>
An explicit-new-expr allocates storage for the object and initializes it,
passing the supplied arg-list to the object's <code>__init</code> method. It is
a compile error if the type-descriptor does not specify an object type or if the
arg-list does not match the signature of the object type's <code>__init</code>
method. If the result of calling the <code>__init</code> method is an error
value e, then the result of evaluating the explicit-new-expr is e; otherwise the
result is the newly initialized object.
</p>
<p>
An explicit-type-expr specifying a type descriptor T has static type T, except
that if the type of the <code>__init</code> method is E?, where E is a subtype
of error, then it has static type T|E.
</p>
<pre
class="grammar">implicit-new-expr := new [<code>(</code> arg-list <code>)</code>]
</pre>
<p>
An implicit-new-expr is equivalent to an explicit-new-expr that specifies the
applicable contextually expected type as the type descriptor. An
implicit-new-expr consisting of just <code>new</code> is equivalent to
<code>new()</code>.
</p>
<h3>Variable reference expression</h3>

<pre
class="grammar">variable-reference-expr := variable-reference
variable-reference := qualified-identifier
</pre>
<p>
A variable-reference can refer to a variable, a parameter, a constant (defined
with a module constant declaration) or a type (defined with a type definition).
</p>
<p>
If the variable-reference references a type defined with a type definition, then
the result of evaluating the variable-reference-expr is a typedesc value for
that type.
</p>
<h3>Field access expression</h3>

<pre
class="grammar">field-access-expr := expression <code>.</code> field-name
</pre>
<p>
{MISSING}
</p>
<h3>Annotation access expression</h3>

<pre
class="grammar">annot-access-expr := expression <code>@.</code> annot-tag-reference
</pre>
<p>
The annot-tag-reference must refer to an annotation tag declared with an
annotation declaration. The static type of expression must be a subtype of
<code>typedesc</code>.
</p>
<p>
An <code>annot-access-expr</code> is evaluated by first evaluating
<code>expression</code> resulting in a typedesc value <em>t</em>. If <em>t</em>
has an annotation with the tag referenced by <code>annot-tag-reference</code>,
then the result of the <code>annot-access-expr</code> is the value of that
annotation; otherwise, the result is nil.
</p>
<p>
The static type of the <code>annot-access-expr</code> is T? where T is the type
of the annotation tag.
</p>
<h3>Index expression</h3>

<pre
class="grammar">index-expr := expression <code>[</code> expression <code>]</code>
</pre>
<p>
{MISSING}
</p>
<p>
Evaluation of an index-expr that attempts to accessing a list with an out of
bounds index will complete abruptly with a panic.
</p>
<h3>[Preview] XML attributes expression</h3>

<pre
class="grammar">xml-attributes-expr := expression <code>@</code>
</pre>
<p>
Returns the attributes map of a singleton xml value, or nil if the operand is
not a singleton xml value. The result type is <code>map&lt;string>?</code>.
</p>
<h3 id="function_call">Function call expression</h3>

<pre
class="grammar">function-call-expr := [<code>start</code>] function-reference <code>(</code> arg-list <code>)</code>
function-reference := variable-reference
arg-list :=
   positional-args [<code>,</code> other-args]
   | [other-args]
positional-args := positional-arg (<code>,</code> positional-arg)*
positional-arg := expression
other-args := named-args | rest-arg
named-args := named-arg (<code>,</code> named-arg)*
named-arg := arg-name <code>=</code> expression
arg-name := identifier
rest-arg := <code>...</code> expression
</pre>
<p>
A function-call-expr is evaluated by constructing an argument list and passing
the argument list to the function referred to by the variable-name. If the
function terminates normally, then the result of the function-call-expr is the
return value of the function; otherwise the function-call-expr completes
abruptly with a panic. The static type of the function-call-expr is the return
type of the function type.
</p>
<p>
However, if <code>start</code> is specified, then the called function is
executed on a new strand, and the result of the <code>function-call-expr</code>
is a value of type future&lt;T>, where T is the return type of the function
called.
</p>
<p>
The variable-reference must refer to a variable with function type. The type
descriptor of that function type is used to construct an argument list from the
specified arg-list. Note that it is the type descriptor of the declared type of
the variable that is used for this purpose, rather than the runtime type
descriptor of the referenced function value.
</p>
<p>
The expressions occurring in the arg-list are evaluated in the order in which
they occur in the arg-list. The result of evaluating each positional-arg is
added to the argument list in order. The contextually expected type for the
expression in the i-th positional-arg is the type of the i-th parameter.
</p>
<p>
If there is a rest-arg, then it is evaluated. The result must be a list value.
Each member of the list value is added to the argument in the order that it
occurs. The static type of the list value must be such as to guarantee that the
resulting argument list will conform to the function's declared param-list. The
rest-arg is not restricted to supplying the part of the argument list that will
be bound to a rest-param, and its static type is not restricted to being an
array type. If there is rest-arg, then no parameter defaults are added.
</p>
<p>
If there is no rest-arg, then each non-rest parameter that was not supplied by
positional argument is added in order from a named parameter, if there is one,
and otherwise using the parameter default. The contextually expected type for
the expression specifying a named argument is the type declared for the
corresponding parameter. A default parameter is computed by calling the closure
in the type descriptor, passing it the previous arguments in the argument list.
It is a compile-time error if there is a non-rest parameter for which there was
no positional argument and no named argument and which is not defaultable. It is
also an error if there is a named argument for a parameter that was supplied by
a positional argument.
</p>
<p>
When a function to be called results from the evaluation of an expression that
is not merely a variable reference, the function can be called either by first
storing the value of the expression in a variable or using the <code>call</code>
built-in method on functions.
</p>

<h3>Method call expression</h3>

<pre
class="grammar">method-call-expr := [<code>start</code>] expression <code>.</code> method-name <code>(</code> arg-list <code>)</code>
</pre>
<p>
The basic type of the value that results from evaluating expression determines
how the method-name is used to lookup the method to call. If the basic type is
service or object, then the method is looked up in the object's methods;
otherwise, the method is looked up in the built-in methods of that basic type. A
method-call-expr cannot be used to call a remote method; it can only be called
by a remote-method-call-action. A method-call-expr cannot be used to invoke a
resource.
</p>
<p>
If <code>start</code> is specified, then the called method is executed on a new
strand, and the result of the <code>method-call-expr</code> is a value of type
future&lt;T>, where T is the return type of the method called.
</p>
<h3>Error constructor</h3>

<pre
class="grammar">error-constructor-expr := <code>error</code> <code>(</code> error-arg-list <code>)</code>
error-arg-list :=
   positional-arg (<code>,</code> named-arg)*
   | [named-arg (<code>,</code> named-arg)*]
</pre>
<p>
An error-constructor-expr constructs a new error value. The positional-arg, if
present, specifies the error reason string. Each named-arg specifies a field of
the error detail mapping. The static type of positional-arg must be a subtype of
string; the static type of each named-arg must be a pure type. The stack trace
describes the stack at the point where the error constructor was evaluated.
</p>
<p>
If there is a contextually expected type and the type of the error reason of
the applicable contextually expected error type is a singleton string type, then
the positional-arg can be omitted and the error reason will be the single
string allowed by the type.
</p>
<p>
If there is a contextually expected type and the applicable contextually
expected type is an error type (rather than a union) with detail type
<var>d</var>, then the error detail mapping will also have a field for any
defaultable fields of <var>d</var> for which no named-arg was specified.
</p>
<p>
Evaluating the error-constructor-expr creates a new detail record. The result of
evaluating each named-arg and every defaultable arg is cloned using the Clone
abstract operation, then frozen using the Freeze abstract operation, before
being added to the detail record. The detail record is itself frozen after all
fields have been added.
</p>

<h3>Anonymous function expression</h3>

<pre
class="grammar">anonymous-function-expr :=
  annots <code>function</code> function-signature function-body-block
</pre>
<p>
Evaluating an anonymous-function-expr creates a closure, whose basic type is
function. If function-body-block refers to a block-scope variable defined
outside of the function-body-block, the closure will capture a reference to that
variable; the captured reference will refer to the same storage as the original
reference not a copy.
</p>
<h3>Arrow function expression</h3>

<pre
class="grammar">arrow-function-expr := arrow-param-list <code>=></code> expression
arrow-param-list :=
   identifier
   | <code>(</code>[identifier (<code>,</code> identifier)*]<code>)</code>
</pre>
<p>
Arrow functions provide a convenient alternative to anonymous function
expressions that can be used for many simple cases. An arrow function can only
be used in a context where a function type is expected. The types of the
parameters are inferred from the expected function type. The scope of the
parameters is <code>expression</code>. The static type of the arrow function
expression will be a function type whose return type is the static type of
<code>expression</code>. If the contextually expected type for the
<code>arrow-function-expr</code> is a function type with return type T, then the
contextually expected type for <code>expression</code> is T.
</p>
<h3>Type cast expression</h3>

<pre
class="grammar">type-cast-expr := <code>&lt;</code> type-descriptor <code>></code> expression
</pre>
<p>
A <code>type-cast-expr</code> casts the value resulting from evaluating
<code>expression</code> to the type described by the type-descriptor, performing
a numeric conversion if required.
</p>
<p>
A type-cast-expr is evaluated by first evaluating <code>expression</code>
resulting in a value v. Let T be the type described by
<code>type-descriptor</code>. If v belongs T, then the result of the
type-cast-expr is v. Otherwise, if T includes shapes from exactly one basic
numeric type N and v is belongs to another basic numeric type, then let n be
NumericConvert(N, v); if n is not an error and n belongs to T, then the result
of the type-cast-expr is n. Otherwise, the evaluation of the type-cast-expr
completes abruptly with a panic.
</p>
<p>
Let T be the static type described by <code>type-descriptor</code>, and let TE
be the static type of <code>expression</code>. Then the static type of the
<code>type-cast-expr</code> is the intersection of T and TE', where TE' is TE
with its numeric shapes transformed to take account to the possibility of the
numeric conversion specified in the previous paragraph.
</p>
<p>
The <code>type-descriptor</code> provides the contextually expected type for
<code>expression</code>.
</p>
<h3>Typeof expression</h3>

<pre
class="grammar">typeof-expr := <code>typeof</code> expression
</pre>
<p>
The result of a <code>typeof-expr</code> is a typedesc value for the runtime
type of v, where v is the result of evaluating <code>expression</code>.
</p>
<p>
The runtime type of v is the narrowest type to which v belongs.
</p>
<ul>
<li>When v is a simple value, the resulting typedesc will describe a type
consisting of a single shape, which is the shape of the value. The typedesc will
not have any annotations. Each evaluation of <code>typeof</code> with a simple
value produces a new typedesc value.</li>
<li>When v is a reference value, each evaluation of <code>typeof</code> with an
identical reference value produces an identical typedesc value. The type
descriptor resulting from <code>typeof</code> will be identical to the type
descriptor used to construct the value. For containers, this is the same as the
inherent type, except in the case where the inherent type of a structured value
has been changed by freeze or stamp methods. For behavioural values, this is the
same as the type descriptor used with new. Any annotations that were attached to
the type descriptor used to construct the value will this be available on the
constructed value.</li>
</ul>
<p>
The static type of <code>typeof-expr</code> is typedesc&lt;T>, where T is the
static type of <code>expression</code>.
</p>
<h3>Unary expression</h3>

<pre
class="grammar">unary-expr :=
   <code>+</code> expression
   | <code>-</code> expression
   | <code>~</code> expression
   | <code>!</code> expression

</pre>
<p>
The unary <code>-</code> operator performs negation. The static type of the
operand must be a number; the static type of the result is the same basic type
as the static type of the operand. The semantics for each basic type are as
follows:
</p>
<ul>
<li>int: negation for int is the same as subtraction from zero; an exception is
thrown on overflow, which happens when the operand is -2<sup>63</sup></li>
<li>float, decimal: negation for floating point types corresponds to the negate
operation as defined by IEEE 754-2008 (this is not the same as subtraction from
zero); no exceptions are thrown</li>
</ul>
<p>
The unary + operator returns the value of its operand expression. The static
type of the operand must be a number, and the static type of the result is the
same as the static type of the operand expression.
</p>
<p>
The ~ operator inverts the bits of its operand expression. The static type of
the operand must be int, and the static type of the result is an int.
</p>
<p>
The <code>!</code> operator performs logical negation. The static type of the
operand expression must be boolean. The <code>!</code> operator returns true if
its operand is false and false if its operand is true.
</p>
<h3>Multiplicative expression</h3>

<pre
class="grammar">multiplicative-expr :=
   expression <code>*</code> expression
   | expression <code>/</code> expression
   | expression <code>%</code> expression
</pre>
<p>
The <code>*</code> operator performs multiplication; the <code>/</code> operator
performs division; the <code>%</code> operator performs remainder.
</p>
<p>
The static type of both operand expressions is required to be the same basic
type; this basic type will be the static type of the result. The following basic
types are allowed:
</p>
<ul>
<li>int
<ul>
<li>* performs integer multiplication; an exception will be thrown on overflow</li>
<li>/ performs integer division, with any fractional part discarded ie with
truncation towards zero; an exception will be thrown on division by zero or on
overflow (which happens if the first operand is -2<sup>63</sup> and the second
operand is -1)</li>
<li>% performs integer remainder consistent with integer division, so that if
x/y does not throw an exception, then (x/y)*y + (x%y) is equal to x; an
exception will be thrown if the second operand is zero; if the first operand is
-2<sup>63</sup> and the second operand is -1, then the result is 0</li>
</ul>
</li>
<li>float, decimal
<ul>
<li><code>*</code> performs the multiplication operation with the destination
format being the same as the source format, as defined by IEEE 754-2008; no
exceptions are thrown</li>
<li><code>/</code> performs the division operation with the destination format
being the same as the source format, as defined by IEEE 754-2008; no exceptions
are thrown</li>
<li><code>%</code> performs a remainder operation; the remainder is not the
IEEE-defined remainder operation but is instead a remainder operation analogous
to integer remainder; more precisely,
<ul>
<li>if x is NaN or y is NaN or x is an infinity or y is a zero, then x % y is
NaN</li>
<li>for finite x, and infinite y, x % y is x</li>
<li>for finite x and finite non-zero y, x % y is equal to the result of rounding
x - (y × n)  to the nearest representable value using the roundTiesToEven
rounding mode, where n is the integer that is nearest to the mathematical
quotient of x and y without exceeding it in magnitude; if the result is zero,
then its sign is that of x</li>
<li>no exceptions are thrown</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Additive expression</h3>

<pre
class="grammar">additive-expr :=
   expression <code>+</code> expression
   | expression <code>-</code> expression
</pre>
<p>
The <code>+</code> operator is used for both addition and concatenation; the
<code>-</code> operator is used for subtraction.
</p>
<p>
It is required that either
</p>
<ul>
<li>the static type of both operand expressions is the same basic type, in which
case this basic type will be the static type of the result, or</li>
<li>the static type of one operand expression must be xml and of the other
operand expression must be string, in which case the static type of the result
is xml</li>
</ul>
<p>
The semantics for each basic type is as follows:
</p>
<ul>
<li>int
<ul>
<li>+ performs integer addition; an exception will be thrown on overflow</li>
<li>- peforns integer subtraction; an exception will be thrown on overflow</li>
</ul>
</li>
<li>float, decimal
<ul>
<li>+ performs the addition operation with the destination format being the same
as the source format, as defined by IEEE 754-2008; no exceptions are thrown</li>
<li> - performs the subtraction operation with the destination format being the
same as the source format, as defined by IEEE 754-2008; no exceptions are thrown</li>
</ul>
</li>
<li>string, xml
<ul>
<li>if both operands are a string, then the result is a string that is the
concatenation of the operands</li>
<li>if both operands are xml, then the result is a new xml sequence that is the
concatenation of the operands; the new xml sequence contains a shallow copy of
both operands; this operation does not perform a copy of the content or
attributes of any elements in sequence</li>
<li>if one operand is a string and one is xml, the string is treated as if it
were an xml sequence with one character item for each code point in the string</li>
</ul>
</li>
</ul>
<h3>Shift expression</h3>

<pre
class="grammar">shift-expr :=
   expression <code>&lt;&lt;</code> expression
   expression <code>>></code> expression
   expression <code>>>></code> expression
</pre>
<p>
A shift-expr performs a bitwise shift. Both operand expressions must have static
type that is a subtype of int. The left hand operand is the value to be shifted;
the right hand value is the shift amount; all except the bottom 6 bits of the
shift amount are masked out (as if by x &amp; 0x3F). Then a bitwise shift is
performed depending on the operator:
</p>
<ul>
<li><code>&lt;&lt;</code> performs a left shift, the bits shifted in on the
right are zero</li>
<li><code>>></code> performs  a signed right shift; the bits shifted in on the
left are the same as the most significant bit</li>
<li><code>>>></code> performs a unsigned right shift, the bits shifted in on the
left are zero</li>
</ul>
<p>
If the operator is >> or >>> and the left hand operand is a subtype of byte,
then the static type of the result is byte; otherwise the static type of the
result is int.
</p>
<h3>Range expression</h3>

<pre
class="grammar">range-expr :=
   expression <code>...</code> expression
   | expression <code>..&lt;</code> expression
</pre>
<p>
A range-expr results in a new array of integers in increasing order including
all integers n such that
</p>
<ul>
<li>the value of the first expression is less than or equal to n, and</li>
<li>n is
<ul>
<li>if the operator is <code>...</code>, less than or equal to the value of the
second expression</li>
<li>if the operator is <code>..&lt;</code>, less than the value of the second
expression</li>
</ul>
</li>
</ul>
<p>
It is a compile error if the static type of either expression is not a subtype
of int.
</p>
<p>
A range-expr is designed to be used in a foreach statement, but it can be used
anywhere.
</p>
<h3>Numerical comparison expression</h3>

<pre
class="grammar">numerical-comparison-expr :=
   expression <code>&lt;</code> expression
   | expression <code>></code> expression
   | expression <code>&lt;=</code> expression
   | expression <code>>=</code> expression
</pre>
<p>
A numerical-comparison-expr compares two numbers.
</p>
<p>
The static type of both operands must be of the same basic type, which must be
int, float or decimal. The static type of the result is boolean.
</p>
<p>
Floating point comparisons follow IEEE, 754-2008, so
</p>
<ul>
<li>if either operand is NaN, the result is false</li>
<li>positive and negative zero compare equal</li>
</ul>
<h3>Type test expression</h3>

<pre
class="grammar">is-expr :=
   expression <code>is</code> type-descriptor
</pre>
<p>
An is-expr tests where a value belongs to a type.
</p>
<p>
An is-expr is evaluated by evaluating the expression yielding a result v. If v
belongs to the type denoted by type-descriptor, then the result of the is-expr
is true; otherwise the result of the is-expr is false.
</p>
<h3>Equality expression</h3>

<pre
class="grammar">equality-expr :=
   expression <code>==</code> expression
   | expression <code>!=</code> expression
   | expression <code>===</code> expression
   | expression <code>!==</code> expression
</pre>
<p>
An equality-expr tests whether two values are equal. For all four operators, it
is a compile time error if the intersection of the static types of the operands
is empty.
</p>
<p>
The === operator tests for exact equality.  The !== operator results in the
negation of the result of the === operator.  Two values are exactly equal if
they have the same basic type T and
</p>
<ul>
<li>if T is simple type, the values are identical values within the set of
values allowed for T</li>
<li>if T is a reference type, the values refer to the same storage</li>
</ul>
<p>
The == operator tests for deep equality. The != operator results in the negation
of the result of the == operator. For both == and !=, both operands must have a
static type that is pure. Two values v1, v2 are deeply equal if SameShape(v1,
v2) is true.
</p>
<p>
Note that === and == are the same for simple values except as regards floating
point zero: == treats positive and negative zero from the same basic type as
equal whereas === treats them as unequal. Both == and === treat two NaN values
from the same basic type as equal. This means that none of these operators
correspond to operations defined by IEEE 754-2008, because they do not treat NaN
in the special way defined for those operations.
</p>
<h3>Binary bitwise expression</h3>

<pre
class="grammar">binary-bitwise-expr :=
   bitwise-and-expr
   | bitwise-xor-expr
   | bitwise-or expr
bitwise-and-expr = expression <code>&amp;</code> expression
bitwise-xor-expr = expression <code>^</code> expression
bitwise-or-expr = expression <code>|</code> expression
</pre>
<p>
A binary-bitwise-expr does a bitwise AND, XOR, or OR operation on its operands.
</p>
<p>
The static type of both operands must be a subtype of int.  The static type of
the result is as follows:
</p>
<ul>
<li>for AND, if the type of one operand is a subtype of byte, then the result
has type byte; otherwise, the result has type int;</li>
<li>for OR, if the type of both operands have a type that is a subtype of byte,
then the result has type byte; otherwise, the result has type int;</li>
<li>for XOR, the result has type int.</li>
</ul>
<h3>Logical expression</h3>

<pre
class="grammar">logical-expr :=
   expression <code>&amp;&amp;</code> expression
   | expression <code>||</code> expression
</pre>
<h3>Conditional expression</h3>

<pre
class="grammar">conditional-expr :=
   expression <code>?</code> expression <code>:</code> expression
   | expression <code>?:</code> expression
</pre>
<p>
L <code>?:</code> R is evaluated as follows:
</p>
<ol>
<li>Evaluate L to get a value x</li>
<li>If x is not nil, then return x.</li>
<li>Otherwise, return the result of evaluating R.</li>
</ol>
<h3>Check expression</h3>

<pre
class="grammar">check-expression := <code>check</code> expression
</pre>
<p>
Evaluates expression resulting in value v. If v has basic type error, then
check-expression completes abruptly with a check-fail with associated value v.
Otherwise evaluation completes normally with result v.
</p>
<p>
If the static type of expression e is T|E, where E is a subtype of error, then
the static type of check e is T.
</p>
<h3>Trap expression</h3>
<p>
The trap expression stops a panic and gives access to the error value associated
with the panic.
</p>
<pre
class="grammar">trap-expr := <code>trap</code> expression
</pre>  
<p>
Semantics are:
</p>
<ul>
<li>Evaluate <code>expression</code> resulting in value v
<ul>
<li>If evaluation completes abruptly with panic with associated value e, then
result of trap-exp is e</li>
<li>Otherwise result of trap-expr  is v</li>
</ul>
</li>
<li>If type of <code>expr</code> is T, then type of <code>trap expr</code> is
T|error.</li>
</ul>
<h2 id="actions_statements">7. Actions and statements</h2>
<h3>Actions</h3>

<pre
class="grammar">action :=
   remote-method-call-action
   | worker-receive-action 
   | wait-action
   | flush-action
   | synchronous-send-action
   | check-action
   | trap-action
   | <code>(</code> action <code>)</code>
action-or-expr := action | expression
check-action := <code>check</code> action
trap-action := <code>trap</code> action
</pre>
<p>
Actions are an intermediate syntactic category between expressions and
statements. Actions are similar to expressions, in that they yield a value.
However, an action cannot be nested inside an expression; it can only occur as
part of a statement or nested inside other actions. This is because actions are
shown in the sequence diagram in the graphical syntax.
</p>
<p>
An action is evaluated in the same way as an expression. Static typing for
actions is the same as for expressions.
</p>
<p>
A <code>check-action</code> and <code>trap-actio</code>n is evaluated in the
same way as a <code>check-exp</code>r and <code>trap-expr</code> respectively.
</p>
<h3>Function and worker execution</h3>

<pre
class="grammar">function-body-block :=
   <code>{</code> [default-worker-init, named-worker-decl+] default-worker <code>}</code>
default-worker-init := sequence-stmt
default-worker := sequence-stmt
named-worker-decl :=
   <code>worker</code> worker-name return-type-descriptor <code>{</code> sequence-stmt <code>}</code>
worker-name := identifier
</pre>
<p>
A worker represents a thread of control running within a function. A statement
is always executed in the context of a current worker. A worker is in one of
three states: running, suspended or terminated. When a worker is in the
terminated state, it has a termination value. A worker terminates either
normally or abnormally. An abnormal termination results from a panic, and in
this case the termination value is always an error. If the termination value of
a normal termination is an error, then the worker is said to have terminated
with failure; otherwise the worker is said to have terminated with success. Note
that an error termination value resulting from a normal termination is
distinguished from an error termination value resulting from an abnormal
termination.
</p>
<p>
A function always has a single default worker, which is unnamed. When a function
is called, the current worker is suspended, and a default worker for the called
function is started. When the default worker terminates, the function returns to
its caller, and the caller's worker is resumed. If the default worker terminates
normally, then its termination value provides the return value of the function.
If the default worker terminates abnormally, then the evaluation of the function
call expression completes abruptly with a panic and the default worker's
termination value provides the associated value for the abrupt completion of the
function call. The function's return type is the same as the return type of the
function's default worker.
</p>
<p>
The default worker of a function and the worker that called the function belong
to the same thread of control, which is called a <em>strand</em>. Only one
worker in a strand is running at any given time.
</p>
<p>
A function also has zero or more named workers. Each named worker runs on its
own new strand. The termination of a function is independent of the termination
of its named workers. The termination of a named worker does not automatically
result in the termination of its function. When a default worker terminates
causing the function to terminate, the function does not automatically wait for
the termination of its named workers. There is a wait-action that allows one
worker to explicitly wait for the termination of another worker.
</p>
<p>
A named worker has a return type. If the worker terminates normally, the
termination value will belong to the return type. If the return type of a worker
is not specified, it defaults to nil as for functions. A return-type-descriptor
in a named-worker-decl is an inferable context for a type descriptor, which
means that <code>*</code> can be used to infer parts of the type descriptor; in
particular, it is convenient to use <code>error&lt;*&gt;</code> to specify the
error type.
</p>
<p>
When a function has named workers, the default worker executes in three stages,
as follows:
</p>
<ol>
<li>The statements in default-worker-init are executed.</li>
<li>All the named workers are started. Each named worker executes its
sequence-stmt on its strand.</li>
<li>The statements in default-worker are executed. This happens without waiting
for the termination of the named workers started in stage 2.</li>
</ol>
<p>
Variables declared in default-worker-init are in scope within named workers,
whereas variables declared in default-worker are not.
</p>
<p>
The execution of a worker's sequence-stmt may result in the execution of a
statement that causes the worker to terminate. For example, a return statement
causes the worker to terminate. If this does not happen, then the worker
terminates as soon as it has finished executing its sequence-stmt. In this case,
the worker terminates normally, and the termination value is nil. In other
words, falling off the end of a worker is equivalent to <code>return;</code>,
which is in turn equivalent to <code>return ();</code>.
</p>
<p>
The parameters declared for a function are in scope in the function-body-block.
They are implicitly final: they can be read but not modified. They are in scope
for named workers as well as for the default worker.
</p>
<p>
The name of a worker is in-scope as a final local variable. The scope is the
function-body-block with the exception of the default-worker-init. When the
worker name is accessed using a variable-reference-expr, it has type
future&lt;T>, where T is the return type of the worker.
</p>
<p>
In the above, function includes method, and function call includes method call.
</p>
<h3>Statement execution</h3>

<pre
class="grammar">statement := 
   action-stmt
   | block-stmt
   | local-var-decl-stmt
   | local-type-defn-stmt
   | xmlns-decl-stmt
   | assignment-stmt
   | compound-assignment-stmt
   | destructuring-assignment-stmt
   | call-stmt
   | if-else-stmt
   | match-stmt
   | foreach-stmt
   | while-stmt
   | break-stmt
   | continue-stmt
   | fork-stmt
   | panic-stmt
   | lock-stmt
   | async-send-stmt
   | return-stmt
   | transaction-stmt
   | transaction-control-stmt
</pre>
<p>
The execution of any statement may involve the evaluation of actions and
expressions, and the execution of substatements. The following sections
describes how each kind of statement is evaluated, assuming that the evaluation
of those expressions and actions completes normally, and assuming that the
execution of any substatements does not cause termination of the current worker.
 Except where explicitly stated to the contrary, statements handle abrupt
completion of the evaluation of expressions and actions as follows. If in the
course of executing a statement, the evaluation of some expression or action
completes abruptly with associated value e, then the current worker is
terminated with termination value e; if the abrupt termination is a check-fail,
then the termination is normal, otherwise the termination is abnormal. If the
execution of a substatement causes termination of the current worker, then the
execution of the statement terminates at that point.
</p>

<pre
class="grammar">sequence-stmt := statement*
block-stmt := <code>{</code> sequence-stmt <code>}</code>
</pre>
<p>
A <code>sequence-stmt</code> executes its statements sequentially. A
<code>block-stmt</code> is executed by executing its <code>sequence-stmt</code>.
</p>
<h3>Fork statement</h3>

<pre
class="grammar">fork-stmt := <code>fork</code> <code>{</code> named-worker-decl+ <code>}</code>
</pre>
<p>
The fork statement starts one or more named workers, which run in parallel with
each other, each in its own new strand.
</p>
<p>
Variables and parameters in scope for the fork-stmt remain in scope within the
workers (similar to the situation with parameters and workers in a function
body).
</p>
<p>
The scope of the worker name declared in a named-worker-decl includes both other
workers in the same fork-stmt and the block containing the fork-stmt starting
from the point immediately after the fork-stmt. When a worker-name is in scope
it can be accessed using a variable-reference-expr, resulting in a value of type
future&lt;T>, where T is the return type of that worker.
</p>
<h3>Wait action</h3>
<p>
A wait-action waits for one or more workers to terminate, and gives access to
their termination values.
</p>

<pre
class="grammar">wait-action :=
   single-wait-waction
   | multiple-wait-action
   | alternate-wait-action

wait-future-expr := expression but not mapping-constructor-expr
</pre>
<p>
A wait-future-expr is used by a wait-action to refer to the worker to be waited
for. Its static type must be future&lt;T> for some T. It can use a variable
reference to refer to an in-scope named-worker-decl, which will be treated as a
reference to a variable of type future&lt;T> where T is the return value of the
worker.
</p>
<p>
Note that it is only possible to wait for a named worker, which will start its
own strand. It is not possible to wait for a default worker, which runs on an
existing strand.
</p>
<p>
A mapping-constructor-expr is not recognized as a wait-future-expr (it would not
type-check in any case).
</p>
<h4>Single wait action</h4>

<pre
class="grammar">single-wait-action := <code>wait</code> wait-future-expr
</pre>
<p>
A single-wait-action waits for a single future.
</p>
<p>
A single-wait-action is evaluated by evaluating wait-future-expr resulting in a
value f, which must be of basic type future. It then waits until the strand of
the future has terminated. If the strand terminates normally, the
single-wait-action completes normally with the termination value of the strand
as the result. Otherwise, the single-wait-action completes abruptly with a
panic, with the associated value being the termination value of the strand,
which will be an error.
</p>
<p>
If the static type of the wait-future-expr is future&lt;T> , then the static
type of the single-wait-action is then T.
</p>
<h4>Multiple wait action</h4>

<pre
class="grammar">multiple-wait-action := <code>wait</code> <code>{</code> wait-field (<code>,</code> wait-field)* <code>}</code>
wait-field :=
  variable-name
  | field-name <code>:</code> wait-future-expr
</pre>
<p>
A multiple-wait-action waits for multiple futures, returning the result as a
record.
</p>
<p>
A wait-field that is a variable-name <code>v</code> is equivalent to a
wait-field <code>v: v</code>, where <code>v</code> must be the name of an
in-scope named worker.
</p>
<p>
A multiple-wait-action is evaluated by evaluating all of the wait-future-exprs
resulting in a value of type future for each wait-field. It then waits for all
of these futures. If all the futures complete normally, then it constructs a
record with a field for each wait-field, whose name is the field-name and whose
value is the completion value of the strand.
</p>
<h4>Alternate wait action </h4>

<pre
class="grammar">alternate-wait-action := <code>wait</code> wait-future-expr (<code>|</code> wait-future-expr)+
</pre>
<p>
An alternate-wait-action waits for one of multiple futures to terminate.
</p>
<p>
An alternate-wait-action is evaluated by first evaluating all of the
wait-future-exprs, resulting in a set of future values. It then starts waiting
for all of the futures. As soon as one of the futures completes normally with a
non-error value v, the alternate-wait-action completes normally with result v.
If all of the futures complete normally with an error, then it completes
normally with result e, where e is the termination value of the last future to
complete.
</p>
<p>
If the static type of the wait-future-exprs is future&lt;T1>, future&lt;T2>, ...,
future&lt;Tn>, then the static type of the alternative-wait action is T1|T1|. .
.Tn
</p>
<h3>Worker message passing</h3>
<p>
Messages can be sent between workers.
</p>
<p>
Sends and receives are matched up at compile-time. This allows the connection
between the send and the receive to be shown in the sequence diagram. It is also
guarantees that any sent message will be received, provided that neither the
sending nor the receiving worker terminate abnormally or with an error.
</p>
<p>
Messages can only be sent between workers that are peers of each other. The
default worker and the named workers in a function are peers of each other. The
workers created in a fork-stmt are also peers of each other. The workers created
in a fork-stmt are not peers of the default worker and named workers created by
a function.
</p>

<pre
class="grammar">peer-worker := worker-name | <code>default</code>
</pre>
<p>
A worker-name refers to a worker named in a named-worker-decl, which must be in
scope; default refers to the default worker. The referenced worker must be a
peer worker.
</p>
<p>
Each worker maintains a separate logical queue for each peer worker to which it
sends messages; a sending worker sends a message by adding it to the queue; a
receiving worker receives a message by removing it from the sending worker's
queue for that worker; messages are removed in the order in which they were
added to the queue.
</p>
<h4>Send action and send statement</h4>

<pre
class="grammar">sync-send-action := expression <code>->></code> peer-worker
async-send-stmt := expression <code>-></code> peer-worker <code>;</code>
</pre>
<p>
The sync-send-action and async-send-stmt send a message to another worker. In
both cases, the message is the result of applying the Clone abstract operation
to the result of evaluating expr. The message is sent to the worker identified
by peer-worker.
</p>
<p>
In both cases, the message is added to the message queue maintained by the
sending  worker for messages to be sent to the sending worker. Conceptually, the
message is added to the queue even if the receiving worker has already
terminated.
</p>
<p>
For each async-send-stmt and sync-send-action S, the compiler determines a
unique corresponding receive-action R, such that a message sent by S will be
received by R, unless R's worker has terminated abnormally or with failure. It
is a compile-time error if this cannot be done. The compiler determines a
<em>failure type</em> for the corresponding receive-action. If the
receive-action was not executed and its worker terminated normally, then the
termination value of the worker will belong to the failure type. The failure
type will be a (possibly empty) subtype of error.
</p>
<p>
The execution of the async-send-stmt completes as soon as the message is added
to the queue. A subsequent flush action can be used to check whether the message
was received.
</p>
<p>
The sync-send-action is evaluated by waiting until the receiving worker either
executes a receive action that receives the queued message or terminates. The
evaluation of sync-send-action completes as follows:
</p>
<ul>
<li>if the queued message was received, then normally with result nil;</li>
<li>otherwise
<ul>
<li>if the receiving worker terminated with failure, then normally with the
result being the the termination value of the receiving worker, which will be an
error;</li>
<li>if the receiving worker terminated abnormally, then abruptly with a panic,
with the associated value being the termination value of the receiving worker.</li>
</ul>
</li>
</ul>
<p>
The static type of the sync-send-action is F|() where F is the failure type of
the corresponding receive action. If F is empty, then this static type will be
equivalent to ().
</p>
<p>
The contextually expected type used to interpret <code>expression</code> is the
contextually expected type from the corresponding receive-action.
</p>
<p>
If the receive-action corresponding to an async-send-stmt has a non-empty
failure type, then it is a compile-time error unless it can be determined that a
sync-send-action or a flush-action will be executed before the sending worker
terminates with success.
</p>
<p>
If a worker W is about to terminate normally and there are messages still to be
sent in a queue (which must be the result of executing an async-send-stmt), then
the worker waits until the messages have been received or some receiving worker
terminates. If a receiving worker R terminates without the message being
received, R must have terminated abnormally, because the rule in the preceding
paragraph. In this case, W terminates abnormally and W will use R's termination
value as its termination value.
</p>
<h4>Receive action</h4>

<pre
class="grammar">receive-action := single-receive-action | multiple-receive-action
</pre>
<h5>Single receive action</h5>

<pre
class="grammar">single-receive-action := <code>&lt;-</code> peer-worker
</pre>
<p>
A single-receive-action receives a message from a single worker.
</p>
<p>
For each single-receive-action R receiving from worker W, the compiler
determines a <em>corresponding send set</em>. The corresponding send set S is a
set of sync-send-actions and async-send-stmts in W, such that
</p>
<ul>
<li>in any execution of W that terminates successfully, exactly one member of S
is executed and is executed once only</li>
<li>if R is evaluated, it will receive the single message sent by a member of S,
unless W has terminated abnormally or with failure.</li>
</ul>
<p>
The compiler terminates a failure type for the corresponding send set. If no
member of the corresponding send set was executed/evaluated and the sending
worker terminated normally, then the termination value of the sending worker
will belong to the failure type. The failure type will be a (possibly empty)
subtype of error.
</p>
<p>
A single-receive-action is evaluated by waiting until there is a message
available in the queue or the sending worker terminates.  The evaluation of
single-receive-action completes as follows:
</p>
<ul>
<li>if a message becomes available in the queue, then the first available
message is removed and the evaluation completes normally with the result being
that message;</li>
<li>otherwise
<ul>
<li>if the sending worker terminated with failure, then normally with the result
being the the termination value of the sending worker, which will be an error;</li>
<li>if the sending worker terminated abnormally, then abruptly with a panic,
with the associated value being the termination value of the sending worker.</li>
</ul>
</li>
</ul>
<p>
The static type of the single-receive-action is T|F where T is the union of the
static type of the expressions in the corresponding send set and F is the
failure type of the corresponding send set.
</p>
<h5>Multiple receive action</h5>

<pre
class="grammar">multiple-receive-action :=
   <code>&lt;-</code>  <code>{</code> receive-field (<code>,</code> receive-field)* <code>}</code>
receive-field :=
   peer-worker
   | field-name <code>:</code> peer-worker
</pre>
<p>
A multiple-receive-action receives a message from multiple workers.
</p>
<p>
A peer-worker can occur at most once in a multiple-receive-action.
</p>
<p>
A receive-field consisting of a peer-worker <code>W</code> is equivalent to a
field <code>W:W</code>.
</p>
<p>
The compiler determines a corresponding send set for each receive field, in the
same way as for a single-receive-action. A multiple-receive-action is evaluated
by waiting until there is a message available in the queue for every
peer-worker.  If any of the peer workers W terminate before a message becomes
available, then the evaluation of the multiple-receive-action completes as
follows
</p>
<ul>
<li>if the sending worker terminated with failure, then normally with the result
being the the termination value of the sending worker, which will be an error;</li>
<li>if the sending worker terminated abnormally, then abruptly with a panic,
with the associated value being the termination value of the sending worker.</li>
</ul>
<p>
Otherwise, the result of the evaluation of multiple-receive-action completes by
removing the first message from each queue and constructing a record with one
field for each receive-field, where the value of the record is the message
received.
</p>
<p>
The contextually expected typed for the multiple-receive-action determines a
contextually expected type for each receive-field, in the same way as for a
mapping constructor. The contextually expected type for each receive-field
provides the contextually expected type for the expression in each member of the
corresponding send set.
</p>
<p>
The static type of multiple-receive-action is R|F where
</p>
<ul>
<li>R is a record type, where R is determined in the same way as for a mapping
constructor, where the static type of each field comes from the union of the
static types of the expressions in each member of the corresponding send set and
the contextually expected type is the contextually expected type of the
multiple-receive-action</li>
<li>F is the union of the failure types for the corresponding send set for each
receive-field</li>
</ul>
<h4>Flush action</h4>

<pre
class="grammar">flush-action := <code>flush</code> [peer-worker]
</pre>
<p>
If peer-worker is specified, then flush waits until the queue of messages to be
received by peer-worker is empty or until the peer-worker terminates.
</p>
<p>
Send-receive correspondence for async-send-stmt implies that the queue will
eventually become empty, unless the peer-worker terminates abnormally or with
failure. The evaluation of flush-action completes as follows:
</p>
<ul>
<li>if the queue of messages is empty, then normally with result nil;</li>
<li>otherwise
<ul>
<li>if the peer-worker terminated with failure, then normally with the result
being the the termination value of the peer-worker, which will be an error;</li>
<li>if the peer-worker terminated abnormally, then abruptly with a panic, with
the associated value being the termination value of the peer-worker.</li>
</ul>
</li>
</ul>
<p>
If the flush-action has a preceding async-send-stmt without any intervening
sync-send-action or other flush-action, then the static type of the flush-action
is F|(), where F is the failure type of the receive-action corresponding to that
async-send-stmt. Otherwise, the static type of the flush-action is nil.
</p>
<p>
If peer-worker is omitted, then the flush-action flushes the queues to all other
workers. In this case, the static type will be the union of the static type of
flush on each worker separately.
</p>
<h4>Send-receive correspondence</h4>
<p>
This section provides further details about how compile-time correspondence is
established between sends and receive. This is based on the concept of the index
of a message in its queue: a message has index n in its queue if it is the nth
message added to the queue during the current execution of the worker.
</p>
<ul>
<li>A send action/statement has index i in its queue if the message that it adds
to the queue is always the i-th message added to the queue during the execution
of its worker. It is a compile time error if a send statement or action does not
have an index in its queue.</li>
<li>A receive action has index i in a queue if any message that it removes from
the queue is always the i-th message removed from the queue during the execution
of its worker. It is a compile time error if a receive action does not have an
index in each of its queues.</li>
<li>A send action/statement and a receive action correspond if they have the
same index in a queue.</li>
<li>It is a compile time error if two or more receive actions have the same
index in a queue.</li>
<li>A send action/statement is in the same send set as another send
action/statement if they have the same index in a queue. It is allowed for a
send set to have more than one member.</li>
<li>The maximum index that a receive action has in a queue must be the same as
the maximum index that a send action or statement has in that queue.</li>
<li>It is a compile time error if it is possible for a worker to terminate with
success before it has executed all its receive actions.</li>
<li>It is a compile time error if it is possible for a worker to terminate with
success before it has executed one member from every send set.</li>
</ul>
<h3>Local variable declaration statements</h3>

<pre
class="grammar">local-var-decl-stmt :=
   local-init-var-decl-stmt
   | local-no-init-var-decl-stmt
local-init-var-decl-stmt :=
   annots [<code>final</code>] typed-binding-pattern <code>=</code> action-or-expr <code>;</code>
</pre>
<p>
A <code>local-var-decl-stmt</code> is used to declare variables with a scope
that is local to the block in which they occur.
</p>
<p>
The scope of variables declared in a <code>local-var-decl-stmt</code> starts
immediately after the statement and continues to the end of the block statement
in which it occurs.
</p>
<p>
A local-init-var-decl-stmt is executed by evaluating the action-or-expr
resulting in a value, and then matching the typed-binding-pattern to the value,
causing assignments to the variables occurring in the typed-binding-pattern. The
typed-binding-pattern is used unconditionally, meaning that it is a compile
error if the static types do not guarantee the success of the match. If the
typed-binding-pattern uses <code>var</code>, then the type of the variable is
inferred from the static type of the action-or-expr; if the
local-init-var-decl-stmt includes final, the precise type is used, and otherwise
the broad type is used. If the typed-binding-pattern specifies a
type-descriptor, then that type-descriptor provides the contextually expected
type for action-or-expr.
</p>
<p>
If <code>final</code> is specified, then the variables declared must not be
assigned to outside the local-init-var-decl-stmt.
</p>

<pre
class="grammar">local-no-init-var-decl-stmt :=
   annots [<code>final</code>] type-descriptor variable-name <code>;</code>
</pre>
<p>
A local variable declared <code>local-no-init-var-decl-stmt</code> must be
definitely assigned at each point that the variable is referenced. This means
that the compiler must be able to verify that the local variable will have been
assigned before that point. If <code>final</code> is specified, then the
variable must not be assigned more than once.
</p>
<h3>Implicit variable type narrowing</h3>
<p>
Usually the type of a reference to a variable is determined by the variable's
declaration, either explicitly specified by a type descriptor or inferred from
the static type of the initializer.
</p>
<p>
In addition, this section defines cases where a variable is used in certain
kinds of boolean expression in a conditional context, and it can be proved at
compile time that the value stored in local variable or parameter will, within a
particular region of code, always belong to a type that is narrower that the
static type of the variable. In these cases, references to the variable within
particular regions of code will have a static type that is narrower that the
variable type.
</p>
<p>
Given an expression E with static type boolean, and a variable x with static
type Tx, we define how to determine
</p>
<ul>
<li>a narrowed type for x implied by truth of E and</li>
<li>a narrowed type for x implied by falsity of E</li>
</ul>
<p>
based on the syntactic form of E as follows.
</p>
<ul>
<li>If E has the form x is T, then
<ul>
<li>the narrowed type for x implied by truth of E is the intersection of Tx and
T</li>
<li>the narrowed type for x implied by falsity of E is Tx with T removed</li>
</ul>
</li>
<li>If E has the form x == E1 or E1 == x where the static type of E1 is an
expression whose static type is a singleton simple type T1, then
<ul>
<li>the narrowed type for x implied by truth of E is the intersection of Tx and
T1</li>
<li>the narrowed type for x implied by falsity of E is Tx with T1 removed</li>
</ul>
</li>
<li>If E has the form x != E1 or E1 != x where the static type of E1 is an
expression whose static type is a singleton simple type T1, then
<ul>
<li>the narrowed type for x implied by truth of E is Tx with T1 removed</li>
<li>the narrowed type for x implied by falsity of E is the intersection of Tx
and T1</li>
</ul>
</li>
<li>If E has the form !E1, then
<ul>
<li>the narrowed type for x implied by truth of E is the narrowed type for x
implied by falsity of E1</li>
<li>the narrowed type for x implied by falsity of E is the narrowed type for x
implied by truth of E1</li>
</ul>
</li>
<li>If E has the form E1 &amp;&amp; E2
<ul>
<li>the narrowed type for x implied by truth of E is the intersection of T1 and
T2, where T1 is the narrowed type for x implied by the truth of T1 and T2 is the
narrowed type for x implied by the truth of T2</li>
<li>the narrowed type for x implied by falsity of E is T1|T2, where T1 is the
narrowed type for x implied by the falsity of E1, and T2 is the intersection of
T3 and T4, where T3 is the narrowed type for x implied by the truth of E1 and T4
is  the narrowed type for x implied by the falsity of E2</li>
</ul>
</li>
<li>If E has the form E1 || E2, then
<ul>
<li> the narrowed type for x implied by truth of E is T1|T2, where T1 is the
narrowed type for x implied by the truth of E1, and T2 is the intersection of T3
and T4, where T3 is the narrowed type for x implied by the falsity of E1 and T4
is the narrowed type for x implied by the truth of E2</li>
<li>the narrowed type for x implied by falsity of E is the intersection of T1
and T2, where T1 is narrowed type for x implied by the falsity of E1 and T2 is
the narrowed type for x implied by the falsity of E2</li>
</ul>
</li>
<li>If E has any other form, then
<ul>
<li>the narrowed type for x implied by the truth of E is Tx</li>
<li>the narrowed type for x implied by the falsity of E is Tx</li>
</ul>
</li>
</ul>
<p>
Narrowed types apply to regions of code as follows:
</p>
<ul>
<li>in an expression E1 || E2, the narrowed types implied by the falsity of E1
apply within E2</li>
<li>in an expression E1 &amp;&amp; E2, the narrowed types implied by the truth of E1
apply within E2</li>
<li>in an expression E1 ? E2 : E3, the narrowed types implied by the truth of E1
apply within E2 and the narrowed types implied by the falsity of E1 apply within
E3</li>
<li>in a statement if E1 { B1 } else { B2 }, the narrowed types implied by the
truth of E1 apply within B1 and the narrowed types implied by the falsity of E1
apply within E2</li>
<li>in a match-clause P if E => { B }, the narrowed types implied by the truth
of E apply within B</li>
<li>the narrowed type for a variable x no longer applies as soon as there is a
possibility of x being assigned to</li>
</ul>
<h3>Local type definition statement</h3>

<pre
class="grammar">local-type-defn-stmt :=
   annots <code>type</code> identifier type-descriptor <code>;</code>
</pre>
<p>
A local-type-defn-stmt binds the identifier to a type descriptor within the
scope of the current block. The type-descriptor is resolved when the statement
is executed.
</p>
<h3>XML namespace declaration statement</h3>

<pre
class="grammar">xmlns-decl-stmt := <code>xmlns</code> xml-namespace [ <code>as</code> identifier ] <code>;</code>
xml-namespace := simple-const-expr
</pre>
<p>
The xml-decl-stmt is used to declare a XML namespace. If the identifier is
omitted then the default namespace is defined. Once a default namespace is
defined, it is applicable for all XML values in the current scope. If an
identifier is provided then that identifier is the namespace prefix used to
qualify elements and/or attribute names.  The static type of the
simple-const-expr must be a subtype of string.
</p>
<h3>Assignment statement</h3>

<pre
class="grammar">assignment-stmt := lhs <code>=</code> action-or-expr <code>;</code>
lhs :=
   variable-reference
   | lhs <code>.</code> field-name
   | lhs <code>[</code> expression <code>]</code>
   | lhs <code>@</code>
</pre>
<p>
An <code>lhs</code> evaluates to a storage location, into which a value can be
stored and from which a value can be fetched.
</p>
<p>
When a list value has an inherent type that is not fixed length. then attempting
to write a member of a list at an index <em>i</em> that is greater than or equal
to the current length of the list will first increase the length of the list to
<em>i</em> + 1, with the newly added members of the array being filled in
automatically.
</p>
<p>
The type of lhs provides the contextually expected type for action-or-expr.
</p>
<h3>Compound assignment statement</h3>

<pre
class="grammar">compound-assignment-stmt := 
   lhs CompoundAssignmentOperator action-or-expr <code>;</code>
CompoundAssignmentOperator := BinaryOperator <code>=</code>
BinaryOperator := <code>+</code> | <code>-</code> | <code>*</code> | <code>/</code> | <code>&amp;</code> | <code>|</code> | <code>^</code> | <code>&lt;&lt;</code> | <code>>></code> | <code>>>></code>
</pre>
<p>
These statements update the value of the LHS variable to the value that results
from applying the corresponding binary operator to the value of the variable and
the value of the expression.
</p>
<h3>Destructuring assignment statement</h3>

<pre
class="grammar">destructure-assignment-stmt :=
   binding-pattern-not-variable-reference <code>=</code> action-or-expr <code>;</code>
binding-pattern-not-variable-reference :=
   wildcard-binding-pattern
   | list-binding-pattern
   | mapping-binding-pattern
   | error-binding-pattern
</pre>
<p>
A destructuring assignment is executed by evaluating the action-or-expr
resulting in a value v, and then matching the binding pattern to v, causing
assignments to the variables occurring in the binding pattern.
</p>
<p>
The binding-pattern has a static type implied by the static type of the
variables occurring in it. The static type of action-or-expr must be a subtype
of this type.
</p>
<h3>Action statement</h3>

<pre class="grammar">action-stmt := action <code>;</code>
</pre>
<p>
An action-stmt is a statement that is executed by evaluating an action and
discarding the resulting value, which must be nil. It is a compile-time error if
the static type of an action in an action-stmt is not nil.
</p>
<h3>Call statement</h3>

<pre
class="grammar">call-stmt := call-expr <code>;</code>
call-expr :=
   function-call-expr
   | method-call-expr
   | <code>check</code> call-expr
   | <code>trap</code> call-expr
</pre>
<p>
A call-stmt is executed by evaluating call-expr as an expression and discarding
the resulting value, which must be nil.  It is a compile-time error if the
static type of the call-expr in an call-stmt is not nil.
</p>
<h3>Remote method call action</h3>

<pre
class="grammar">remote-method-call-action :=
   [<code>start</code>] expression <code>-></code> method-name <code>(</code> arg-list <code>)</code>
</pre>
<p>
Calls a remote method. This works the same as a method call expression, except
that it is used only for a method with the <code>remote</code> modifier.
</p>
<p>
If <code>start</code> is specified, then the called method is executed on a new
strand, and the result of the <code>remote-method-call-expr</code> is a value of type
future&lt;T>, where T is the return type of the method called.
</p>

<h3>Conditional statement</h3>

<pre
class="grammar">if-else-stmt :=
   <code>if</code> expression block-stmt 
   [ <code>else</code> <code>if</code> expression block-stmt ]* 
   [ <code>else</code> block-stmt ]
</pre>
<p>
The if-else statement is used for conditional execution.
</p>
<p>
The static type of the expression following <code>if</code> must be boolean.
When an expression is true then the corresponding block statement is executed
and the if statement completes. If no expression is true then, if the else block
is present, the corresponding block statement is executed.
</p>
<h3>Match statement</h3>

<pre
class="grammar">match-stmt := <code>match</code> action-or-expr <code>{</code> match-clause+ <code>}</code>
match-clause :=
  match-pattern-list [match-guard] <code>=></code> block-stmt
match-guard := <code>if</code> expression
</pre>
<p>
A match statement selects a block statement to execute based on which patterns a
value matches.
</p>
<p>
A match-stmt is executed as follows:
</p>
<ol>
<li>the expression is evaluated resulting in some value v;</li>
<li>for each match-clause in order:
<ol>
<li>a match of match-pattern against v is attempted</li>
<li>if the attempted match fails, the execution of the match-stmt continues to
the next match-clause</li>
<li>if the attempted match succeeds, then the variables in match-pattern are
created</li>
<li>if there is a match-guard, then the expression in match-guard is executed
resulting in a value b</li>
<li>if b is false, then the execution of the match-stmt continues to the next
match-clause</li>
<li>otherwise, the block-stmt in the match-clause is executed</li>
<li>execution of the match-stmt completes</li>
</ol>
</li>
</ol>
<p>
The scope of any variables created in a match-pattern-list of a match-clause is
both the match-guard, if any, and the block-stmt in that match-clause. The
static type of the expression in match-guard must be a subtype of boolean.
</p>

<pre
class="grammar">match-pattern-list := 
  match-pattern (<code>|</code> match-pattern)*
</pre>
<p>
A match-pattern-list can be matched against a value. An attempted match can
succeed or fail. A match-pattern-list is matched against a value by attempting
to match each match-pattern until a match succeeds.
</p>
<p>
All the match-patterns in a given match-pattern-list must bind the same set of
variables.
</p>

<pre
class="grammar">match-pattern :=
  <code>var</code> binding-pattern
   | wildcard-match-pattern
   | const-pattern
   | list-match-pattern
   | mapping-match-pattern
   | error-match-pattern
</pre>
<p>
A match-pattern combines the destructuring done by a binding-pattern with the
ability to match a constant value.
</p>
<p>
Note that an identifier can be interpreted in two different ways within a
match-pattern:
</p>
<ul>
<li>in the scope of a <code>var</code>, an identifier names a variable which is
to be bound to a part of the matched value when a pattern match succeeds;</li>
<li>outside the scope of a var, an identifier references a constant that a value
must match for the pattern match to succeed.</li>
</ul>
<p>
A match-pattern must be linear: a variable that is to be bound cannot occur more
than once in a match-pattern.
</p>

<pre
class="grammar">const-pattern := simple-const-expr
</pre>
<p>
A const-pattern denotes a single value. Matching a const-pattern against a value
succeeds if the value has the same shape as the value denoted by the
const-pattern. A variable-reference in a const-pattern must refer to a constant.
Successfully matching a const-pattern does not cause any variables to be
created.
</p>
<p>
Matching a wildcard-match-pattern against a value succeeds if the value belongs to
type any, in other words if the basic type of the value is not error.
</p>

<pre
class="grammar">wildcard-match-pattern := <code>_</code>
list-match-pattern := <code>[</code> list-member-match-patterns <code>]</code>
list-member-match-patterns :=
   match-pattern (<code>,</code> match-pattern)* [<code>,</code> rest-match-pattern]
   | [ rest-match-pattern ]
mapping-match-pattern := <code>{</code> field-match-patterns <code>}</code>
field-match-patterns :=
   field-match-pattern (<code>,</code> field-match-pattern)* [<code>,</code> rest-match-pattern]
   | [ rest-match-pattern ] 
field-match-pattern := field-name <code>:</code> match-pattern
rest-match-pattern := <code>...</code> <code>var</code> variable-name
error-match-pattern := <code>error</code> <code>(</code> error-arg-list-match-pattern <code>)</code>
error-arg-list-match-pattern :=
   simple-match-pattern (<code>,</code> named-arg-match-pattern)* [<code>,</code> rest-match-pattern]
   | named-arg-match-pattern (<code>,</code> named-arg-match-pattern)* [<code>,</code> rest-match-pattern]
   | [ rest-match-pattern]
simple-match-pattern :=
   wildcard-match-pattern
   | const-pattern
   | <code>var</code> variable-name
named-arg-match-pattern := arg-name <code>=</code> match-pattern
</pre>

<p>
Matching a <code>mapping-match-pattern</code> against a mapping value succeeds
if and only every <code>field-match-pattern</code> matches against a field of
the value. The variable in the <code>rest-match-pattern</code>, if specified, is
bound to a new mapping that contains just the fields for which that did not
match a <code>field-match-pattern</code>.
</p>

<h3>Foreach statement</h3>

<pre
class="grammar">foreach-stmt :=
   <code>foreach</code> typed-binding-pattern <code>in</code> action-or-expr block-stmt
</pre>
<p>
A foreach statement iterates over a sequence, executing a block statement once
for each member of the sequence.
</p>
<p>
The scope of any variables created in typed-binding-pattern is block-stmt. These
variables are implicitly final.
</p>
<p>
In more detail, a foreach statement executes as follows:
</p>
<ol>
<li>evaluate the expression resulting in a value c</li>
<li>create an iterator object i from c as follows
<ol>
<li>if c is a basic type that is iterable, then i is the result of calling
c.iterator()</li>
<li>if c is an object and c belongs to Iterable&lt;T> for some T, then i is the
result of calling c.__iterator()</li>
</ol>
</li>
<li>call i.next() resulting in a value n</li>
<li>if n is nil, then terminate execution of the foreach statement</li>
<li>match typed-binding-pattern to n.value causing assignments to any variables
that were created in typed-binding-pattern</li>
<li>execute block-stmt with the variable bindings from step 5 in scope; in the
course of so doing
<ol>
<li>the execution of a break-stmt terminates execution of the foreach statement</li>
<li>the execution of a continue-stmt causes execution to proceed immediately to
step 3</li>
</ol>
</li>
<li>go back to step 3</li>
</ol>
<p>
In step 2, the compiler will give an error if the static type of expression is
not suitable for 2a or 2b.
</p>
<p>
In step 5, the typed-binding-pattern is used unconditionally, and the compiler
will check that the static types guarantee that the match will succeed. If the
typed-binding-pattern uses var, then the type will be inferred from the type of
<code>expression</code>.
</p>
<h3>While statement</h3>

<pre
class="grammar">while-stmt := <code>while</code> expression block-stmt
</pre>
<p>
A while statement repeatedly executes a block statement so long as a
boolean-valued expression evaluates to true.
</p>
<p>
In more detail, a while statement executes as follows:
</p>
<ol>
<li>evaluate expression;</li>
<li>if expression evaluates to false, terminate execution of the while
statement;</li>
<li>execute block-stmt; in the course of so doing
<ol>
<li>the execution of a break-stmt results in termination of execution of the
while statement</li>
<li>the execution of a continue-stmt causes execution to proceed immediately to
step 1</li>
</ol>
</li>
<li>go back to step 1.</li>
</ol>
<p>
The static type of <code>expression</code> must be a subtype of boolean.
</p>
<h3>Continue statement</h3>

<pre
class="grammar">continue-stmt := <code>continue</code> <code>;</code>
</pre>
<p>
A continue statement is only allowed if it is lexically enclosed within a
while-stmt or a foreach-stmt. Executing a continue statement causes execution of
the nearest enclosing while-stmt or foreach-stmt to jump to the end of the
outermost block-stmt in the while-stmt or foreach-stmt.
</p>
<h3>Break statement</h3>

<pre class="grammar">break-stmt := <code>break</code> <code>;</code>
</pre>
<p>
A break statement is only allowed if it is lexically enclosed within a
while-stmt or a foreach-stmt. Executing a break statement causes the nearest
enclosing while-stmt or foreach-stmt to terminate.
</p>
<h3>[Experimental] Lock statement</h3>

<pre
class="grammar">lock-stmt := <code>lock</code> block-stmt
</pre>
<p>
A lock statement is used to execute a series of assignment statements in a
serialized manner. For each variable that is used as an L-value within the block
statement, this statement attempts to first acquire a lock and the entire
statement executes only after acquiring all the locks. If a lock acquisition
fails after some have already been acquired then all acquired locks are released
and the process starts again.
</p>
<p>
<strong>Note</strong> <em>The design of shared data access is likely to change
in a future version.</em>
</p>
<h3>Panic statement</h3>

<pre
class="grammar">panic-stmt := <code>panic</code> expression <code>;</code>
</pre>
<p>
A panic statement terminates the current worker abnormally. The result of
evaluating <code>expression</code> provides the termination value of the worker.
</p>
<p>
The static type of <code>expression</code> must be a subtype of error.
</p>
<h3>Return statement</h3>

<pre
class="grammar">return-stmt := <code>return</code> [ action-or-expr ] <code>;</code>
</pre>
<p>
A return statement terminates the current worker normally.The result of
evaluating the action-or-expr provides the termination value of the worker. If
action-or-expr is omitted, then the termination value is nil.
</p>
<h2 id="built-in_methods">8. Built-in methods</h2>
<p>
The following built-in methods are available.
</p>
<h3>Generic methods</h3>
<p>
The following methods are provided on a variety of different basic types, with a
consistent semantics.
</p>
<h4>length</h4>
<p>
The length method returns an integer representing the number of items that a
value contains, where the meaning of item depends on the basic type of value.
The following list specifies the basic types for which it is provided, and the
meaning on each basic type:
</p>
<ul>
<li>string: is the number of code points in the string</li>
<li>list: the number of members of the list</li>
<li>mapping: the length of a mapping is the number of members in the mapping</li>
<li>table: the number of rows in the table</li>
<li>xml: the number of content items in this XML value, where each character,
element, comment and processing instructions is counted as a single content item</li>
</ul>
<h4>iterator</h4>
<p>
The iterator method is provided for all iterable basic types. It returns a new
object belonging to the Iterator&lt;T> abstract type, where T depends on the
basic type as follows:
</p>
<ul>
<li>string: T is string; it will iterate over the substrings of length 1</li>
<li>list: T is the union of the type of members of the list</li>
<li>mapping: T is (string, M) where M is the union of the types of the members
of the mapping</li>
<li>table: T is a record representing a single row</li>
<li>xml: T is string|xml</li>
</ul>
<h4>freeze, clone, unfrozenClone</h4>
<p>
The freeze, clone and unfrozenClone built-in methods work in a similar way. They
are provided on all structural types other than error, and all basic types other
than nil. When applied to a value v, the method starts by checking whether v is
a pure value; if it is not, the method returns an error. (If v belongs to type
anydata, then it is guaranteed that v is a pure value.) Otherwise, the method
returns Freeze(v), Clone(v) or UnfrozenClone(v).
</p>
<p>
The static type of the return type of applying one of these methods to an
expression of type T is T if T is a subtype of anydata, and otherwise is
T|error.
</p>
<h4>isFrozen</h4>
<p>
The isFrozen method is provided on all structural types other than error. When
applied to a value v, it returns true if the value is frozen and false
otherwise.
</p>
<h3>Floating point methods</h3>
<p>
The following  built-in methods are provided on both the decimal and float basic
types. They all return boolean.
</p>
<ul>
<li>isFinite: true iff this is neither infinity nor NaN</li>
<li>isInfinite: true iff this is infinity (plus or minus)</li>
<li>isNaN: true iff this is NaN</li>
</ul>
<h3>Error methods</h3>
<p>
The following  built-in methods are provided on the error basic type:
</p>
<ul>
<li>reason: returns the error's reason string</li>
<li>detail: returns the error's detail record as a frozen mapping</li>
<li>stackTrace: returns an object representing the stack trace of the error</li>
</ul>
<h3>Function methods</h3>
<p>
The following built-in method is provided on the function basic type:
</p>
<ul>
<li>call: <code>f.call(args)</code> means the same as <code>f(args)</code>; this
allows f to be an arbitrary expression</li>
</ul>
<h3>Typedesc methods</h3>
<p>
The stamp and convert methods are provided on typedesc values. They both take a
single parameter of type anydata, and return a value of type T|error where T is
the type denoted by the typedesc value.
</p>
<h4>stamp</h4>
<p>
The stamp method takes a single argument of type anydata.
</p>
<p>
t.stamp(v) works as follows
</p>
<ol>
<li>It checks that v is a tree. If v is a reference value, and the graph
structure of v is not a tree, then stamp returns an error.</li>
<li>If the shape of v is not a member of the set of shapes denoted by t (i.e. v
does not look like t), then stamp will attempt to modify it so that it is by
using numeric conversions (as defined by the NumericConvert operation) on
members of containers and by adding fields for which a default value is defined.
If this fails or can be done in more than one way, then stamp will return an
error. Frozen structures will not be modified, nor will new structures be
created.</li>
<li>At this point, v looks like t. Now stamp narrows the inherent type of v, and
recursively of any members of v, so that the v belongs to t, and then returns v.
Any frozen values in v are left unchanged by this.</li>
</ol>
<h4>convert</h4>
<p>
The convert method takes a single argument of type anydata. It is similar to
stamp, but it does not modify its argument.
</p>
<p>
t.convert(v) works as follows:
</p>
<ol>
<li>It checks that v is a tree. If v is a reference value, and the graph
structure of v is not a tree, then convert returns an error.</li>
<li>convert now creates a new value that has the same shape as v, except
possibly for differences in numeric types and for the addition of fields for
which a default value is defined, but belongs to type</li>
</ol>
<h2 id="module_level">9. Module-level declarations</h2>
<p>
Each source part in a Ballerina module must match the production
<code>module-part</code>.
</p>
<p>
The import declarations must come before other declarations; apart from this,
the order of the definitions and declarations at the top-level of a module is
not significant.
</p>

<pre
class="grammar">module-part := import-decl* other-decl*
other-decl := metadata other-decl-item
other-decl-item :=
   module-type-defn
   | module-const-decl
   | module-var-decl
   | listener-decl
   | function-defn
   | outside-method-defn
   | service-decl
   | xmlns-decl-stmt
   | annotation-decl
</pre>
<h3>Module and program execution</h3>
<p>
Creating a Ballerina program from a collection of modules requires that one
module is identified as the <em>root</em> module. The modules comprising the
program consist of the root module together with transitive closure of its
imported modules.
</p>
<p>
If the root module of the program has a function called <code>main</code>, then
it must be public and its return type must both be a subtype of
<code>error?</code> and contain nil. Any parameters must have a type that is a
subtype of anydata; they are not restricted to strings.
</p>
<p>
If the root module does not have a function called <code>main</code>, then there
must be at least one service declared in at least one of the program's modules.
</p>
<p>
When a Ballerina program is executed, the arguments to main come from the
command line made available by the operating system. The format of the command
line is operating system dependent, but is typically some sort of string or
array of strings. The implementation should make use of the declared parameter
types of main in attempting to convert the                  supplied command
line into an argument list acceptable to main. It may also make use of
annotations on main.
</p>
<p>
The execution of a program can terminate in one of three ways: success, failure
or abnormal. In the failure and abnormal cases, there is an associated error
value. For the failure case, the type of the error value can be determined at
compile time.
</p>
<p>
The execution of a Ballerina has two or three consecutive phases:
</p>
<ol>
<li>init</li>
<li>main</li>
<li>listen</li>
</ol>
<p>
There is always an init phase. There must be at least one of the main or listen
phases, and there may be both.
</p>
<p>
In the init phase, every module comprising the program is initialized, in such
an order than a module is always initialized after all the modules it imports
have been initialized. If a module fails to initialize, then the program
terminates.
</p>
<p>
The main phase happens only if the root module has a main function. In this
case, the main function is executed with arguments converted from the supplied
command line. If the main function returns an error, then the program
terminates.
</p>
<p>
If the main function returns nil and there is no listener registered with any
module, then the program terminates successfully.
</p>
<p>
Otherwise the listen phase happens. In  this phase, all the listeners that have
been registered with any of the modules are started, by calling their
<code>__start</code> method. (If there was no main function, then the successful
initialization of the required service declaration will ensure that at least one
listener will have been registered.)
</p>
<p>
The listen phase continues to execute until either the program explicitly exits,
by calling a standard library function, or the user explicitly requests the
termination the program using an implementation-dependent operating system
facility (such as a signal on a POSIX system). In the latter case, the program
will call the __stop request on each registered listener before terminating.
</p>
<h3>Import declaration</h3>

<pre
class="grammar">import-decl := 
   <code>import</code> [org-name <code>/</code>] pkg-name [<code>version</code> sem-ver] 
   [<code>as</code> module-identifier] <code>;</code>
module-identifier := identifier
org-name := identifier
pkg-name := identifier (<code>.</code> identifier)*
sem-ver := major-num [<code>.</code> minor-num [<code>.</code> patch-num]]
major-num := DecimalNumber
minor-num := DecimalNumber
patch-num := DecimalNumber

qualified-identifier := [module-identifier <code>:</code>] identifier
</pre>
<p>
A module-identifier in a qualified-identifier must refer to a module-identifier
specified in an import-declaration in the same source part.
</p>
<h3>Module type definition</h3>

<pre
class="grammar">module-type-defn :=
   metadata
   <code>public</code>? <code>type</code> identifier type-descriptor <code>;</code>
</pre>
<h3>Module variable declaration</h3>

<pre
class="grammar">module-var-decl :=
   metadata
   [<code>final</code>]
   typed-binding-pattern <code>=</code> expression <code>;</code>
</pre>
<p>
The scope of variables declared in a module-var-decl is the entire module. Note
that module variables are not allowed to be public. If final is specified, then
it is not allowed to assign to the variable. If the typed-binding-pattern uses
<code>var</code>, then the type of the variable is inferred from the static type
of <code>expression</code>; if the module-var-decl includes <code>final</code>,
the precise type is used, and otherwise the broad type is used. If the
typed-binding-pattern specifies a type-descriptor, then that type-descriptor
provides the contextually expected type for action-or-expr.
</p>
<h3>Module constant declaration</h3>

<pre
class="grammar">module-const-decl :=
   metadata
   <code>public</code>? <code>const</code> [type-descriptor] identifier <code>=</code> const-expr <code>;</code>
</pre>
<p>
A module-const-decl declares a compile-time constant. A compile-time constant is
an named immutable value, known at compile-time. A compile-time constant can be
used like a variable, and can also be referenced in contexts that require a
value that is known at compile-time, such as in a type-descriptor or in a
match-pattern.
</p>
<p>
The type of the constant is the singleton type containing just the shape of the
value named by the constant. The type of the constant determines the static type
of a variable-reference-expr that references this constant.
</p>
<p>
If type-descriptor is present, then it provides the contextually expected type
for the interpretation of const-expr. It is a compile-time error if the static
type of const-expr is not a subtype of that type. The type-descriptor must
specify a type that is a subtype of anydata. Note that the type-descriptor does
not specify the type of the constant, although the type of the constant will all
be a subtype of the type specified by the type-descriptor.
</p>
<h3>Listener declaration</h3>

<pre
class="grammar">listener-decl :=
   metadata
   <code>public</code>? <code>listener</code> [type-descriptor] identifier <code>=</code> expression <code>;</code>
</pre>
<p>
A <code>listener-decl</code> defines a module listener.
</p>
<p>
A module listener is an object value that belongs to the Listener abstract
object type and is managed as part of the module's lifecycle. A module may have
multiple listeners.
</p>
<p>
A module-listener can be referenced by a variable-reference, but cannot be
modified. It is this similar to a final variable declaration, except that it
also registers the value with the module as a listener.
</p>
<p>
A module listener has a static type, which must be a subtype of the Listener
type. If the type-descriptor is present it specifies the module listener's
static type; if it is not present, the the static type of the listener is the
static type of <code>expression</code>.
</p>
<h3>Function definition</h3>

<pre
class="grammar">function-defn := 
   metadata
   [<code>public</code>]
   <code>function</code> identifier function-signature function-body
function-body := function-body-block | external-function-body
external-function-body := <code>=</code> annots <code>external</code> <code>;</code>
</pre>
<p>
An <code>extern-function-body</code> means that the implementation of the
function is not provided in the Ballerina source module.
</p>
<h3>Service declaration</h3>

<pre
class="grammar">service-decl :=
  metadata
  <code>service</code> [identifier] <code>on</code> expression-list service-body-block
expression-list := expression (<code>,</code> expression)*
</pre>
<p>
Creates a service and attaches it to one or more listeners.
</p>
<p>
This works as follows:
</p>
<ul>
<li>service-body is the same as what goes inside a service constructor</li>
<li>expression is evaluated to an object obj that matches the Listener interface
or an error; if its an error then module initialization panics</li>
<li>obj is registered with the module as one of its endpoints (registering the
same object multiple times is the same as registering it once)</li>
<li>service-body-block is evaluated as in a service-constructor to get a service
value s;  the parameter type of obj.__attach determines the contextually
expected type</li>
<li>identifier, if present, works as a final variable whose value is s</li>
<li>s is attached to obj using obj.__attach; the identifier is supplied as an
argument to obj.attach along with s (nil if not present)</li>
<li>if __attach returns an error, then module initialization panics</li>
</ul>
<h2 id="querying">10. [Experimental] Querying</h2>
<p>
Ballerina tables and streams are designed for processing data at rest and data
in motion, respectively.
</p>
<h3>Table query expressions</h3>

<pre
class="grammar">table-query-expr := 
   <code>from</code> query-source [query-join-type query-join-source] 
      [query-select] [query-group-by] [query-order-by]
      [query-having] [query-limit]
query-source := identifier [<code>as</code> identifier] [query-where]
query-where := <code>where</code> expression
query-join-type := [([<code>left</code> | <code>right</code> | <code>full</code>] <code>outer</code>)| <code>inner</code>] <code>join</code>
query-join-source := query-source <code>on</code> expression
query-select := <code>select</code> (<code>*</code> | query-select-list)
query-select-list := 
   expression [<code>as</code> identifier] (, expression [<code>as</code> identifier])*
query-group-by := <code>group</code> <code>by</code> identifier (<code>,</code> identifier)*
query-order-by :=
   <code>order</code> <code>by</code> identifier [(<code>ascending</code> | <code>descending</code>)]
      (<code>,</code> identifier [(<code>ascending</code> | <code>descending</code>)])*
query-having := <code>having</code> expression
query-limit := <code>limit</code> int-literal
</pre>
<p>
Query expressions being language integrated SQL-like querying to Ballerina
tables.
</p>
<h3>Streaming queries</h3>

<pre
class="grammar">forever-stmt :=
   <code>forever</code> <code>{</code> 
      streaming-query-pattern+
   <code>}</code>
streaming-query-pattern :=
   streaming-query-expr <code>=></code> <code>(</code> array-type-descriptor identifier <code>)</code>
      block-stmt
streaming-query-expr :=
   <code>from</code> (sq-source [query-join-type sq-join-source]) | sq-pattern
      [query-select] [query-group-by] [query-order-by]
      [query-having] [query-limit] 
      [sq-output-rate-limiting]
sq-source := 
   identifier [query-where] [sq-window [query-where]] 
      [<code>as</code> identifier]*
sq-window := <code>window</code> function-call-exp
sq-join-source := sq-source <code>on</code> expression
sq-output-rate-limiting := 
   sq-time-or-event-output | sq-snapshot-output
sq-time-or-event-output := 
   (<code>all</code> | <code>last</code> | <code>first</code>) <code>every</code> int-literal (time-scale | <code>events</code>)
sq-snapshot-output :=
   <code>snapshot</code> <code>every</code> int-literal time-scale
time-scale := <code>seconds</code> | <code>minutes</code> | <code>hours</code> | <code>days</code> | <code>months</code> | <code>years</code>
sq-pattern := [<code>every</code>] sp-input [sp-within-clause]
sp-within-clause := <code>within</code> expression
sp-input :=
   sp-edge-input (<code>followed</code> <code>by</code>) | <code>,</code> streaming-pattern-input
   | <code>not</code> sp-edge-input (<code>and</code> sp-edge-input) | (<code>for</code> simple-literal)
   | [sp-edge-input ( <code>and</code> | <code>or</code> ) ] sp-edge-input
   | <code>(</code> sp-input <code>)</code>
sp-edge-input :=
   identifier [query-where] [int-range-expr] [<code>as</code> identifier]
</pre>
<p>
The forever statement is used to execute a set of streaming queries against some
number of streams concurrently and to execute a block of code when a pattern
matches. The statement will never complete and therefore the worker containing
it will never complete. See section 10 for details.
</p>
<h2 id="transactions">11. [Experimental] Transactions</h2>

<pre
class="grammar">transaction-stmt := <code>transaction</code> trans-conf? block-stmt trans-retry?
transaction-control-stmt := retry-stmt | abort-stmt
trans-conf := trans-conf-item (<code>,</code> trans-conf-item)*
trans-conf-item := trans-retries | trans-oncommit | trans-onabort
trans-retries := <code>retries</code> <code>=</code> expression
trans-oncommit := <code>oncommit</code> <code>=</code> identifier
trans-onabort := <code>onabort</code> <code>=</code> identifier
trans-retry := <code>onretry</code> block-stmt
retry-stmt := <code>retry</code> <code>;</code>
abort-stmt := <code>abort</code> <code>;</code>
</pre>
<p>
A transaction statement is used to execute a block of code within a 2PC
transaction. A transaction can be established by this statement or it may
inherit one from the current worker.
</p>
<h3>Initiated transactions</h3>
<p>
If no transaction context is present in the worker then the transaction
statement starts a new transaction (i.e., becomes the initiator) and executes
the statements within the transaction statement.
</p>
<p>
Upon completion of the block the transaction is immediately tried to be
committed. If the commit succeeds, then if there's an on-commit handler
registered that function gets invoked to signal that the commit succeeded. If
the commit fails, and if the transaction has not been retried more times than
the value of the retries configuration, then the on-retry block is executed and
the transaction block statement will execute again in its entirety. If there are
no more retries available then the commit is aborted the on-abort function is
called.
</p>
<p>
The transaction can also be explicitly aborted using an abort statement, which
will call the on-abort function and give up the transaction (without retrying).
</p>
<p>
If a retry statement is executed if the transaction has not been retried more
times than the value of the retries configuration, then the on-retry block is
executed and the transaction block statement will execute again in its entirety.
</p>
<h3>Participated transactions</h3>
<p>
If a transaction context is present in the executing worker context, then the
transaction statement joins that transaction and becomes a participant of that
existing transaction. In this case, retries will not occur as the transaction is
under the control of the initiator. Further, if the transaction is locally
aborted (by using the abort statement), the transaction gets marked for abort
and the participant will fail the transaction when it is asked to prepare for
commit by the coordinator of the initiator. When the initiating coordinator
decides to abort the transaction it will notify all the participants globally
and their on-abort functions will be invoked. If the initiating coordinator
decides to retry the transaction then a new transaction is created and the
process starts with the entire containing executable entity (i.e. resource or
function) being re-invoked with the new transaction context.
</p>
<p>
When the transaction statement reaches the end of the block the transaction is
marked as ready to commit. The actual commit will happen when the coordinator
sends a commit message to the participant and after the commit occurs the
on-commit function will be invoked. Thus, reaching the end of the transaction
statement and going past does not have the semantic of the transaction being
committed nor of it being aborted. Thus, if statements that follow the
transaction statement they are unaware whether the transaction has committed or
aborted.
</p>
<p>
When in a participating transaction, a retry statement is a no-op.
</p>
<h3>Transaction propagation</h3>
<p>
The transaction context in a worker is always visible to invoked functions. Thus
any function invoked within a transaction, which has a transaction statement
within it, will behave according to the "participated transactions" semantics
above.
</p>
<p>
The transaction context is also propagated over the network via the Ballerina
Microtransaction Protocol [XXX].
</p>
<h2 id="metadata">12. Metadata</h2>
<p>
Ballerina allows metadata to be attached to a construct by specifying the
metadata before the construct.
</p>

<pre
class="grammar">metadata := [DocumentationString] annots
</pre>
<p>
There are two forms of metadata: documentation and annotations.
</p>
<h3>Annotations</h3>

<pre
class="grammar">annots := annotation*
annotation := <code>@</code> annot-tag-reference annot-value
</pre>
<p>
Annotations provide structured metadata about a particular construct. Multiple
annotations can be applied to a single construct. An annotation consists of a
tag and a value.
</p>

<pre
class="grammar">annotation-decl :=
   metadata
   [<code>public</code>] [<code>const</code>] <code>annotation</code> [type-descriptor] annot-tag 
   [<code>on</code> annot-attach-points]
annot-tag := identifier
</pre>
<p>
An annotation-decl declares an annotation tag. Annotations tags are in a
separate namespace and cannot conflict with other module level declarations and
definitions.
</p>
<p>
The type-descriptor specifies the type of the annotation tag. The type must be a
subtype of one of the following three types: <code>true</code>,
<code>map&lt;anydata></code>, <code>map&lt;anydata>[]</code>. If the
type-descriptor is omitted, then the type is <code>true</code>.
</p>

<pre
class="grammar">annot-tag-reference := qualified-identifier
annot-value := [mapping-constructor-expr]
</pre>
<p>
An annot-tag-reference in an annotation must refer to an annot-tag declared in
an annotation declaration. If the annotation includes a
mapping-constructor-expr, then the value of the annotation is the mapping value
resulting from evaluating the mapping-constructor-expr; otherwise the value is
the boolean value <code>true</code>.
</p>
<p>
For every construct that has an annotation with a particular tag, there is an
effective value for that annotation tag, which is constructed from all the
annotations with that tag that were attached to that construct. The effective
value belongs to the type of the annotation tag.
</p>
<p>
The type of the annotation tag constrains both the annotation value and the
occurrence of multiple annotations with the same tag on a single construct as
follows.
</p>
<ul>
<li>If the type of the annotation tag is T[] for some T, then the
mapping-constructor-expr must be specified and its static type must be a subtype
of T; multiple annotations are allowed; the effective value is a list of all
annotations with the tag in the order specified.</li>
<li>Otherwise, multiple annotations with this tag are not allowed and the
effective value for the tag is the value of the single annotation with the tag.
<ul>
<li>If the type of the annotation tag is true, then the mapping-constructor-expr
must not be specified.</li>
<li>Otherwise, the mapping-constructor-expr must be specified and its static
type must be a subtype of the type of the annotation tag.</li>
</ul>
</li>
</ul>
<p>
If the annotation-decl for a tag specifies <code>const</code>, then a
mapping-constructor-expr in annotations with that tag must be a const-expr and
is evaluated at compile-time with the semantics of a const-expr. Otherwise, the
mapping-constructor-expr is evaluated when the annotation is evaluated and the
resulting value is automatically frozen.
</p>
<p>
An annotation applied to a module-level declaration is evaluated when the module
is initialized. An annotation applied to a service constructor is evaluated when
the service constructor is evaluated. An annotation occurring within a type
descriptor is evaluated when the type descriptor is resolved.
</p>

<pre
class="grammar">annot-attach-points := annot-attach-point (<code>,</code> annot-attach-point)*
annot-attach-point :=
   dual-attach-point
   | source-only-attach-point
dual-attach-point := [<code>source</code>] dual-attach-point-ident
dual-attach-point-ident :=
   [<code>object</code>] <code>type</code>
   | [<code>object</code>|<code>resource</code>] <code>function</code>
   | <code>parameter</code>
   | <code>return</code>
   | <code>service</code>
   | <code>listener</code>
source-only-attach-point := <code>source</code> source-only-attach-point-ident
source-only-attach-point-ident :=
   <code>annotation</code>
   | <code>external</code>
   | <code>var</code>
   | <code>const</code>
</pre>
<p>
The <code>annot-attach-points</code> specify the constructs to which an
annotation can be attached.
</p>
<p>
When an attachment point is prefixed with <code>source</code>, then the
annotation is attached to a fragment of the source rather than to any runtime
value, and thus is not available at runtime. If any of the attachment points
specify <code>source</code>, the annotation-decl must specify
<code>const</code>.
</p>
<p>
When an attachment point is not prefixed with source, then the annotation is
accessible at runtime by applying the annotation access operator to a typedesc
value.
</p>
<p>
The available attachment points are described in the following table.
</p>
<table>
  <tr>
   <td><strong>Attachment point name</strong></td>
   <td><strong>Syntactic attachment point(s)</strong></td>
   <td><strong>Attached to which type descriptor at runtime</strong></td>
  </tr>
  <tr>
   <td>type</td>
   <td>module-type-defn</td>
   <td>defined  type</td>
  </tr>
  <tr>
   <td>object type</td>
   <td>module-type-defn whose type descriptor is a non-abstract object type
descriptor</td>
   <td>defined type (which will be type of objects constructed using this type)</td>
  </tr>
  <tr>
   <td>function</td>
   <td>function-defn, method-decl, method-defn, outside-method-defn,
anonymous-function-expr, service-method-defn</td>
   <td>type of function</td>
  </tr>
  <tr>
   <td>resource function</td>
   <td>service-method-defn with resource modifier</td>
   <td>type of function, on service value</td>
  </tr>
  <tr>
   <td>return</td>
   <td>returns-type-descriptor</td>
   <td>indirectly to type of function</td>
  </tr>
  <tr>
   <td>parameter</td>
   <td>individual-param, rest-param</td>
   <td>indirectly to type of function</td>
  </tr>
  <tr>
   <td>service</td>
   <td>service-decl, service-constructor-expr</td>
   <td>type of service</td>
  </tr>
  <tr>
   <td>listener</td>
   <td>listener-decl</td>
   <td>type of object</td>
  </tr>
  <tr>
   <td>var</td>
   <td>module-var-decl, local-var-decl-stmt</td>
   <td>none</td>
  </tr>
  <tr>
   <td>const</td>
   <td>module-const-decl</td>
   <td>none</td>
  </tr>
  <tr>
   <td>annotation</td>
   <td>annotation-decl</td>
   <td>none</td>
  </tr>
  <tr>
   <td>external</td>
   <td>external-function-body</td>
   <td>none</td>
  </tr>
</table>
<h3>Documentation</h3>
<p>
A documentation string is an item of metadata that can be associated with
module-level Ballerina constructs and with method declarations. The purpose of
the documentation strings for a module is to enable a programmer to use the
module. Information not useful for this purpose should be provided in in
comments.
</p>
<p>
A documentation string has the format of one or more lines each of which has a
<code>#</code> optionally preceded by blank space.
</p>
<p>
The documentation statement is used to document various Ballerina constructs.
</p>

<pre
class="grammar">DocumentationString := DocumentationLine +
DocumentationLine := BlankSpace* <code>#</code> [Space] DocumentationContent
DocumentationContent := (^ 0xA)* 0xA
BlankSpace := Tab | Space
Space := 0x20
Tab := 0x9
</pre>
<p>
A <code>DocumentationString</code> is recognized only at the beginning of a
line. The content of a documentation string is the concatenation of the
<code>DocumentationContent</code> of each <code>DocumentationLine</code> in the
<code>DocumentationString</code>. Note that a single space following the # is
not treated as part of the DocumentationContent.
</p>
<p>
The content of a <code>DocumentationString</code> is parsed as Ballerina
Flavored Markdown (BFM). BFM is also used for a separate per-module
documentation file, conventionally called <code>Module.md</code>.
</p>
<h3>Ballerina Flavored Markdown</h3>
<p>
Ballerina Flavored Markdown is GitHub Flavored Markdown, with some additional
conventions.
</p>
<p>
In the documentation string attached to a function or method, there must be
documentation for each parameter, and for the return value if the return value
is not nil. The documentation for the parameters and a return value must consist
of a Markdown list, where each list item must have the form <code>ident -
doc</code>, where ident is either the parameter name or return, and doc is the
documentation of that parameter or of the return value.
</p>
<p>
The documentation for an object must contain a list of fields rather than
parameters. Private fields should not be included in the list.
</p>
<p>
BFM also provides conventions for referring to Ballerina-defined names from
within documentation strings in a source file. An identifier in backticks
<code>`X`</code>, when preceded by one of the following words:
</p>
<ul>
<li><code>type</code></li>
<li><code>endpoint</code></li>
<li><code>service</code></li>
<li><code>variable</code></li>
<li><code>var</code></li>
<li><code>annotation</code></li>
<li><code>module</code></li>
<li><code>function</code></li>
<li><code>parameter</code></li>
</ul>
<p>
is assumed to be a reference to a Ballerina-defined name of the type indicated
by the word. In the case of <code>parameter</code>, the name must be unqualified
and be the name of a parameter of the function to which the documentation string
is attached. For other cases, if the name is unqualified it must refer to a
public name of the appropriate type in the source file's module; if it is a
qualified name M:X, then the source file must have imported M, and X must refer
to a public name of an appropriate type in M. BFM also recognizes
<code>`f()`</code> as an alternative to <code>function `f`</code>. In both
cases, f can have any of the following forms (where m is a module import, x is a
function name, t is an object type name, and y is a method name):
</p>

<pre
>    x()
    m:x()
    t.y()
    m:t.y()
</pre>
<p>
Example
</p>

<pre
>    # Adds parameter `x` and parameter `y`
    # + x - one thing to be added
    # + y - another thing to be added
    # + return - the sum of them
    function add (int x, int y) returns int  { return x + y; }
</pre>
<h2 id="references">A. References</h2>
<ul>
<li>Unicode</li>
<li>XML</li>
<li>JSON</li>
<li>RFC 3629 UTF-8</li>
<li>IEEE 754-2008</li>
<li>GitHub Markdown</li>
</ul>
<h2 id="changes">B. Changes since previous versions</h2>
<h3>Summary of changes from 0.990 to 2019R1</h3>
<p>
The specification has switched to a new versioning scheme. The <var>n</var>-th
version of the specification released in year 20<var>xy</var> will be labelled
20<var>xy</var>R<var>n</var>.
</p>
<ol>
<li>Tuples types now use square brackets, rather than parentheses, as do tuple
binding patterns and tuple match patterns. Array constructors and tuple
constructors are now unified into list constructors, which use square brackets.
Tuple types can have zero members or one member, and can use <code>T...</code>
syntax allow trailing members of a specified type.</li>
<li>The way that record type descriptors express openness has changed. Instead
of the <code>!...</code> syntax, there are two flavours of record type
descriptor, which use different delimiters: <code>record {| |}</code> allows any
mapping that has exclusively the specified fields, whereas <code>record {
}</code> allows any mapping that includes the specified fields; the former can
use the <code>T...</code> syntax, whereas the latter cannot. The
<code>!...</code> is no longer allowed for record binding patterns and record
match patterns.</li>
<li>The syntax for an array with an array length that is inferred has changed
from <code>T[!...]</code> to <code>T[*]</code>.</li>
<li>A type descriptor of <code>error&lt;*&gt;</code> can be used to specify an
error type whose subtype is inferred.</li>
<li>A new expression can no longer be used to create values of structural types;
it is only allowed for objects.</li>
<li>Symbolic string literals <code>'ident</code> have been removed (compile time
constants provide a more convenient approach).</li>
<li><code>untaint</code> expression has been removed (this will be handled by
annotations instead).</li>
<li>The syntax for named arguments in a function call has reverted to
<code>arg=</code> from <code>arg:</code>, since the latter caused syntactic
ambiguities.</li>
<li>The syntax for error constructors specifies fields of the error detail
separately as named arguments, rather than specifying the error detail as a
single argument; the syntax for binding patterns and match patterns for error
values has also changed accordingly.</li>
<li>The error reason argument can be omitted from an error constructor if it
can be determined from the contextually expected type.</li>
<li>The syntax for annotation declarations has been revised; the places where
annotations are allowed has been revised to match the possible attachment
points.</li>
<li>An <code>@.</code> binary operator has been added for accessing annotations
at runtime.</li>
<li>A unary <code>typeof</code> operator has been added.</li>
<li>The <code>typedesc</code> type now takes an optional type parameter.</li>
<li>The type parameters for <code>future</code> and <code>stream</code> are now
optional.</li>
<li>The syntax for a function with an external implementation has changed to use
<code>=external</code> in place of the curly braces.</li>
<li>A numeric literal can use a suffix of <code>d</code> or <code>f</code> to
indicate that it represents a value belonging to the decimal or float type
respectively.</li>
<li>Record type descriptors may now specify a default value for fields.</li>
<li>Providing a default value for a parameter no longer affects whether a function
call must supply the argument for that parameter positionally or by name. Instead
the argument for any parameter can be supplied either positionally or by name.
To avoid ambiguity, all arguments specified positionally must be specified before
arguments specified by name.</li>
<li>Expressions specifying the default value for function parameters are not
compile time constants, and are evaluated each time they are used to supply a
missing argument.</li>
<li>In the argument list of a function or method call, positional arguments are
now required to be specified before named arguments.</li>
<li>Types may now be defined within a block.</li>
</ol>
<h3>Summary of changes from 0.980 to 0.990</h3>
<p>
<strong>Structural types and values</strong>
</p>
<ol>
<li>Concepts relating to typing of mutable structural values have been changed
in order to make type system sound.</li>
<li>The <code>match</code> statement has been redesigned.</li>
<li>The <code>but</code> expression has been removed.</li>
<li>The <code>is</code> expression for dynamic type testing has been added.</li>
<li>The type-cast-expr &lt;T>E now performs unsafe type casts.The only
conversions it performs are numeric conversions.</li>
<li>The <code>anydata</code> type has been added, which is a union of simple and
structural types.</li>
<li>Records are now by default open to <code>anydata|error</code>, rather than
<code>any</code>.</li>
<li>Type parameters for built-in types (map, stream, future), which previously
defaulted to any, are now required.</li>
<li>The type parameter for json (e.g. json&lt;T>) is not allowed any more.</li>
<li>Type for table columns are restricted to subtype of anydata|error.</li>
<li>There are now two flavors of equality operator: == and != for deep equality
(which is allowed only for <code>anydata</code>), and ===  and !== for exact
equality.</li>
<li>There is a built-in clone operation for performing a deep copy on values of
type anydata.</li>
<li>There is a built-in freeze operation for making structural values deeply
immutable.</li>
<li>Compile-time constants (which are always a subtype of anydata and frozen)
have been added.</li>
<li>Singleton types have been generalized: any compile-time constant can be made
into a singleton value.</li>
<li>Variables can be declared final, with a similar semantic to Java.</li>
<li>Errors are now immutable.</li>
<li>Module variables are not allowed to be public: only compile-time constants
can be public.</li>
</ol>
<p>
<strong>Error handling</strong>
</p>
<ol>
<li>The <code>any</code> type no longer includes <code>error</code>.</li>
<li><code>check</code> is now an expression.</li>
<li>Exceptions have been replaced by panics
<ol>
<li>the <code>throw</code> statement has been replaced by the <code>panic</code>
statement</li>
<li>the<code> try</code> statement has been replaced by the <code>trap</code>
expression</li>
</ol>
</li>
<li>Object constructors (which could not return errors) have been replaced by
<code>__init</code> methods (which can return errors).</li>
</ol>
<p>
<strong>Concurrency</strong>
</p>
<ol>
<li>Workers in functions have been redesigned. In particular, workers now have a
return value.</li>
<li>The <code>done</code> statement has been removed.</li>
<li>The fork/join statement has been redesigned.</li>
<li>A syntactic category between expression and statement, called action, has
been added.</li>
<li>A synchronous message send action has been added.</li>
<li>A flush action has been added to flush asynchronously sent messages.</li>
<li>A wait action has been added to wait for a worker and get its return value.</li>
<li>Futures have been unified with workers. A future&lt;T> represents a value to
be returned by a named worker.</li>
<li>Error handling of message send/receive has been redesigned.</li>
</ol>
<p>
<strong>Endpoints and services</strong>
</p>
<ol>
<li>Client endpoints have been replaced by client objects, and actions on client
endpoints have been replaced by remote methods on client objects. Remote methods
are called using a remote method call action, which replaces the action
invocation statement.</li>
<li>Module endpoint declaration has been replaced by module listener
declaration, which uses the Listener built-in object type.</li>
<li>The service type has been added as a new basic type of behavioural value,
together with service constructor expressions for creating service values.</li>
<li>Module service definitions have been redesigned.</li>
</ol>
<p>
<strong>Miscellaneous changes</strong>
</p>
<ol>
<li>Public/private visibility qualifiers must be repeated on an outside method
definition.</li>
</ol>
<h3>Summary of changes from 0.970 to 0.980</h3>
<ol>
<li>The decimal type has been added.</li>
<li>There are no longer any implicit numeric conversions.</li>
<li>The type of a numeric literal can be inferred from the context.</li>
<li>The error type is now a distinct basic type.</li>
<li>The byte type has been added as a predefined subtype of int; blobs have been
replaced by arrays of bytes.</li>
<li>The syntax of string templates and xml literals has been revised and
harmonized.</li>
<li>The syntax of anonymous functions has been revised to provide two
alternative syntaxes: a full syntax similar to normal function definitions and a
more convenient arrow syntax for when the function body is an expression.</li>
<li>The cases of a match statement are required to be exhaustive.</li>
<li>The + operator is specified to do string and xml concatenation as well as
addition.</li>
<li>Bitwise operators have been added (<code>&lt;&lt;</code>, <code>>></code>,
<code>>>></code>, <code>&amp;</code>, <code>|</code>, <code>^</code>,
<code>~</code>) rather than = after the argument name.</li>
<li>In a function call or method call, named arguments have changed to use
<code>:</code></li>
<li>A statement with <code>check</code> always handles an error by returning it,
not by throwing it.</li>
<li><code>check</code> is allowed in compound assignment statements.</li>
<li>Method names are now looked up differently from field names; values of types
other than objects can now have built-in methods.</li>
<li>The <code>lengthof</code> unary expression has been removed; the length
built-in method can be used instead.</li>
<li>The semantics of &lt;T>expr have been specified.</li>
<li>The value space for tuples and arrays is now unified, in the same way as the
value space for records and maps was unified. This means that tuples are now
mutable. Array types can now have a length.</li>
<li>The <code>next</code> keyword has been changed to <code>continue</code>.</li>
<li>The syntax and semantics of destructuring is now done in a consistent way
for the but expression, the match statement, the foreach statement,
destructuring assignment statements and variable declarations.</li>
<li>The implied initial value is not used as a default initializer in variable
declarations. A local variable whose declaration omits the initializer must be
initialized by an assignment before it is used. A global variable declaration
must always have an initializer. A new expression can be used with any reference
type that has an implicit initial value.</li>
<li>Postfix increment and decrement statements have been removed.</li>
<li>The <code>...</code> and <code>..&lt;</code> operators have been added for
creating integer ranges; this replaces the foreach statement's special treatment
of integer ranges.</li>
<li>An object type can be declared to be abstract, meaning it cannot be used
with <code>new</code>.</li>
<li>By default,  a record type now allows extra fields other than those
explicitly mentioned; <code>T...</code> requires extra fields to be of type T
and <code>!...</code> disallows extra fields.</li>
<li>In a mapping constructor, an expression can be used for the field name by
enclosing the expression in square brackets (as in ECMAScript).</li>
<li>Integer arithmetic operations are specified to throw an exception on
overflow.</li>
<li>The syntax for documentation strings has changed.</li>
<li>The deprecated construct has been removed (data related to deprecation will
be provided by an annotation; documentation related to deprecation will be part
of the documentation string).</li>
<li>The order of fields, methods and constructors in object types is no longer
constrained.</li>
<li>A function or method can be defined as <code>extern</code>. The
<code>native</code> keyword has been removed.</li>
</ol>
<h2 id="contributors">C. Other contributors</h2>
<p>
The following contributed to establishing the design principles of the language:
</p>
<ul>
<li>Frank Leymann, <a href="mailto:frank.leymann@iaas.uni-stuttgart.de">frank.leymann@iaas.uni-stuttgart.de</a></li>
<li>Srinath Perera, <a href="mailto:srinath@wso2.com">srinath@wso2.com</a></li>
<li>Kasun Indrasiri, <a href="mailto:kasun@wso2.com">kasun@wso2.com</a></li>
</ul>
<p>
The following also contributed to the language in a variety of ways (in
alphabetical order):
</p>
<ul>
<li>Shafreen Anfar, <a href="mailto:shafreen@wso2.com">shafreen@wso2.com</a></li>
<li>Afkham Azeez, <a href="mailto:azeez@wso2.com">azeez@wso2.com</a></li>
<li>Anjana Fernando, <a href="mailto:anjana@wso2.com">anjana@wso2.com</a></li>
<li>Chanaka Fernando, <a href="mailto:chanakaf@wso2.com">chanakaf@wso2.com</a></li>
<li>Joseph Fonseka, <a href="mailto:joseph@wso2.com">joseph@wso2.com</a></li>
<li>Paul Fremantle, <a href="mailto:paul@wso2.com">paul@wso2.com</a></li>
<li>Antony Hosking, <a href="mailto:antony.hosking@anu.edu.au">antony.hosking@anu.edu.au</a></li>
<li>Tyler Jewell, <a href="mailto:tylerjewell@gmail.com">tylerjewell@gmail.com</a></li>
<li>Anupama Pathirage, <a href="mailto:anupama@wso2.com">anupama@wso2.com</a></li>
<li>Manuranga Perera, <a href="mailto:manu@wso2.com">manu@wso2.com</a></li>
<li>Supun Thilina Sethunga, <a href="mailto:supuns@wso2.com">supuns@wso2.com</a></li>
<li>Sriskandarajah Suhothayan, <a href="mailto:suho@wso2.com">suho@wso2.com</a></li>
<li>Isuru Udana, <a href="mailto:isuruu@wso2.com">isuruu@wso2.com</a></li>
<li>Rajith Lanka Vitharana, <a href="mailto:rajithv@wso2.com">rajithv@wso2.com</a></li>
<li>Mohanadarshan Vivekanandalingam, <a href="mailto:mohan@wso2.com">mohan@wso2.com</a></li>
<li>Lakmal Warusawithana, <a href="mailto:lakmal@wso2.com">lakmal@wso2.com</a></li>
<li>Ayoma Wijethunga, <a href="mailto:ayoma@wso2.com">ayoma@wso2.com</a></li>
</ul>
</body>
</html>
</div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"permalink":"/spec/lang/2019R1/","redirect_from":["/spec/lang/v2019R1/"]},"content":"\u003c!DOCTYPE html\u003e\n\u003chtml xmlns=\"http://www.w3.org/1999/xhtml\"\u003e\n\u003chead\u003e\n  \u003ctitle\u003eBallerina Language Specification, 2019R1\u003c/title\u003e\n  \u003cmeta charset=\"utf-8\" /\u003e\n  \u003clink rel=\"shortcut icon\" href=\"/img/favicon.ico\"\u003e\n  \u003cstyle type=\"text/css\"\u003e\n    body { font-family: sans-serif; line-height: 1.38;  }\n    pre.grammar code, code.grammar { background-color: #00FFFF; }\n    pre, code { font-family: Consolas, monospace; }\n    table { border: solid thin; border-collapse: collapse; }\n    td, th { border: solid thin; padding: 0.5em; }\n    p.status { font-size: large; font-weight: bold; }\n  \u003c/style\u003e\n\u003clink rel=\"stylesheet\" href=\"https://fonts.googleapis.com/css?family=Roboto:100,100i,300,300i,400,400i,500,500i,700,700i,900,900i\u0026amp;display=swap\"\u003e\n\u003clink rel=\"stylesheet\" href=\"style/ballerina-language-specification.css\"\u003e\n\u003cscript src=\"https://code.jquery.com/jquery-2.2.4.min.js\"\u003e\u003c/script\u003e\u003cscript src=\"style/ballerina-language-specification.js\"\u003e\u003c/script\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003eBallerina Language Specification, 2019R1\u003c/h1\u003e\n\u003cp\u003e\nPrimary contributors:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eJames Clark, \u003ca href=\"mailto:jjc@jclark.com\"\u003ejjc@jclark.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eSanjiva Weerawarana, \u003ca href=\"mailto:sanjiva@weerawarana.org\"\u003esanjiva@weerawarana.org\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eSameera Jayasoma, \u003ca href=\"mailto:sameera@wso2.com\"\u003esameera@wso2.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eHasitha Aravinda, \u003ca href=\"mailto:hasitha@wso2.com\"\u003ehasitha@wso2.com\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\n(Other contributors are listed in \u003ca href=\"#contributors\"\u003eAppendix C\u003c/a\u003e.)\n\u003c/p\u003e\n\u003cp\u003e\nCopyright © 2018, 2019 \u003ca href=\"https://wso2.com/\"\u003eWSO2\u003c/a\u003e\n\u003c/p\u003e\n\u003cp\u003e\nLicensed under the \u003ca\nhref=\"https://creativecommons.org/licenses/by-nd/4.0/\"\u003eCreative Commons\nAttribution-NoDerivatives 4.0 International\u003c/a\u003e license\n\u003c/p\u003e\n\u003cp class=\"status\"\u003e\nLanguage and document status\n\u003c/p\u003e\n\u003cp\u003e\nThe design of the Ballerina language is approaching stability.\n\u003c/p\u003e\n\u003cp\u003e\nSome language features described by this specification are less stable than the\nrest of the language. These are marked with either as having either \"preview\" or\n\"experimental\" status. Preview status means that we expect the final design to\nbe close enough to the current design that it will be straightforward to update\ncode that makes uses the current design to the final design. Experimental status\nmeans that we believe that we want to have similar functionality, but we are not\nyet confident about how close the final design will be to the feature as\ncurrently described.\n\u003c/p\u003e\n\u003cp\u003e\nIn addition, we know there are some areas where the specification needs to\nprovide more details about the semantics of the language.\n\u003c/p\u003e\n\u003cp\u003e\nComments on this document are welcome and should be made by creating an issue in\n\u003ccode\u003e\u003ca href=\"https://github.com/ballerina-platform/ballerina-spec\"\n\u003ehttps://github.com/ballerina-platform/ballerina-spec\u003c/a\u003e\u003c/code\u003e, which is the\nGitHub repository where this specification is maintained. The design of the\nlanguage may also be discussed in the \u003ca\nhref=\"mailto:ballerina-dev@googlegroups.com\"\u003eballerina-dev@googlegroups.com\u003c/a\u003e\nmailing list.\n\u003c/p\u003e\n\u003ch2 class=\"toc\"\u003eTable of Contents\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"#introduction\"\u003e1. Introduction\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"#notation\"\u003e2. Notation\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"#program_structure\"\u003e3. Program structure\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"#lexical_structure\"\u003e4. Lexical structure\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"#values_types\"\u003e5. Values, types and variables\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"#expressions\"\u003e6. Expressions\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"#actions_statements\"\u003e7. Actions and statements\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"#built-in_methods\"\u003e8. Built-in methods\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"#module_level\"\u003e9. Module-level declarations\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"#querying\"\u003e10. [Experimental] Querying\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"#transactions\"\u003e11. [Experimental] Transactions\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"#metadata\"\u003e12. Metadata\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"#references\"\u003eA. References\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"#changes\"\u003eB. Changes since previous versions\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"#contributors\"\u003eC. Other contributors\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003e1. Introduction\u003c/h2\u003e\n\u003cp\u003e\nBallerina is a programming language intended for network distributed\napplications. It is a statically typed, concurrent programming language with all\nfunctionality expected of a modern, general purpose programming language. But it\nalso has several unusual aspects that make it particularly suitable for its\nintended purpose.\n\u003c/p\u003e\n\u003cp\u003e\nFirst, it provides language constructs specifically for consuming and providing\nnetwork services. Future versions of Ballerina will add language constructs for\nother functionality often needed by network distributed applications such as\nsecurity, stream processing, distributed transactions and reliable messaging.\n\u003c/p\u003e\n\u003cp\u003e\nSecond, it is designed to take advantage of sequence diagrams as a way of\ndescribing the interactions within network distributed applications. There is a\nclose correspondence between the function-level concurrency-related syntax and\nsequence diagrams; this syntax is in effect a syntax for writing sequence\ndiagrams. This makes it possible to provide an editable graphical representation\nof a function as a sequence diagram.\n\u003c/p\u003e\n\u003cp\u003e\nThird, it has a type system that is more flexible and allows for looser coupling\nthat traditional statically typed languages. The type system is structural:\ninstead of requiring the program to explicitly say which types are compatible\nwith each other, compatibility of types and values is determined automatically\nbased on their structure; this is particularly useful when combining data from\nmultiple, independently-designed systems. In addition, the type system provides\nunion types and open records. This flexibility allows the type system to be used\nas a schema for the data that is exchanged in distributed applications.\nBallerina's data types are designed to work particularly well with JSON; any\nJSON value has a direct, natural representation as a Ballerina value. Ballerina\nalso provides support for XML and relational data.\n\u003c/p\u003e\n\u003cp\u003e\nBallerina is not a research language. It is intended to be a pragmatic language\nsuitable for mass-market commercial adoption. It tries to feel familiar to\nprogrammers who are used to popular, modern C-family languages, notably Java,\nC#, JavaScript. It also borrows ideas from many other existing programming\nlanguages including TypeScript, Go, Rust, D, Kotlin, TypeScript, Swift, Python\nand Perl.\n\u003c/p\u003e\n\u003cp\u003e\nBallerina is designed for modern development practices with a module based\ndevelopment model with namespace management via module repositories, including a\nglobally shared central repository. Module version management, dependency\nmanagement, testing, documentation, building and sharing are part of the\nlanguage platform design architecture and not left for later add-on tools.\n\u003c/p\u003e\n\u003cp\u003e\nBallerina is a \"batteries included\" language: it comes with a standard library,\nwhich includes not only the usual low-level, general-purpose functionality, but\nalso support for a wide variety of network protocols, interface standards, data\nformats and authentication/authorization standards, which make writing secure,\nresilient distributed applications significantly easier than with other\nlanguages. The standard library is not specified in this document.\n\u003c/p\u003e\n\u003ch2 id=\"notation\"\u003e2. Notation\u003c/h2\u003e\n\u003cp\u003e\nProductions are written in the form:\n\u003c/p\u003e\n\n\u003cpre\u003esymbol := rhs\n\u003c/pre\u003e\n\u003cp\u003e\nwhere symbol is the name of a nonterminal, and \u003ccode\u003erhs\u003c/code\u003e is as follows:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e0xX\u003c/code\u003e means the single character whose Unicode code point is\ndenoted by the hexadecimal numeral X\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e^x\u003c/code\u003e means any single Unicode code point that does not match x\nand is not a disallowed character;\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ex..y\u003c/code\u003e means any single Unicode character whose code point is\ngreater than or equal to that of x and less than or equal to that of y\u003c/li\u003e\n\u003cli\u003e\u003ccode class=\"grammar\"\u003estr\u003c/code\u003e means the characters \u003ccode\u003estr\u003c/code\u003e literally\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esymbol \u003c/code\u003emeans a reference to production for the nonterminal\n\u003ccode\u003esymbol\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ex|y\u003c/code\u003e means x or y\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ex\u0026amp;y\u003c/code\u003e means x and y interleaved in any order\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e[x]\u003c/code\u003e means zero or one times\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ex?\u003c/code\u003e means x zero or one times\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ex*\u003c/code\u003e means x zero or more times\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ex+\u003c/code\u003e means x one or more times\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e(x)\u003c/code\u003e means x (grouping)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nThe rhs of a symbol that starts with a lower-case letter implicitly allows white\nspace and comments, as defined by the production \u003ccode\u003eTokenWhiteSpace\u003c/code\u003e,\nbetween the terminals and nonterminals that it references.\n\u003c/p\u003e\n\u003ch2 id=\"program_structure\"\u003e3. Program structure\u003c/h2\u003e\n\u003cp\u003e\nA Ballerina program is divided into modules. A module has a source form and a\nbinary form. The module is the unit of compilation; a Ballerina compiler\ntranslates the source form of a module into its binary form. A module may\nreference other modules. When a compiler translates a source module into a\nbinary module, it needs access only to the binary form of other modules\nreferenced from the source module.\n\u003c/p\u003e\n\u003cp\u003e\nA binary module can only be referenced if it is placed in a module store. There\nare two kinds of module store: a repository and a project. A module stored in a\nrepository can be referenced from any other module. A module stored in a project\ncan only be referenced from other modules stored in the same project.\n\u003c/p\u003e\n\u003cp\u003e\nA repository organizes binary modules into a 3-level hierarchy:\n\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eorganization;\u003c/li\u003e\n\u003cli\u003emodule name;\u003c/li\u003e\n\u003cli\u003eversion.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\nOrganizations are identified by Unicode strings, and are unique within a\nrepository. A module name is a Unicode string and is unique within a repository\norganization. A particular module name can have one or more versions each\nassociated with a separate binary module. Versions are semantic, as described in\nthe SemVer specification.\n\u003c/p\u003e\n\u003cp\u003e\nA project stores modules using a simpler single level hierarchy, in which the\nmodule is associated directly with the module name.\n\u003c/p\u003e\n\u003cp\u003e\nA binary module is a sequence of octets. Its format is specified in the\nBallerina Platform Specification.\n\u003c/p\u003e\n\u003cp\u003e\nAn abstract source module consists of:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ean ordered collection of one or more source parts; each source part is a\nsequence of octets that is the UTF-8 encoding of part of the source code for the\nmodule\u003c/li\u003e\n\u003cli\u003emetadata containing the following\n\u003cul\u003e\n\u003cli\u003ealways required: module name\u003c/li\u003e\n\u003cli\u003erequired only if the source module is to be compiled into a binary module\nstored in a repository:\n\u003cul\u003e\n\u003cli\u003eorganization name\u003c/li\u003e\n\u003cli\u003eversion\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nAn abstract source module can be stored in a variety of concrete forms. For\nexample, the Ballerina Platform Specification describes a method for storing an\nabstract source module in a filesystem, where the source parts are files with a\n\u003ccode\u003e.bal \u003c/code\u003eextension stored in a directory, the module name comes from\nthe name of that directory, and the version and organization name comes from a\nconfiguration file \u003ccode\u003eBallerina.toml\u003c/code\u003e in that directory.\n\u003c/p\u003e\n\u003ch2 id=\"lexical_structure\"\u003e4. Lexical structure\u003c/h2\u003e\n\u003cp\u003e\nThe grammar in this document specifies how a sequence of Unicode code points is\ninterpreted as part of the source of a Ballerina module. A Ballerina module part\nis a sequence of octets (8-bit bytes); this sequence of octets is interpreted as\nthe UTF-8 encoding of a sequence of code points and must comply with the\nrequirements of RFC 3629.\n\u003c/p\u003e\n\u003cp\u003e\nAfter the sequence of octets is decoded from UTF-8, the following two\ntransformations must be performed before it is parsed using the grammar in this\ndocument:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eif the sequence starts with a byte order mark (code point 0xFEFF), it must\nbe removed\u003c/li\u003e\n\u003cli\u003enewlines are normalized as follows:\n\u003cul\u003e\n\u003cli\u003ethe two character sequence 0xD 0xA is replaced by 0xA\u003c/li\u003e\n\u003cli\u003ea single 0xD character that is not followed by 0xD is replaced by 0xA\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nThe sequence of code points must not contain any of the following disallowed\ncode points:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003esurrogates (0xD800 to 0xDFFF)\u003c/li\u003e\n\u003cli\u003enon-characters (the 66 code points that Unicode designates as\nnon-characters)\u003c/li\u003e\n\u003cli\u003eC0 control characters (0x0 to 0x1F and 0x1F) other than whitespace (0x9,\n0xA, 0xC, 0xD)\u003c/li\u003e\n\u003cli\u003eC1 control characters (0x80 to 0x9F)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nNote that the grammar notation ^X does not allow the above disallowed code\npoints.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eidentifier := UndelimitedIdentifier | DelimitedIdentifier\nUndelimitedIdentifier :=\n   IdentifierInitialChar IdentifierFollowingChar*\nDelimitedIdentifier := \u003ccode\u003e^\"\u003c/code\u003e StringChar+ \u003ccode\u003e\"\u003c/code\u003e\nIdentifierInitialChar := \u003ccode\u003eA\u003c/code\u003e .. \u003ccode\u003eZ\u003c/code\u003e | \u003ccode\u003ea\u003c/code\u003e .. \u003ccode\u003ez\u003c/code\u003e | \u003ccode\u003e_\u003c/code\u003e | UnicodeIdentifierChar\nIdentifierFollowingChar := IdentifierInitialChar | Digit\nUnicodeIdentifierChar := ^ ( AsciiChar | UnicodeNonIdentifierChar )\nAsciiChar := 0x0 .. 0x7F\nUnicodeNonIdentifierChar :=\n   UnicodePrivateUseChar\n   | UnicodePatternWhiteSpaceChar\n   | UnicodePatternSyntaxChar\nUnicodePrivateUseChar :=\n   0xE000 .. 0xF8FF\n   | 0xF0000 .. 0xFFFFD\n   | 0x100000 .. 0x10FFFD\nUnicodePatternWhiteSpaceChar := 0x200E | 0x200F | 0x2028 | 0x2029\nUnicodePatternSyntaxChar :=\n   character with Unicode property Pattern_Syntax=True\nDigit := \u003ccode\u003e0\u003c/code\u003e .. \u003ccode\u003e9\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nNote that the set of characters allowed in identifiers follows the requirements\nof Unicode TR31 for immutable identifiers; the set of characters is immutable in\nthe sense that it does not change between Unicode versions.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eTokenWhiteSpace := (Comment | WhiteSpaceChar)*\nComment := \u003ccode\u003e//\u003c/code\u003e AnyCharButNewline*\nAnyCharButNewline := ^ 0xA\nWhiteSpaceChar := 0x9 | 0xA | 0xD | 0x20\n\u003c/pre\u003e\n\u003cp\u003e\n\u003ccode\u003eTokenWhiteSpace\u003c/code\u003e is implicitly allowed on the right hand side of\nproductions for non-terminals whose names start with a lower-case letter.\n\u003c/p\u003e\n\u003ch2 id=\"values_types\"\u003e5. Values, types and variables\u003c/h2\u003e\n\u003cp\u003e\nBallerina programs operate on a rich universe of values. This universe of values\nis partitioned into a number of \u003cem\u003ebasic types\u003c/em\u003e; every value belongs to\nexactly one basic type.\n\u003c/p\u003e\n\u003cp\u003e\nValues are of three kinds, each corresponding to a kind of basic type:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003esimple values, like booleans and floating point numbers, which are not\nconstructed from other values;\u003c/li\u003e\n\u003cli\u003estructured values, like mappings and lists, which create structures from\nother values;\u003c/li\u003e\n\u003cli\u003ebehavioral values, like functions, which allow parts of Ballerina programs\nto be handled in a uniform way with other values\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nValues can be stored in variables or as members of structures. A simple value is\nstored directly in the variable or structure. However, for other types of value,\nwhat is stored in the variable or member is a reference to the value; the value\nitself has its own separate storage. Non-simple types (i.e. structured types and\nbehavioral types) are thus collectively called reference types. A reference\nvalue has an identity determined by its storage location. References make it\npossible for distinct members of a structure to refer to values that are\nidentical, in the sense that they are stored in the same location. Thus values\nin Ballerina represent not just trees but graphs.\n\u003c/p\u003e\n\u003cp\u003e\nSimple values are inherently immutable because they have no identity distinct\nfrom their value. All basic types of structural values, with the exception of\nthe XML, are mutable, meaning the value referred to by a particular reference\ncan be changed. Whether a behavioural value is mutable depends on its basic\ntype: some of the behavioural basic types allow mutation, and some do not.\nMutation cannot change the basic type of a value. Mutation makes it possible for\nthe graphs of references between values to have cycles.\n\u003c/p\u003e\n\u003cp\u003e\nBallerina programs use types to categorize values both at compile-time and\nruntime. Types deal with an abstraction of values, which does not consider\nstorage location or mutability. This abstraction is called a \u003cem\u003eshape\u003c/em\u003e. A\ntype denotes a set of shapes. Subtyping in Ballerina is \u003cem\u003esemantic\u003c/em\u003e: a\ntype S is a subtype of type T if the set of shapes denoted by S is a subset of\nthe set of shapes denoted by T. Every value has a corresponding shape. A shape\nis specific to a basic type: if two values have different basic types, then they\nhave different shapes. Since shapes do not deal with storage location, they have\nno concept of identity; shapes therefore represent trees rather graphs. For\nsimple values, there is no difference between a shape and a value, except for\none case: positive and negative zero of a floating point basic type are distinct\nvalues but have the same shape. There are two important relations between a\nvalue and a type:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ea value \u003cem\u003elooks like\u003c/em\u003e a type at a particular point in the execution of\na program if its shape at that point is a member of the type;\u003c/li\u003e\n\u003cli\u003ea value \u003cem\u003ebelongs to\u003c/em\u003e a type if it looks like the type, and it will\nnecessarily continue to look like the type no matter how the value is mutated.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nFor an immutable value, looking like a type and belonging to a type are the same\nthing.\n\u003c/p\u003e\n\u003cp\u003e\nWhen a Ballerina program declares a variable to have a compile-time type, this\nmeans that the Ballerina compiler together with the runtime system will ensure\nthat the variable will only ever contain a value that belongs to the type.\nBallerina also provides mechanisms that take a value that looks like a type and\nuse it to create a value that belongs to a type.\n\u003c/p\u003e\n\u003cp\u003e\nBallerina provides a rich variety of type descriptors, which programs use to\ndescribe types. For example, there is a type descriptor for each simple basic\ntype; there is a type descriptor that describes as type as a union of two types;\nthere is a type descriptor that uses a single value to describe a type that\ncontains a single shape. This means that values can look like and belong to\narbitrarily many types, even though they look like or belong to exactly one\n\u003cem\u003ebasic\u003c/em\u003e type.\n\u003c/p\u003e\n\u003cp\u003e\nIn addition to describing a type, a type descriptor may also include information\nused to construct a value of the type, as well as metadata. Whereas the type\ndescribed by a type descriptor is known at compile time, this additional\ninformation may need to be resolved at runtime. The typedesc basic type\nrepresents a type descriptor that has been resolved.\n\u003c/p\u003e\n\u003cp\u003e\nMost basic types of structured values (along with one basic type of simple\nvalue) are iterable, meaning that a value of the type can be accessed as a\nsequence of simpler values.\n\u003c/p\u003e\n\u003cp\u003e\nThe following table summarizes the type descriptors provided by Ballerina.\nExperimental features are not included.\n\u003c/p\u003e\n\u003ctable\u003e\n  \u003ctr\u003e\n   \u003ctd\u003e\u003cstrong\u003eKind\u003c/strong\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003cstrong\u003eName\u003c/strong\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003cstrong\u003eSet of values denoted by type descriptor\u003c/strong\u003e\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd rowspan=\"6\" \u003ebasic, simple\u003c/td\u003e\n   \u003ctd\u003enil\u003c/td\u003e\n   \u003ctd\u003e()\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003eboolean\u003c/td\u003e\n   \u003ctd\u003etrue, false\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003eint\u003c/td\u003e\n   \u003ctd\u003e64-bit signed integers\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003efloat\u003c/td\u003e\n   \u003ctd\u003e64-bit IEEE 754-2008 binary floating point numbers\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003edecimal\u003c/td\u003e\n   \u003ctd\u003e128-bit IEEE 754-2008 decimal floating point numbers\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003estring\u003c/td\u003e\n   \u003ctd\u003esequences of Unicode code points\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd rowspan=\"7\" \u003ebasic, structured\u003c/td\u003e\n   \u003ctd\u003earray\u003c/td\u003e\n   \u003ctd\u003ean ordered list of values, optionally with a specific length, where a\nsingle type is specified for all members of the list,\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003etuple\u003c/td\u003e\n   \u003ctd\u003ean ordered list of values, where a type is specified separately for each\nmember of the list\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003emap\u003c/td\u003e\n   \u003ctd\u003ea mapping from keys, which are strings, to values; specifies mappings in\nterms of a single type to which all keys are mapped\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003erecord\u003c/td\u003e\n   \u003ctd\u003ea mapping from keys, which are strings, to values; specifies maps in\nterms of names of fields (required keys) and value for each field\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003etable\u003c/td\u003e\n   \u003ctd\u003e\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003eXML\u003c/td\u003e\n   \u003ctd\u003ea sequence of zero or more characters, XML elements, processing\ninstructions or comments\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003eerror\u003c/td\u003e\n   \u003ctd\u003ean indication that there has been an error, with a string identifying the\nreason for the error, and a mapping giving additional details about the error\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd rowspan=\"5\" \u003ebasic, behavioral\u003c/td\u003e\n   \u003ctd\u003efunction\u003c/td\u003e\n   \u003ctd\u003ea function with 0 or more specified parameter types and a single return\ntype\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003efuture\u003c/td\u003e\n   \u003ctd\u003e\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003eobject\u003c/td\u003e\n   \u003ctd\u003e\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003eservice\u003c/td\u003e\n   \u003ctd\u003e\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003etypedesc\u003c/td\u003e\n   \u003ctd\u003ea type descriptor\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd rowspan=\"7\" \u003eother\u003c/td\u003e\n   \u003ctd\u003esingleton\u003c/td\u003e\n   \u003ctd\u003ea single value described by a literal\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003eunion\u003c/td\u003e\n   \u003ctd\u003ethe union of the component types\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003eoptional\u003c/td\u003e\n   \u003ctd\u003ethe underlying type and ()\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003eany\u003c/td\u003e\n   \u003ctd\u003eall values\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003eanydata\u003c/td\u003e\n   \u003ctd\u003e\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003ebyte\u003c/td\u003e\n   \u003ctd\u003eint in the range 0 to 255 inclusive\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003ejson\u003c/td\u003e\n   \u003ctd\u003ethe union of (), int, float, decimal, string, and maps and arrays whose\nvalues are, recursively, json\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003ch3\u003eSimple Values\u003c/h3\u003e\n\u003cp\u003e\nA simple value belongs to exactly one of the following basic types:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003enil\u003c/li\u003e\n\u003cli\u003eboolean\u003c/li\u003e\n\u003cli\u003eint\u003c/li\u003e\n\u003cli\u003efloat\u003c/li\u003e\n\u003cli\u003edecimal\u003c/li\u003e\n\u003cli\u003estring\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nThe type descriptor for each simple basic type contains all the values of the\nbasic type.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003esimple-type-descriptor :=\n   nil-type-descriptor\n   | boolean-type-descriptor\n   | int-type-descriptor\n   | floating-point-type-descriptor\n   | string-type-descriptor\n\u003c/pre\u003e\n\u003ch4\u003eNil\u003c/h4\u003e\n\n\u003cpre\nclass=\"grammar\"\u003enil-type-descriptor :=  \u003ccode\u003e(\u003c/code\u003e \u003ccode\u003e)\u003c/code\u003e\nnil-literal :=  \u003ccode\u003e(\u003c/code\u003e \u003ccode\u003e)\u003c/code\u003e | \u003ccode\u003enull\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nThe nil type contains a single value, called nil, which is used to represent the\nabsence of any other value. The nil value is written \u003ccode\u003e()\u003c/code\u003e. The nil\nvalue can also be written \u003ccode\u003enull\u003c/code\u003e, for compatibility with JSON; the\nuse of null should be restricted to JSON-related contexts.\n\u003c/p\u003e\n\u003cp\u003e\nThe nil type is special, in that it is the only basic type that consists of a\nsingle value. The type descriptor for the nil type is not written using a\nkeyword, but is instead written \u003ccode\u003e() \u003c/code\u003elike the value.\n\u003c/p\u003e\n\u003ch4\u003eBoolean\u003c/h4\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eboolean-type-descriptor := \u003ccode\u003eboolean\u003c/code\u003e\nboolean-literal := \u003ccode\u003etrue\u003c/code\u003e | \u003ccode\u003efalse\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nThe boolean type consists of the values true and false.\n\u003c/p\u003e\n\u003ch4\u003eInt\u003c/h4\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eint-type-descriptor := \u003ccode\u003eint\u003c/code\u003e\nint-literal := DecimalNumber | HexIntLiteral\nDecimalNumber := \u003ccode\u003e0\u003c/code\u003e | NonZeroDigit Digit*\nHexIntLiteral := HexIndicator HexNumber\nHexNumber := HexDigit+\nHexIndicator := \u003ccode\u003e0x\u003c/code\u003e | \u003ccode\u003e0X\u003c/code\u003e\nHexDigit := Digit | \u003ccode\u003ea\u003c/code\u003e .. \u003ccode\u003ef\u003c/code\u003e | \u003ccode\u003eA\u003c/code\u003e .. \u003ccode\u003eF\u003c/code\u003e\nDigit := \u003ccode\u003e0\u003c/code\u003e .. \u003ccode\u003e9\u003c/code\u003e\nNonZeroDigit := \u003ccode\u003e1\u003c/code\u003e .. \u003ccode\u003e9\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nThe int type consists of integers between -9,223,372,036,854,775,808 and\n9,223,372,036,854,775,807 (i.e. signed integers than can fit into 64 bits using\na two's complement representation)\n\u003c/p\u003e\n\u003ch4\u003eFloating point types\u003c/h4\u003e\n\n\u003cpre\nclass=\"grammar\"\u003efloating-point-type-descriptor := \u003ccode\u003efloat\u003c/code\u003e | \u003ccode\u003edecimal\u003c/code\u003e\nfloating-point-literal :=\n   DecimalFloatingPointNumber | HexFloatingPointLiteral\nDecimalFloatingPointNumber :=\n   DecimalNumber Exponent [FloatingPointTypeSuffix]\n   | DottedDecimalNumber [Exponent] [FloatingPointTypeSuffix]\n   | DecimalNumber FloatingPointTypeSuffix\nDottedDecimalNumber :=\n   DecimalNumber \u003ccode\u003e.\u003c/code\u003e Digit*\n   | \u003ccode\u003e.\u003c/code\u003e Digit+\nExponent := ExponentIndicator [Sign] Digit+\nExponentIndicator := \u003ccode\u003ee\u003c/code\u003e | \u003ccode\u003eE\u003c/code\u003e\nHexFloatingPointLiteral := HexIndicator HexFloatingPointNumber\nHexFloatingPointNumber :=\n   HexNumber HexExponent\n   | DottedHexNumber [HexExponent]\nDottedHexNumber :=\n   HexDigit+ \u003ccode\u003e.\u003c/code\u003e HexDigit*\n   | \u003ccode\u003e.\u003c/code\u003e HexDigit+\nHexExponent := HexExponentIndicator [Sign] Digit+\nHexExponentIndicator := \u003ccode\u003ep\u003c/code\u003e | \u003ccode\u003eP\u003c/code\u003e\nSign := \u003ccode\u003e+\u003c/code\u003e | \u003ccode\u003e-\u003c/code\u003e\nFloatingPointTypeSuffix := DecimalTypeSuffix | FloatTypeSuffix\nDecimalTypeSuffix := \u003ccode\u003ed\u003c/code\u003e | \u003ccode\u003eD\u003c/code\u003e\nFloatTypeSuffix :=  \u003ccode\u003ef\u003c/code\u003e | \u003ccode\u003eF\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nThere are two basic types for floating point numbers:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ethe float type corresponds to IEEE 754-2008 64-bit binary (radix 2) floating\npoint numbers\u003c/li\u003e\n\u003cli\u003ethe decimal type corresponds to IEEE 754-2008 128-bit decimal (radix 10)\nfloating point numbers\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nThe multiple bit patterns that IEEE 754 treats as NaN are considered to be the\nsame value in Ballerina. Positive and negative zero of a floating point basic\ntype are distinct values, following IEEE 754, but are defined to have the same\nshape, so that they will usually be treated as being equal.\n\u003c/p\u003e\n\u003cp\u003e\nIEEE-defined operations on floating point values must be performed using a\nrounding-direction attribute of roundTiesToEven (which is the default IEEE\nrounding direction, sometimes called \u003cem\u003eround to nearest\u003c/em\u003e). All floating\npoint values, including the intermediate results of expressions, must use the\nvalue space defined for the float and decimal type; implementations must not use\nextended precision for intermediate results. This ensures that all\nimplementations will produce identical results. (This is the same as what is\nrequired by strictfp in Java.)\n\u003c/p\u003e\n\u003ch4\u003eStrings\u003c/h4\u003e\n\n\u003cpre\nclass=\"grammar\"\u003estring-type-descriptor := \u003ccode\u003estring\u003c/code\u003e\nstring-literal := DoubleQuotedStringLiteral\nDoubleQuotedStringLiteral := \u003ccode\u003e\"\u003c/code\u003e (StringChar | StringEscape)* \u003ccode\u003e\"\u003c/code\u003e\nStringChar := ^ ( 0xA | 0xD | \u003ccode\u003e\\\u003c/code\u003e | \u003ccode\u003e\"\u003c/code\u003e )\nStringEscape := StringSingleEscape | StringNumericEscape\nStringSingleEscape := \u003ccode\u003e\\t\u003c/code\u003e | \u003ccode\u003e\\n\u003c/code\u003e | \u003ccode\u003e\\r\u003c/code\u003e | \u003ccode\u003e\\\\\u003c/code\u003e | \u003ccode\u003e\\\"\u003c/code\u003e\nStringNumericEscape := \u003ccode\u003e\\u[\u003c/code\u003e CodePoint \u003ccode\u003e]\u003c/code\u003e\nCodePoint := HexDigit+\n\u003c/pre\u003e\n\u003cp\u003e\nA string is an immutable sequences of zero or more Unicode code points. Any code\npoint in the Unicode range of 0x0 to 0x10FFFF inclusive is allowed other than\nsurrogates (0xD800 to 0xDFFF inclusive).\n\u003c/p\u003e\n\u003cp\u003e\nIn a \u003ccode\u003eStringNumericEscape\u003c/code\u003e, \u003ccode\u003eCodePoint\u003c/code\u003e must valid Unicode\ncode point; more precisely, it must  be a hexadecimal numeral denoting an\ninteger \u003cem\u003en\u003c/em\u003e where 0 \u0026lt;= \u003cem\u003en\u003c/em\u003e \u0026lt; 0xD800 or 0xDFFF \u0026lt; n \u0026lt;=\n0x10FFFF.\n\u003c/p\u003e\n\u003cp\u003e\nA string is iterable as a sequence of its single code point substrings. String\nis the only simple type that is iterable.\n\u003c/p\u003e\n\u003ch3\u003eStructured values\u003c/h3\u003e\n\u003cp\u003e\nThere are five basic types of structured value. First, there are three container\nbasic types: list, mapping and table. Second, there is the xml basic type and\nthe error basic type, which are both special in different ways.\n\u003c/p\u003e\n\u003cp\u003e\nValues of the container basic types are containers for other values, which are\ncalled their members.  Containers are mutable: the members contained in a\nparticular container can be changed. However, a container value can also be\nfrozen at runtime or compile time, which prevents any change to its members. A\nfrozen container value can refer only to immutable values: either other frozen\nvalues or values of basic types that are always immutable. Once frozen, a\ncontainer value remains frozen. Values of basic type xml can also be frozen as\ndescribed below.\n\u003c/p\u003e\n\u003cp\u003e\nThe shape of the members of a container value contribute to the shape of the\ncontainer. Mutating a member of a container can thus cause the shape of the\ncontainer to change.\n\u003c/p\u003e\n\u003cp\u003e\nA type descriptor for a container basic type describe the shape of the container\nin terms of the shapes of its members.  A container has an inherent type, which\nis a type descriptor which is part of the container's runtime value. At runtime,\nthe container prevents any mutation that might lead to the container having a\nshape that is not a member of its inherent type. Thus a container value belongs\nto a type if and only if that type is its inherent type or a subset of its\ninherent type.\n\u003c/p\u003e\n\u003cp\u003e\nA frozen container value belongs to a type if and only if the type contains the\nshape of the value. In other words, freezing a container narrows its inherent\ntype to a type that consists of just its current shape.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003estructured-type-descriptor :=\n   list-type-descriptor\n   | mapping-type-descriptor\n   | table-type-descriptor\n   | xml-type-descriptor\n   | error-type-descriptor\n\u003c/pre\u003e\n\u003cp\u003e\nThe following table summarizes the type descriptors for structured types.\n\u003c/p\u003e\n\u003ctable\u003e\n  \u003ctr\u003e\n   \u003ctd\u003e\u003c/td\u003e\n   \u003ctd\u003eInteger index\u003c/td\u003e\n   \u003ctd\u003eString key\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003eBasic type\u003c/td\u003e\n   \u003ctd\u003elist\u003c/td\u003e\n   \u003ctd\u003emapping\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003eType descriptor with uniform member type\u003c/td\u003e\n   \u003ctd\u003earray\u003c/td\u003e\n   \u003ctd\u003emap\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003eType descriptor with separate member types\u003c/td\u003e\n   \u003ctd\u003etuple\u003c/td\u003e\n   \u003ctd\u003erecord\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003cp\u003e\nA value is defined to be \u003cem\u003epure\u003c/em\u003e if it either\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eis a simple value, or\u003c/li\u003e\n\u003cli\u003eis a structured value, all of whose members are also pure values.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nA shape is pure if it is the shape of a pure value. A type is pure if it\ncontains only pure shapes.\n\u003c/p\u003e\n\u003ch4\u003eLists\u003c/h4\u003e\n\u003cp\u003e\nA list value is a container that keeps its members in an ordered list. The\nnumber of members of the list is called the \u003cem\u003elength \u003c/em\u003eof the list. A\nmember of a list can be referenced by an integer index representing its position\nin the list. For a list of length \u003cem\u003en\u003c/em\u003e, the indices of the members of the\nlist, from first to last, are 0,1,...,\u003cem\u003en\u003c/em\u003e - 1. The shape of a list value\nis an ordered list of the shapes of its members.\n\u003c/p\u003e\n\u003cp\u003e\nA list is iterable as a sequence of its members.\n\u003c/p\u003e\n\u003cp\u003e\nThe type of list values can be described by two kinds of type descriptors.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003elist-type-descriptor :=\n   array-type-descriptor | tuple-type-descriptor\n\u003c/pre\u003e\n\u003cp\u003e\nThe inherent type of a list value must be a \u003ccode\u003elist-type-descriptor\u003c/code\u003e.\nThe inherent type of a list value determines a type T\u003csub\u003e\u003cem\u003ei\u003c/em\u003e\u003c/sub\u003e for a\nmember with index \u003cem\u003ei\u003c/em\u003e. The runtime system will enforce a constraint that\na value written to index \u003cem\u003ei\u003c/em\u003e will belong to type T\u003csub\u003e\u003cem\u003ei\u003c/em\u003e\u003c/sub\u003e.\nNote that the constraint is not merely that the value looks like\nT\u003csub\u003e\u003cem\u003ei\u003c/em\u003e\u003c/sub\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nBoth kinds of type descriptor are covariant in the types of their members.\n\u003c/p\u003e\n\u003ch5\u003eArray types\u003c/h5\u003e\n\u003cp\u003e\nAn array type-descriptor describes a type of list value by specifying the type\nthat the value for all members must belong to, and optionally, a length.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003earray-type-descriptor := member-type-descriptor \u003ccode\u003e[\u003c/code\u003e [ array-length ] \u003ccode\u003e]\u003c/code\u003e\nmember-type-descriptor := type-descriptor\narray-length :=\n   int-literal\n   | constant-reference-expr\n   | inferred-array-length\ninferred-array-length := \u003ccode\u003e*\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nA type \u003ccode\u003eT[]\u003c/code\u003e contains a list shape if all members of the list shape\nare in \u003ccode\u003eT\u003c/code\u003e. A type \u003ccode\u003eT[n]\u003c/code\u003e contains a list shape if in\naddition the length of the list shape is n.\n\u003c/p\u003e\n\u003cp\u003e\nA \u003ccode\u003econstant-reference-expr\u003c/code\u003e in an \u003ccode\u003earray-length\u003c/code\u003e must\nevaluate to a non-negative integer. An array length of \u003ccode\u003e*\u003c/code\u003e means that\nthe length of the array is to be inferred from the context; this is allowed only\nwithin a type descriptor occurring in a context that is specified to be\ninferable; its meaning is the same as if the length was specified explicitly.\n\u003c/p\u003e\n\u003cp\u003e\nNote also that \u003ccode\u003eT[n]\u003c/code\u003e is a subtype of \u003ccode\u003eT[]\u003c/code\u003e, and that if\n\u003ccode\u003eS\u003c/code\u003e is a subtype of \u003ccode\u003eT\u003c/code\u003e, then \u003ccode\u003eS[]\u003c/code\u003e is a\nsubtype of \u003ccode\u003eT[]\u003c/code\u003e; this is a consequence of the definition of\nsubtyping in terms of subset inclusion of the corresponding sets of shapes.\n\u003c/p\u003e\n\u003cp\u003e\nAn array \u003ccode\u003eT[]\u003c/code\u003e is iterable as a sequence of values of type\n\u003ccode\u003eT\u003c/code\u003e.\n\u003c/p\u003e\n\u003ch5\u003eTuple types\u003c/h5\u003e\n\u003cp\u003e\nA tuple type descriptor describes a type of list value by specifying a separate\ntype for each member of the list.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003etuple-type-descriptor :=\n   \u003ccode\u003e[\u003c/code\u003e tuple-member-type-descriptors \u003ccode\u003e]\u003c/code\u003e\ntuple-member-type-descriptors :=\n   member-type-descriptor (\u003ccode\u003e,\u003c/code\u003e member-type-descriptor)* [\u003ccode\u003e,\u003c/code\u003e tuple-rest-descriptor]\n   | [ tuple-rest-descriptor ]\ntuple-rest-descriptor := type-descriptor \u003ccode\u003e...\u003c/code\u003e\n\n\u003c/pre\u003e\n\u003cp\u003e\nA tuple type descriptor T with m member type descriptors contains a list shape L\nof length n if and only if:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003em is less than or equal to n\u003c/li\u003e\n\u003cli\u003ethe i-th member type descriptor of T contains the i-th member of L for each\ni from 1 to m;\u003c/li\u003e\n\u003cli\u003eif n is greater than m, then T has a tuple-rest-descriptor\nR\u003ccode\u003e...\u003c/code\u003e, and R contains the j-th member of L for each j from m + 1 to\nn.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nNote that a tuple type where all the \u003ccode\u003emember-type-descriptor\u003c/code\u003es are\nthe same and there is no tuple-rest-descriptor is equivalent to an\narray-type-descriptor with a length.\n\u003c/p\u003e\n\u003ch4\u003eMappings\u003c/h4\u003e\n\u003cp\u003e\nA mapping value is a container where each member has a key, which is a string,\nthat uniquely identifies within the mapping. We use the term \u003cem\u003efield\u003c/em\u003e to\nmean the member together its key; the name of the field is the key, and the\nvalue of the field is that value of the member; no two fields in a mapping value\ncan have the same name.\n\u003c/p\u003e\n\u003cp\u003e\nThe shape of a mapping value is an unordered collection of field shapes one for\neach field. The field shape for a field f has a name, which is the same as the\nname of f, and a shape, which is the shape of the value of f.\n\u003c/p\u003e\n\u003cp\u003e\nA mapping is iterable as sequence of fields, where each field is represented by\na 2-tuple \u003ccode\u003e(\u003cem\u003es\u003c/em\u003e, \u003cem\u003eval\u003c/em\u003e)\u003c/code\u003e where \u003ccode\u003e\u003cem\u003es\n\u003c/em\u003e\u003c/code\u003eis a string for the name of a field, and \u003ccode\u003e\u003cem\u003eval\u003c/em\u003e\u003c/code\u003e\nis the value of  the field. The order of the fields in the sequence is\nimplementation-dependent, but implementations are encouraged to preserve and use\nthe order in which the fields were added.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe type of mapping values can be described by two kinds of type descriptors.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003emapping-type-descriptor :=\n   map-type-descriptor | record-type-descriptor\n\u003c/pre\u003e\n\u003cp\u003e\nThe inherent type of a mapping value must be a\n\u003ccode\u003emapping-type-descriptor\u003c/code\u003e. The inherent type of a mapping value\ndetermines a type T\u003csub\u003e\u003cem\u003ef\u003c/em\u003e\u003c/sub\u003e for the value of the field with name\n\u003cem\u003ef\u003c/em\u003e. The runtime system will enforce a constraint that a value written to\nfield \u003cem\u003ef\u003c/em\u003e will belong to type T\u003csub\u003e\u003cem\u003ef\u003c/em\u003e\u003c/sub\u003e. Note that the\nconstraint is not merely that the value looks like T\u003csub\u003e\u003cem\u003ef\u003c/em\u003e\u003c/sub\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nBoth kinds of type descriptor are covariant in the types of their members.\n\u003c/p\u003e\n\u003ch5\u003eMap types\u003c/h5\u003e\n\u003cp\u003e\nA map type-descriptor describes a type of mapping value by specifying the type\nthat the value for all fields must belong to.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003emap-type-descriptor := \u003ccode\u003emap\u003c/code\u003e type-parameter\ntype-parameter := \u003ccode\u003e\u0026lt;\u003c/code\u003e type-descriptor \u003ccode\u003e\u003e\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nA type \u003ccode\u003emap\u0026lt;T\u003e\u003c/code\u003e contains a mapping shape \u003cem\u003em\u003c/em\u003e if every field\nshape in \u003cem\u003em\u003c/em\u003e has a value shape that is in \u003ccode\u003eT\u003c/code\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nA value belonging to type \u003ccode\u003emap\u0026lt;T\u003e\u003c/code\u003e is iterable as a sequence of\nvalues of type \u003ccode\u003e(string, T)\u003c/code\u003e.\n\u003c/p\u003e\n\u003ch5\u003eRecord types\u003c/h5\u003e\n\u003cp\u003e\nA record type descriptor describes a type of mapping value by specifying a type\nseparately for the value of each field.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003erecord-type-descriptor :=\n   inclusive-record-type-descriptor | exclusive-record-type-descriptor\ninclusive-record-type-descriptor :=\n   \u003ccode\u003erecord\u003c/code\u003e \u003ccode\u003e{\u003c/code\u003e field-descriptor* \u003ccode\u003e}\u003c/code\u003e\nexclusive-record-type-descriptor :=\n   \u003ccode\u003erecord\u003c/code\u003e \u003ccode\u003e{|\u003c/code\u003e field-descriptor* [record-rest-descriptor] \u003ccode\u003e|}\u003c/code\u003e\nfield-descriptor :=\n   individual-field-descriptor | record-type-reference\nindividual-field-descriptor :=\n   type-descriptor field-name [\u003ccode\u003e?\u003c/code\u003e | default-value] \u003ccode\u003e;\u003c/code\u003e\ndefault-value := \u003ccode\u003e=\u003c/code\u003e expression\nrecord-type-reference := \u003ccode\u003e*\u003c/code\u003e type-descriptor-reference \u003ccode\u003e;\u003c/code\u003e\nrecord-rest-descriptor := type-descriptor \u003ccode\u003e...\u003c/code\u003e \u003ccode\u003e;\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nEach \u003ccode\u003eindividual-field-descriptor\u003c/code\u003e specifies an additional constraint\nthat a mapping value shape must satisfy for it to be a member of the described\ntype. The constraint depends on whether \u003ccode\u003e?\u003c/code\u003e is present:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eif \u003ccode\u003e?\u003c/code\u003e is not present, then the constraint is that the mapping\nvalue shape must have a field shape with the specified field-name and with a\nvalue shape that is a member of the specified type-descriptor; this is called a\nrequired field;\u003c/li\u003e\n\u003cli\u003eif \u003ccode\u003e?\u003c/code\u003e is present, then the constraint is that if the mapping\nvalue shape has a field shape with the specified field-name, then its value\nshape must be a member of the specified type-descriptor; this is called an\noptional field.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nThe order of the \u003ccode\u003eindividual-field-descriptor\u003c/code\u003es within a\n\u003ccode\u003erecord-type-descriptor\u003c/code\u003e is not significant. Note that the delimited\nidentifier syntax allows the field name to be any non-empty string.\n\u003c/p\u003e\n\u003cp\u003e\nAn exclusive-record-type-descriptor, which uses the \u003ccode\u003e{|\u003c/code\u003e and\n\u003ccode\u003e|}\u003c/code\u003e delimiters, allows exclusively the fields described. More\nprecisely, for a mapping value shape and a record-type-descriptor, let the extra\nfield shapes be the field shapes of the mapping value shapes whose names are not\nthe same as field-name of any individual-field-descriptor; a mapping value shape\nis a member of the type described by an exclusive-record-type-descriptor only if\neither:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ethere are no extra fields shapes, or\u003c/li\u003e\n\u003cli\u003ethere is a record-rest-descriptor \u003ccode\u003eT...\u003c/code\u003e, and the value shape of\nevery extra field shape is a member of \u003ccode\u003eT\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nAn inclusive-record-type-descriptor, which uses the \u003ccode\u003e{\u003c/code\u003e and\n\u003ccode\u003e}\u003c/code\u003e delimiters, allows any mapping value that includes the fields\ndescribed. More precisely, a type descriptor \u003ccode\u003erecord { F };\u003c/code\u003e is\nequivalent to \u003ccode\u003erecord {| F; T...; |}\u003c/code\u003e, where T is the type that\ncontains all pure shapes (which can be written as \u003ccode\u003eanydata|error\u003c/code\u003e).\n\u003c/p\u003e\n\u003cp\u003e\nA record type descriptor that either is an inclusive-record-type-descriptor or\nis an exclusive-record-type-descriptor with a record-rest-descriptor is called\n\u003cem\u003eopen\u003c/em\u003e; a record type descriptor that is not open is called\n\u003cem\u003eclosed\u003c/em\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nA \u003ccode\u003edefault-value\u003c/code\u003e specifies a default value for the field, which is\nused when the record type descriptor is used to construct a mapping value but no\nvalue is specified explicitly for the field. The type descriptor contains a\n0-argument function closure for each default value. The closure is created from\nthe expression when the type descriptor is resolved. The closure is evaluated to\ncreate a field value each time the default is used in the construction of a\nmapping value. The default value does not affect the type described by the type\ndescriptor.\n\u003c/p\u003e\n\u003cp\u003e\nA \u003ccode\u003erecord-type-reference\u003c/code\u003e pulls in fields from a named record type.\nThe \u003ccode\u003etype-descriptor-reference\u003c/code\u003e must reference a type defined by a\n\u003ccode\u003erecord-type-descriptor\u003c/code\u003e. The \u003ccode\u003efield-descriptor\u003c/code\u003es and any\n\u003ccode\u003erecord-rest-descriptor\u003c/code\u003e are copied into the type being defined; the\nmeaning is the same as if they had been specified explicitly. For default\nvalues, the closure rather than the expression is copied in. A\n\u003ccode\u003erecord-rest-descriptor\u003c/code\u003e in the referencing type overrides any\n\u003ccode\u003erecord-rest-descriptor\u003c/code\u003e in the referenced type. For the purposes of\nresolving a \u003ccode\u003erecord-type-reference\u003c/code\u003e, a referenced or referencing type\nthat is an \u003ccode\u003einclusive-record-type-descriptor\u003c/code\u003e is treated as if it\nwere the equivalent \u003ccode\u003eexclusive-record-type-descriptor\u003c/code\u003e with an\nexplicit \u003ccode\u003erecord-rest-descriptor\u003c/code\u003e.\n\u003c/p\u003e\n\u003ch4\u003e[Preview] Tables\u003c/h4\u003e\n\u003cp\u003e\nA table is intended to be similar to the table of relational database table. A\ntable value contains an immutable set of column names and a mutable bag of rows.\nEach column name is a string; each row is a mapping that associates a value with\nevery column name; a bag of rows is a collection of rows that is unordered and\nallows duplicates.\n\u003c/p\u003e\n\u003cp\u003e\nA table value also contains a boolean flag for each column name saying whether\nthat column is a primary key for the table; this flag is immutable. If no\ncolumns have this flag, then the table does not have a primary key. Otherwise\nthe value for all primary keys together must uniquely identify each row in the\ntable; in other words, a table cannot have two rows where for every column\nmarked as a primary key, that value of that column in both rows is the same.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003etable-type-descriptor := \u003ccode\u003etable\u003c/code\u003e \u003ccode\u003e{\u003c/code\u003e column-type-descriptor+ \u003ccode\u003e}\u003c/code\u003e\ncolumn-type-descriptor :=\n   individual-column-type-descriptor\n   | column-record-type-reference\nindividual-column-type-descriptor :=\n   [\u003ccode\u003ekey\u003c/code\u003e] type-descriptor column-name \u003ccode\u003e;\u003c/code\u003e\ncolumn-record-type-reference :=\n   \u003ccode\u003e*\u003c/code\u003e type-reference [key-specifier (\u003ccode\u003e,\u003c/code\u003e key-specifier)*] \u003ccode\u003e;\u003c/code\u003e\nkey-specifier := \u003ccode\u003ekey\u003c/code\u003e column-name\ncolumn-name := identifier\n\u003c/pre\u003e\n\u003cp\u003e\nA table type descriptor has a descriptor for each column, which specifies the\nname of the column, whether that column is part of a primary key and the type\nthat values in that column must belong to. The type descriptor for the column\nmust be a pure type. If a column is part of a primary key, then the type\ndescriptor for the column must also allow only non-nil simple values.\n\u003c/p\u003e\n\u003cp\u003e\nNote that a table type T' will be a subtype of a table type T if and only if:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eT and T' have the same set of column names;\u003c/li\u003e\n\u003cli\u003eT and T' have the same set of primary keys; and\u003c/li\u003e\n\u003cli\u003efor each column, the type for that column in T' is a subtype of the type of\nthat column in T.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nA table is iterable as a sequence of mapping values, one for each row, where\neach mapping value has a field for each column, with the column as the field\nname and the value of that column in that row as the field value. The mapping\nvalues will belong to a closed record type.\n\u003c/p\u003e\n\u003cp\u003e\nIssues:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNeed to say that unique constraint is part of the value.\u003c/li\u003e\n\u003cli\u003eDo we want to allow values that are distinct but numerically equal e.g. -0.0\nand +0.0 or 1.0 and 1 in primary key columns?\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003eXML\u003c/h4\u003e\n\n\u003cpre class=\"grammar\"\u003exml-type-descriptor := \u003ccode\u003exml\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nAn XML value represents an immutable sequence of zero or more of the items that\ncan occur inside an XML element, specifically:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eelements\u003c/li\u003e\n\u003cli\u003echaracters\u003c/li\u003e\n\u003cli\u003eprocessing instructions\u003c/li\u003e\n\u003cli\u003ecomments\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nThe attributes of an element are represented by a map\u0026lt;string\u003e. The content of\neach element in the sequence is itself a distinct XML value. Although the\nsequence is immutable, an element can be mutated to change its content to be\nanother XML value.\n\u003c/p\u003e\n\u003cp\u003e\nAn XML value is iterable as a sequence of its items, where each character item\nis represented by a string with a single code point and other items are\nrepresented by a singleton XML value. A single XML item, such as an element, is\nrepresented by a sequence consisting of just that item.\n\u003c/p\u003e\n\u003ch4\u003eError\u003c/h4\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eerror-type-descriptor := \u003ccode\u003eerror\u003c/code\u003e [error-type-params]\nerror-type-params := \u003ccode\u003e\u0026lt;\u003c/code\u003e (explicit-error-type-params | inferred-error-type-param) \u003ccode\u003e\u0026gt;\u003c/code\u003e\nexplicit-error-type-params := reason-type-descriptor [\u003ccode\u003e,\u003c/code\u003e detail-type-descriptor]\nreason-type-descriptor := type-descriptor\ndetail-type-descriptor := type-descriptor\ninferred-error-type-param := \u003ccode\u003e*\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nAn error value belongs to the error basic type, which is a basic type which is\ndistinct from other structured types and is used only for representing errors.\nAn error value contains the following information:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ea reason, which is a string identifier for the category of error\u003c/li\u003e\n\u003cli\u003ea detail, which is a frozen mapping providing additional information about\nthe error\u003c/li\u003e\n\u003cli\u003ea stack trace\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nAn error value is immutable, since the detail is frozen and the stack trace\ninformation cannot be changed.\n\u003c/p\u003e\n\u003cp\u003e\nThe shape of an error value consists of the shape of the reason and the shape of\nthe detail; the stack trace is not part of the shape. A type descriptor\nerror\u0026lt;\u003cvar\u003er\u003c/var\u003e, \u003cvar\u003ed\u003c/var\u003e\u0026gt; contains an error shape if \u003cvar\u003er\u003c/var\u003e\ncontains the shape's reason, and \u003cvar\u003ed\u003c/var\u003e, if present, contains the shape's\ndetail. The bare type error contains all error shapes. The\nreason-type-descriptor must be a subtype of string; the detail-type-descriptor\nmust be a subtype of \u003ccode\u003erecord { }\u003c/code\u003e (which is equivalent to\n\u003ccode\u003emap\u0026lt;anydata|error\u0026gt;\u003c/code\u003e).\n\u003c/p\u003e\n\u003cp\u003e\nA type of \u003ccode\u003eerror\u0026lt;*\u0026gt;\u003c/code\u003e means that the type is a subtype of error,\nwhere the precise subtype is to be inferred from the context. This is allowed\nonly within type descriptors occurring in a context that is specified to be\ninferable.\n\u003c/p\u003e\n\u003cp\u003e\nError is the only structured basic type that is not iterable.\n\u003c/p\u003e\n\u003ch3\u003eBehavioral values\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003ebehavioral-type-descriptor :=\n   function-type-descriptor\n   | object-type-descriptor\n   | future-type-descriptor\n   | service-type-descriptor\n   | stream-type-descriptor\n   | typedesc-type-descriptor\n\u003c/pre\u003e\n\u003ch4 id=\"functions\"\u003eFunctions\u003c/h4\u003e\n\n\u003cpre\nclass=\"grammar\"\u003efunction-type-descriptor := \u003ccode\u003efunction\u003c/code\u003e function-signature\nfunction-signature := \u003ccode\u003e(\u003c/code\u003e param-list \u003ccode\u003e)\u003c/code\u003e return-type-descriptor\nreturn-type-descriptor := [ \u003ccode\u003ereturns\u003c/code\u003e annots type-descriptor ]\nparam-list :=\n   required-params [\u003ccode\u003e,\u003c/code\u003e defaultable-params] [\u003ccode\u003e,\u003c/code\u003e rest-param]\n   | defaultable-params [\u003ccode\u003e,\u003c/code\u003e rest-param]\n   | [rest-param]\nrequired-params := required-param (\u003ccode\u003e,\u003c/code\u003e required-param)*\nrequired-param := annots type-descriptor param-name\ndefaultable-params := defaultable-param (\u003ccode\u003e,\u003c/code\u003e defaultable-param)*\ndefaultable-param := annots type-descriptor param-name default-value\nrest-param := annots type-descriptor \u003ccode\u003e...\u003c/code\u003e [param-name]\n\u003c/pre\u003e\n\u003cp\u003e\nA function is a part of a program that can be explicitly executed. In Ballerina,\na function is also a value, implying that it can be stored in variables, and\npassed to or returned from functions. When a function is executed, it is passed\nan argument list as input and returns a value as output.\n\u003c/p\u003e\n\u003cp\u003e\nWhen the execution of a function returns to its caller, it returns exactly one\nvalue. A function that would in other programming languages not return a value\nis represented in Ballerina by a function returning \u003ccode\u003e()\u003c/code\u003e. Note that\nthe function definition does not have to explicitly return \u003ccode\u003e()\u003c/code\u003e; a\nreturn statement or falling off the end of the function body will implicitly\nreturn \u003ccode\u003e()\u003c/code\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nThe argument list passed to a function consists of zero or arguments in order;\neach argument is a value, but the argument list itself is not passed as a value.\nThe argument list must conform to the param-list as described in this section.\nUsually, the compiler's type checking will ensure that this is the case; if not,\nthe function will panic.\n\u003c/p\u003e\n\u003cp\u003e\nIt is convenient to consider the complete param-list as having a type. This type\nis described by a tuple-type-descriptor that has a member-type-descriptor for\neach required-param and defaultable-param, and has a tuple-rest-descriptor if\nand only if there is a rest-param. The i-th member-type-descriptor of the tuple\ntype descriptor is the same as the type-descriptor of the i-th member of the\nparam-list; the type-descriptor of the tuple-rest-descriptor, if present, is the\nsame as the type-descriptor of the rest-param.\n\u003c/p\u003e\n\u003cp\u003e\nAn argument list consisting of values v\u003csub\u003e1\u003c/sub\u003e,..., v\u003csub\u003en\u003c/sub\u003e conforms\nto a param-list that has type P, if and only if for each i with 1 \u0026lt;= i \u0026lt;=\nn, vi belongs to T\u003csub\u003ei\u003c/sub\u003e, where T\u003csub\u003ei\u003c/sub\u003e is defined to be the type\nthat contains a shape s if and only if P contains a list shape whose i-th member\nis s.\n\u003c/p\u003e\n\u003cp\u003e\nWhen an argument list is passed to a function, the non-rest parameters are\ninitialized from the arguments in the argument list in order. The conformance of\nthe argument list to the param-list declared for the function ensures that each\nparameter will be initialized to a value that belongs to the declared type of\nthe parameter. If there is a rest-param, then that is a initialized to a newly\ncreated lists containing the remaining arguments in the argument-list; the\ninherent type of this list will be T[] where T is the type of the rest-param.\nThe conformance of the argument list ensures that the members of this list will\nbelong to type T.\n\u003c/p\u003e\n\u003cp\u003e\nA defaultable-param is a parameter for which a default value is specified. The\nexpression specifying the default value may refer to previous parameters by\nname. For each defaultable parameter, the function's type descriptor includes a\nclosure that computes the default value for the parameter using the values of\nprevious parameters. The caller of the function uses the closures in the\nfunction's type descriptor to compute default values for any defaultable\narguments that were not specified explicitly. These default values are included\nin the argument list passed to the function. Whether a parameter is defaultable,\nand what its default is, do not affect the shape of the function and thus do not\naffect typing. The closures computing the defaultable parameters are created\nwhen the type descriptor is resolved; the default value is computed by calling\nthe closure each time the function is called and the corresponding parameter is\nnot specified. Whether a parameter is defaultable is used at compile time, but\nthe closure that computes the default value is only used at runtime.\n\u003c/p\u003e\n\u003cp\u003e\nThe name of each parameter is included in the function's type descriptor. A\ncaller of the function may specify parameters by name. In this case, the caller\nuses the parameter name at compile time in conjunction with the type descriptor\nto create the argument list. The parameter names do not affect the shape of the\nfunction and thus do not affect typing.\n\u003c/p\u003e\n\u003cp\u003e\nThe process by which the function caller creates an argument list, which may\nmake use of arguments specified both by position and by name, is described in\nmore detail in the \u003ca href=\"#function_call\"\u003esection on function calls\u003c/a\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nFunction types are covariant in their return types and contravariant in the type\nof their parameter lists. More precisely, a function type with return type R and\nparameter list type P is a subtype of a function type with return type R' and\nparameter list type P' if and only if R is a subtype of R' and P' is a subtype\nof P. A function value f belongs to a function type T if the declared type of f\nis a subtype of T.\n\u003c/p\u003e\n\u003ch4\u003eObjects\u003c/h4\u003e\n\u003cp\u003e\nObjects are a combination of fields along with a set of associated functions,\ncalled methods, which can be used to manipulate them. An object's methods are\nassociated with the object when the object is constructed and cannot be changed\nthereafter. The fields and methods of an object are in separate namespaces, so\nit is possible for an object to have a field and a method with the same name.\n\u003c/p\u003e\n\u003cp\u003e\nAn object type descriptor, in addition to describing the object type, also\ndefines a way to construct an object of this type, in particular it provides the\nmethod definitions that are associated with the object when it is constructed.\n\u003c/p\u003e\n\u003cp\u003e\nIt is also possible to have an object type descriptor that only describes an\nobject type and cannot be used to construct an object; this is called an\nabstract object type descriptor.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eobject-type-descriptor :=\n   object-type-quals \u003ccode\u003eobject\u003c/code\u003e \u003ccode\u003e{\u003c/code\u003e\n      object-member-descriptor*    \u003ccode\u003e}\u003c/code\u003e\nobject-type-quals :=\n   [\u003ccode\u003eabstract\u003c/code\u003e] [\u003ccode\u003eclient\u003c/code\u003e] | [\u003ccode\u003eclient\u003c/code\u003e] \u003ccode\u003eabstract\u003c/code\u003e\nobject-member-descriptor :=\n   object-field-descriptor\n   | object-method\n   | object-type-reference\n\u003c/pre\u003e\n\u003cp\u003e\nIf \u003ccode\u003eobject-type-quals\u003c/code\u003e contains the keyword \u003ccode\u003eabstract\u003c/code\u003e,\nthen the object type descriptor is an abstract object type descriptor. An\nabstract object type descriptor must not have an object-ctor-function.\n\u003c/p\u003e\n\u003cp\u003e\nIf \u003ccode\u003eobject-type-quals\u003c/code\u003e contains the keyword \u003ccode\u003eclient\u003c/code\u003e, then\nthe object type is a client object type. A client object type may have remote\nmethods; other objects types must not.\n\u003c/p\u003e\n\u003ch5\u003eFields\u003c/h5\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eobject-field-descriptor :=\n   object-visibility-qual type-descriptor field-name [default-value]\u003ccode\u003e;\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nAn \u003ccode\u003eobject-field-descriptor\u003c/code\u003e specifies a field of the object. The\nnames of all the fields of an object must be distinct.\n\u003c/p\u003e\n\u003ch5\u003eMethods\u003c/h5\u003e\n\u003cp\u003e\nMethods are functions that are associated to the object and are called via a\nvalue of that type using a \u003ccode\u003emethod-call-expr\u003c/code\u003e.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eobject-method := method-decl | method-defn\nmethod-decl :=\n   metadata\n   object-visibility-qual [\u003ccode\u003eremote\u003c/code\u003e]\n   \u003ccode\u003efunction\u003c/code\u003e method-name function-signature \u003ccode\u003e;\u003c/code\u003e\nmethod-defn :=\n   metadata\n   method-defn-quals\n   \u003ccode\u003efunction\u003c/code\u003e method-name function-signature method-body\nmethod-defn-quals := object-visibility-qual [\u003ccode\u003eremote\u003c/code\u003e]\nmethod-name := identifier\nmethod-body := function-body\n\u003c/pre\u003e\n\u003cp\u003e\nThe names of all the methods of an object must be distinct: there is no method\noverloading. Method names beginning with two underscores are reserved for use by \u003ca\nhref=\"#built-in_abstract_object_types\"\u003ebuilt-in abstract object types\u003c/a\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nWithin a \u003ccode\u003emethod-body\u003c/code\u003e, the fields and methods of the object are not\nimplicitly in-scope; instead the keyword \u003ccode\u003eself\u003c/code\u003e is bound to the\nobject and can be used to access fields and methods of the object.\n\u003c/p\u003e\n\u003cp\u003e\nAll the methods of an object type must be either declared or defined in the\nobject. A \u003ccode\u003emethod-decl\u003c/code\u003e declares a method without defining it; a\n\u003ccode\u003emethod-defn\u003c/code\u003e also supplies a definition.  An abstract object type\ndescriptor must not contain a \u003ccode\u003emethod-defn\u003c/code\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nA method that is declared or defined with the remote qualifier is a remote\nmethod. A remote method is allowed only in a client object. A remote method is\ninvoked using a different syntax from a non-remote method.\n\u003c/p\u003e\n\u003cp\u003e\nAny method that is declared but not defined within an object that is not\nabstract must be defined outside the object at the top-level of the module:\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eoutside-method-defn :=\n   annots\n   method-defn-quals\n   \u003ccode\u003efunction\u003c/code\u003e qual-method-name function-signature function-body\nqual-method-name := object-type-name \u003ccode\u003e.\u003c/code\u003e method-name\n\u003c/pre\u003e\n\u003cp\u003e\nThe \u003ccode\u003emethod-defn-quals\u003c/code\u003e on an outside-method-defn must contain the\nsame qualifiers (both \u003ccode\u003eremote\u003c/code\u003e and visibility qualifiers) as the\ndeclaration of the method within the object.\n\u003c/p\u003e\n\u003ch5\u003eVisibility\u003c/h5\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eobject-visibility-qual := [explicit-visibility-qual]\nexplicit-visibility-qual := \u003ccode\u003epublic\u003c/code\u003e | \u003ccode\u003eprivate\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nEach field and method of an object type is visible within and can be accessed\nfrom a specific region of code, which is specified by its object-visibility-qual\nas follows:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eif the object-visibility qual is \u003ccode\u003eprivate\u003c/code\u003e, then the visibility\nregion consists of the methods defined by this object type descriptor;\u003c/li\u003e\n\u003cli\u003eif the object-visibility-qual is empty, then the visibility region is the\nentire module containing this object type descriptor; this is called\nmodule-level visibility;\u003c/li\u003e\n\u003cli\u003eif the object-visibility-qual is \u003ccode\u003epublic\u003c/code\u003e, then the visibility region\ncontains all modules.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nThe visibility of a method or field of an abstract object type cannot be\n\u003ccode\u003eprivate\u003c/code\u003e.\n\u003c/p\u003e\n\u003ch5\u003eTyping\u003c/h5\u003e\n\n\u003cp\u003e\nThe shape of an object consists of an unordered collection of object field\nshapes and an unordered collection of object method shapes. An object field\nshape or object method shape is a triple consisting of the name of the field or\nmethod, the visibility region, and a shape for the value of the field or for the\nmethod's function.\n\u003c/p\u003e\n\u003cp\u003e\nAn object type is inclusive, in a similar way to an\ninclusive-record-type-descriptor: an object shape belongs to an object type if\nit has at least the fields and methods described in the object-type-descriptor.\nThus all object values belong to the type \u003ccode\u003eobject { }\u003c/code\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nAn object-type-descriptor that has a field with name f, visibility region R and\ntype T contains an object shape only if the object shape contains an object\nfield shape that has name f, visibility region R and a value shape that is\ncontained in T. An object-type-descriptor that has a method with name m,\nvisibility region R and function type T contains an object shape only if the\nobject shape contains an object method shape that has name m, visibility region\nR and a function value that belongs to type T.\n\u003c/p\u003e\n\u003cp\u003e\nThus an object type T' is a subtype of an object type T only if for each field\nor method f of T there is a corresponding field or method f' of T such that the\ntype of f' in T' is a subtype of the type of f in T and the visibility region of\nf' in T' is the same as the visibility region of f in T.\n\u003c/p\u003e\n\u003cp\u003e\nThis implies that:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eif an object type descriptor T has private fields or methods, then it is not\npossible to define another object type descriptor that is a subtype of T,\nand\u003c/li\u003e\n\u003cli\u003eif an object type descriptor T has fields or methods with module-level\nvisibility, then it is possible to define another object type descriptor that is\na subtype of T only within the same module as T.\u003c/li\u003e\n\u003c/ul\u003e\n \n\u003ch5\u003eInitialization\u003c/h5\u003e\n\u003cp\u003e\nA non-abstract object type provides a way to initialize an object of the type.\nAn object is initialized by:\n\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eallocating storage for the object\u003c/li\u003e\n\u003cli\u003einitializing each field with its default value, if it has one\u003c/li\u003e\n\u003cli\u003einitializing the methods of the object using the type's method definitions\u003c/li\u003e\n\u003cli\u003ecalling the object's \u003ccode\u003e__init\u003c/code\u003e method, if there is one\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\nThe return type of the \u003ccode\u003e__init\u003c/code\u003e method must be a subtype of the union\nof error and nil, and must contain nil; if \u003ccode\u003e__init\u003c/code\u003e returns an error,\nit means that initialization of the object failed. The \u003ccode\u003e__init\u003c/code\u003e\nmethod can declare parameters in the same way as any other method.\n\u003c/p\u003e\n\u003cp\u003e\nAt any point in the body of a \u003ccode\u003e__init\u003c/code\u003e method, the compiler\ndetermines which fields are potentially uninitialized. A field is potentially\nuninitialized at some point if that field does not have a default value and it\nis not definitely assigned at that point. It is a compile error if a\n\u003ccode\u003e__init\u003c/code\u003e method:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eaccesses a field at a point where it is potentially initialized, or\u003c/li\u003e\n\u003cli\u003eat a point where there is any potentially uninitialized value\n\u003cul\u003e\n\u003cli\u003ereturns nil, or\u003c/li\u003e\n\u003cli\u003euses the \u003ccode\u003eself\u003c/code\u003e variable other than to access or modify the value of a field.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nAn object must have a __init method unless all its fields have a default value.\nAn object without a __init method behaves as it had a __init method with no\nparameters and an empty body (which will always return nil).\n\u003c/p\u003e\n\u003cp\u003e\nThe visibility of the \u003ccode\u003e__init\u003c/code\u003e method cannot be \u003ccode\u003eprivate\u003c/code\u003e.\n\u003c/p\u003e\n\u003ch5\u003eObject type references\u003c/h5\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eobject-type-reference :=\n   \u003ccode\u003e*\u003c/code\u003e type-descriptor-reference \u003ccode\u003e;\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nThe \u003ccode\u003etype-descriptor-reference\u003c/code\u003e in an\n\u003ccode\u003eobject-type-reference\u003c/code\u003e must reference an abstract object type. The\nobject-member-descriptors from the referenced type are copied into the type\nbeing defined; the meaning is the same as if they had been specified explicitly.\n\u003c/p\u003e\n\u003cp\u003e\nIf a non-abstract object type T\u003csub\u003eo\u003c/sub\u003e has a type reference to an abstract\nobject type T\u003csub\u003ea\u003c/sub\u003e, then each method declared in T\u003csub\u003ea\u003c/sub\u003e must be\ndefined in T\u003csub\u003eo\u003c/sub\u003e using either a \u003ccode\u003emethod-defn\u003c/code\u003e or an\n\u003ccode\u003eoutside-method-defn\u003c/code\u003e with the same visibility. If T\u003csub\u003ea\u003c/sub\u003e has\na method or field with module-level visibility, the T\u003csub\u003eo\u003c/sub\u003e must be in the\nsame module.\n\u003c/p\u003e\n\u003ch4\u003eFutures\u003c/h4\u003e\n\n\u003cpre\nclass=\"grammar\"\u003efuture-type-descriptor := \u003ccode\u003efuture\u003c/code\u003e [type-parameter]\n\u003c/pre\u003e\n\u003cp\u003e\nA future value represents a value to be returned by a named worker.  A future\nvalue belongs to a type \u003ccode\u003efuture\u0026lt;T\u003e\u003c/code\u003e if the value to be returned\nbelongs to T.\n\u003c/p\u003e\n\u003cp\u003e\nA value belongs to a type \u003ccode\u003efuture\u003c/code\u003e (without the type-parameter)\nif it has basic type future.\n\u003c/p\u003e\n\u003ch4\u003e[Preview] Services\u003c/h4\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eservice-type-descriptor := \u003ccode\u003eservice\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nA service value contains resources and methods. A service method is similar to\nan object method. A resource is a special kind of method, with associated\nconfiguration data, that is invoked in response to network input received by a\nListener.\n\u003c/p\u003e\n\u003cp\u003e\nAll service values belong to the type \u003ccode\u003eservice\u003c/code\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nIt is planned that a future version of Ballerina will provide a mechanism that\nallows more precise typing of services. In the meantime, implementations can use\nannotations on type definitions to support this.\n\u003c/p\u003e\n\u003ch4\u003e[Preview] Streams\u003c/h4\u003e\n\n\u003cpre\nclass=\"grammar\"\u003estream-type-descriptor := \u003ccode\u003estream\u003c/code\u003e [type-parameter]\n\u003c/pre\u003e\n\u003cp\u003e\nA value of type \u003ccode\u003estream\u0026lt;T\u003e\u003c/code\u003e is a distributor for values of type\n\u003ccode\u003eT\u003c/code\u003e: when a value v of type T is put into the stream, a function will\nbe called for each subscriber to the stream with v as an argument. T must be a\npure type.\n\u003c/p\u003e\n\u003cp\u003e\nA value belongs to a type \u003ccode\u003estream\u003c/code\u003e (without the type-parameter)\nif it has basic type stream.\n\u003c/p\u003e\n\n\u003ch4\u003eType descriptors\u003c/h4\u003e\n\u003cpre\nclass=\"grammar\"\u003etypedesc-type-descriptor := \u003ccode\u003etypedesc\u003c/code\u003e [type-parameter]\n\u003c/pre\u003e\n\u003cp\u003e\nA type descriptor value is an immutable value representing a resolved type\ndescriptor. The type typedesc contains all values with basic type typedesc. A\ntypedesc value \u003cvar\u003et\u003c/var\u003e belongs to a type typedesc\u0026lt;\u003cvar\u003eT\u003c/var\u003e\u0026gt; if\nand only if the type described by \u003ccode\u003et\u003c/code\u003e is a subtype of \u003cvar\u003eT\u003c/var\u003e.\nThe typedesc type is thus covariant with its type parameter.\n\u003c/p\u003e\n\u003cp\u003e\nReferencing an identifier defined by a type definition in an expression context\nwill result in a type descriptor value.\n\u003c/p\u003e\n\n\u003ch3\u003eType descriptors\u003c/h3\u003e\n\u003cpre\nclass=\"grammar\"\u003etype-descriptor :=\n   simple-type-descriptor\n   | structured-type-descriptor\n   | behavioral-type-descriptor\n   | singleton-type-descriptor\n   | union-type-descriptor\n   | optional-type-descriptor\n   | any-type-descriptor\n   | anydata-type-descriptor\n   | byte-type-descriptor\n   | json-type-descriptor\n   | type-descriptor-reference\n   | \u003ccode\u003e(\u003c/code\u003e type-descriptor \u003ccode\u003e)\u003c/code\u003e\ntype-descriptor-reference := qualified-identifier\n\u003c/pre\u003e\n\u003cp\u003e\nIt is important to understand that the type descriptors specified in this\nsection do not add to the universe of values. They are just adding new ways to\ndescribe subsets of this universe.\n\u003c/p\u003e\n\u003ch4\u003eSingleton types\u003c/h4\u003e\n\n\u003cpre\nclass=\"grammar\"\u003esingleton-type-descriptor := simple-const-expr\n\n\u003c/pre\u003e\n\u003cp\u003e\nA singleton type is a type containing a single shape. A singleton type is\ndescribed using an compile-time constant expression for a single value: the type\ncontains the shape of that value. Note that it is possible for the\nvariable-reference within the simple-const-expr to reference a structured value.\n\u003c/p\u003e\n\u003ch4\u003eUnion types\u003c/h4\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eunion-type-descriptor := type-descriptor \u003ccode\u003e|\u003c/code\u003e type-descriptor\n\u003c/pre\u003e\n\u003cp\u003e\nThe value space of a union type \u003ccode\u003eT1|T2\u003c/code\u003e is the union of\n\u003ccode\u003eT1\u003c/code\u003e and \u003ccode\u003eT2\u003c/code\u003e.\n\u003c/p\u003e\n\u003ch4\u003eOptional types\u003c/h4\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eoptional-type-descriptor := type-descriptor \u003ccode\u003e?\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nA type \u003ccode\u003eT?\u003c/code\u003e means T optionally, and is exactly equivalent to\n\u003ccode\u003eT|()\u003c/code\u003e.\n\u003c/p\u003e\n\u003ch4\u003eAny Type\u003c/h4\u003e\n\n\u003cpre class=\"grammar\"\u003eany-type-descriptor := \u003ccode\u003eany\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nThe type descriptor \u003ccode\u003eany\u003c/code\u003e describes the type consisting of all values\nother than errors. A value belongs to the any type if and only if its basic type\nis not error. Thus all values belong to the type \u003ccode\u003eany|error\u003c/code\u003e. Note\nthat a structure with members that are errors belongs to the \u003ccode\u003eany\u003c/code\u003e\ntype.\n\u003c/p\u003e\n\u003ch4\u003eAnydata type\u003c/h4\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eanydata-type-descriptor := \u003ccode\u003eanydata\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nThe type descriptor \u003ccode\u003eanydata\u003c/code\u003e describes the type of all pure values\nother than errors. The type \u003ccode\u003eanydata\u003c/code\u003e contains a shape if and only if\nthe shape is pure and is not the shape of an error value.\n\u003c/p\u003e\n\u003cp\u003e\nThus the type \u003ccode\u003eanydata|error\u003c/code\u003e is the supertype of all pure types. The\ntype \u003ccode\u003eanydata\u003c/code\u003e is equivalent to the union\n\u003c/p\u003e\n\n\u003cpre\n\u003e  () | boolean | int | float | decimal | string\n    | (anydata|error)[] | map\u0026lt;anydata|error\u003e\n    | xml | table\n\u003c/pre\u003e\n\u003ch4\u003eByte type\u003c/h4\u003e\n\n\u003cpre class=\"grammar\"\u003ebyte-type-descriptor := \u003ccode\u003ebyte\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nThe byte type is an abbreviation for a union of the int values in the range 0 to\n255 inclusive.\n\u003c/p\u003e\n\u003ch4\u003eJSON types\u003c/h4\u003e\n\n\u003cpre\nclass=\"grammar\"\u003ejson-type-descriptor := json\n\njson means  () | boolean | int | float | decimal | string | json[] | map\u0026lt;json\u003e\n\u003c/pre\u003e\n\u003ch3 id=\"built-in_abstract_object_types\"\u003eBuilt-in abstract object types\u003c/h3\u003e\n\u003cp\u003e\nThere are several abstract object types that are built-in in the sense that the\nlanguage treats objects with these types specially. Note that it is only the\ntypes that are built-in; the names of these types are not built-in.\n\u003c/p\u003e\n\u003cp\u003e\n\u003cstrong\u003eNote\u003c/strong\u003e It is likely that a future version of this specification\nwill provide generic types, so that a library can provide definitions of these\nbuilt-in types.\n\u003c/p\u003e\n\u003ch4\u003eIterator\u003c/h4\u003e\n\u003cp\u003e\nA value that is iterable as a sequence of values of type T provides a way of\ncreating an iterator object that matches the type\n\u003c/p\u003e\n\n\u003cpre\n\u003e    abstract object {\n       public next() returns record {| T value; |}?;\n    }\n\u003c/pre\u003e\n\u003cp\u003e\nIn this specification, we refer to this type as Iterator\u0026lt;T\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nConceptually an iterator represents a position between members of the sequence.\nPossible positions are at the beginning (immediately before the first member if\nany), between members and at the end (immediately after the last member if any).\nA newly created iterator is at the beginning position. For an empty sequence,\nthere is only one possible position which is both at the beginning and at the\nend.\n\u003c/p\u003e\n\u003cp\u003e\nThe \u003ccode\u003enext()\u003c/code\u003e method behaves as follows:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eif the iterator is currently at the end position, return nil\u003c/li\u003e\n\u003cli\u003eotherwise\n\u003cul\u003e\n\u003cli\u003emove the iterator to next position, and\u003c/li\u003e\n\u003cli\u003ereturn a record \u003ccode\u003e{ value: v }\u003c/code\u003e where v is the member of the\nsequence between the previous position and the new position\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nNote that it is not possible for the \u003ccode\u003enext()\u003c/code\u003e method simply to return\na member of the sequence, since a nil member would be indistinguishable from the\nreturn value for the end position.\n\u003c/p\u003e\n\u003ch4\u003eIterable\u003c/h4\u003e\n\u003cp\u003e\nAn object can make itself be iterable as a sequence of values of type T by\nproviding a method named \u003ccode\u003e__iterator\u003c/code\u003e which returns a value that is a\nsubtype of Iterator\u0026lt;T\u003e. In this specification, we refer to this type as\nIterable\u0026lt;T\u003e.\n\u003c/p\u003e\n\u003ch4\u003eCollection\u003c/h4\u003e\n\u003cp\u003e\nAn object can declare itself to be a collection of values of type V indexed by\nkeys of type K, but defining a \u003ccode\u003e__get(K k)\u003c/code\u003e method returning a value\nof type V, that returns the value associated with key k. If the collection is\nmutable, then the object can also declare a \u003ccode\u003e__put(K k, V v)\u003c/code\u003e method\nthat changes the value associated with key k to to value v. In this\nspecification, we refer to these types as ImmutableCollection\u0026lt;T\u003e and\nMutableCollection\u0026lt;T\u003e.\n\u003c/p\u003e\n\u003ch4\u003eListener\u003c/h4\u003e\n\u003cp\u003e\nThe Listener type is defined as follows.\n\u003c/p\u003e\n\n\u003cpre\u003eabstract object {\n   function __attach (service s, string? name = ()) returns error?;\n   function __start () returns error?;\n   function __stop () returns error?;\n}\n\u003c/pre\u003e\n\u003cp\u003e\nNote that if an implementation does precise service typing using annotations on\ntype definitions, it will need to treat Listener as being parameterized in the\nprecise service type that is used to the first argument to\n\u003ccode\u003e__attach\u003c/code\u003e.\n\u003c/p\u003e\n\u003ch3\u003eAbstract operations\u003c/h3\u003e\n\u003cp\u003e\nThese section specifies a number of operations that can be performed on values.\nThese operations are for internal use by the specification.  These operations\nare named in CamelCase to distinguish them from built-in methods.\n\u003c/p\u003e\n\u003ch4\u003eFreeze\u003c/h4\u003e\n\u003cp\u003e\nFreeze(v) is defined for any pure value v. The result of Freeze(v) is always v.\nIt recursively freezes any structural values and their members, thus maintaining\nthe invariant that frozen values can only refer to immutable values. Freeze(v)\nfor a value v is already frozen or is of an immutable type (i.e. a simple type\nof error) just returns v without modifying it.  Freeze(v) must terminate for any\npure value v, even if v has cycles.\n\u003c/p\u003e\n\u003ch4\u003eClone\u003c/h4\u003e\n\u003cp\u003e\nClone(v) is defined for any pure value v. It performs a deep copy, recursively\ncopying all structural values and their members. Clone(v) for a value v that is\nfrozen or of an immutable type (ie a simple type or error) returns v. If v is a\ncontainer, Clone(v) has the same inherent type as v.  The graph of references of\nClone(v) must have the same structure as that of v. This implies that the number\nof distinct references reachable from Clone(v) must be the same as the number of\ndistinct references reachable from v.  Clone(v) must terminate for any pure\nvalue v, even if v has cycles.\n\u003c/p\u003e\n\u003cp\u003e\nClone(v) cannot be implemented simply by recursively calling Clone on all\nmembers of v. Rather Clone must maintain a map that records the result of\ncloning each reference value. When a Clone operation starts, this map as empty.\nWhen cloning a reference value, it must use the result recorded in the map if\nthere is one.\n\u003c/p\u003e\n\u003ch4\u003eUnfrozenClone\u003c/h4\u003e\n\u003cp\u003e\nUnfrozenClone works the same as Clone except for its treatment of frozen values.\nWhereas for a frozen value v, Clone(v) is v, UnfrozenClone(v) returns a new\nvalue that is not frozen and that has the same shape as v. UnfrozenClone handles\nvalues of immutable types (simple types and errors) in the same way as Clone.\nLike Clone, UnfrozenClone preserves graph structure.\n\u003c/p\u003e\n\u003ch4\u003eSameShape\u003c/h4\u003e\n\u003cp\u003e\nSameShape(v1, v2) is defined for any pure values v1, v2. It returns true or\nfalse depending of whether v1 and v2 have the same shape. SameShape(v1, v2) must\nterminate for any pure values v1 and v2, even if v1 or v2 have cycles.\nSameShape(v1, v2) returns true if v1 and v2 have the same shape, even if the\ngraphs of references of v1 and v2 have different structures.  If two values v1\nand v2 have different basic types, then SameShape(v1, v2) will be false.\n\u003c/p\u003e\n\u003cp\u003e\nThe possibility of cycles means that SameShape cannot be implemented simply by\ncalling SameShape recursively on members. Rather SameShape must maintaom a\nmapping that records for each pair of references whether it is already in\nprocess of comparing those references. When a SameShape operation starts, this\nmap is empty. Whenever it starts to compare two references, it should see\nwhether it has already recorded that pair (in either order), and, if it has,\nproceed on the assumption that they compare equal.\n\u003c/p\u003e\n\u003cp\u003e\nSameShape(Clone(x), x) is guaranteed to be true for any pure value.\n\u003c/p\u003e\n\u003ch4\u003eNumericConvert\u003c/h4\u003e\n\u003cp\u003e\nNumericConvert(t, v) is defined if t is the typedesc for float, decimal or int,\nand v is a numeric value. It converts v to a value in t, or returns an error,\naccording to the following table.\n\u003c/p\u003e\n\u003ctable\u003e\n  \u003ctr\u003e\n   \u003ctd\u003efrom  \\ to\u003c/td\u003e\n   \u003ctd\u003efloat\u003c/td\u003e\n   \u003ctd\u003edecimal\u003c/td\u003e\n   \u003ctd\u003eint\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003efloat\u003c/td\u003e\n   \u003ctd\u003eunchanged\u003c/td\u003e\n   \u003ctd\u003eclosest math value\u003c/td\u003e\n   \u003ctd rowspan=\"2\" \u003eround, error for NaN or out of int range\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003edecimal\u003c/td\u003e\n   \u003ctd\u003eclosest math value\u003c/td\u003e\n   \u003ctd\u003eunchanged\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003eint\u003c/td\u003e\n   \u003ctd\u003esame  math value\u003c/td\u003e\n   \u003ctd\u003esame math value\u003c/td\u003e\n   \u003ctd\u003eunchanged\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003ch3\u003eBinding patterns and variables\u003c/h3\u003e\n\u003ch4\u003eBinding patterns\u003c/h4\u003e\n\u003cp\u003e\nBinding patterns are used to support destructuring, which allows different parts\nof a single structured value each to be assigned to separate variables at the\nsame time.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003ebinding-pattern :=\n   capture-binding-pattern\n   | wildcard-binding-pattern\n   | list-binding-pattern\n   | mapping-binding-pattern\n   | error-binding-pattern\ncapture-binding-pattern := variable-name\nvariable-name := identifier\nwildcard-binding-pattern := \u003ccode\u003e_\u003c/code\u003e\nlist-binding-pattern := \u003ccode\u003e[\u003c/code\u003e list-member-binding-patterns \u003ccode\u003e]\u003c/code\u003e\nlist-member-binding-patterns :=\n   binding-pattern (\u003ccode\u003e,\u003c/code\u003e binding-pattern)* [\u003ccode\u003e,\u003c/code\u003e rest-binding-pattern]\n   | [ rest-binding-pattern ]\nmapping-binding-pattern := \u003ccode\u003e{\u003c/code\u003e field-binding-patterns \u003ccode\u003e}\u003c/code\u003e\nfield-binding-patterns :=\n   field-binding-pattern (\u003ccode\u003e,\u003c/code\u003e field-binding-pattern)* [\u003ccode\u003e,\u003c/code\u003e rest-binding-pattern]\n   | [ rest-binding-pattern ] \nfield-binding-pattern :=\n   field-name \u003ccode\u003e:\u003c/code\u003e binding-pattern\n   | variable-name\nrest-binding-pattern := \u003ccode\u003e...\u003c/code\u003e variable-name\nerror-binding-pattern := \u003ccode\u003eerror\u003c/code\u003e \u003ccode\u003e(\u003c/code\u003e error-arg-list-binding-pattern \u003ccode\u003e)\u003c/code\u003e\nerror-arg-list-binding-pattern :=\n   simple-binding-pattern (\u003ccode\u003e,\u003c/code\u003e named-arg-binding-pattern)* [\u003ccode\u003e,\u003c/code\u003e rest-binding-pattern]\n   | named-arg-binding-pattern (\u003ccode\u003e,\u003c/code\u003e named-arg-binding-pattern)* [\u003ccode\u003e,\u003c/code\u003e rest-binding-pattern]\n   | [ rest-binding-pattern ]\nsimple-binding-pattern :=\n   capture-binding-pattern\n   | wildcard-binding-pattern\nnamed-arg-binding-pattern := arg-name \u003ccode\u003e=\u003c/code\u003e binding-pattern\n\u003c/pre\u003e\n\u003cp\u003e\nA binding pattern may succeed or fail in matching a value. A successful match\ncauses values to be assigned to all the variables occurring the binding-pattern.\n\u003c/p\u003e\n\u003cp\u003e\nA binding pattern matches a value in any of the following cases.\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ea capture-binding-pattern always matches a value and causes the matched\nvalue to be assigned to named variable;\u003c/li\u003e\n\u003cli\u003ea wildcard-binding-pattern matches a value if the value belongs to type any,\nin other words if the basic type of the value is not error; it does not cause\nany assignments to be made;\u003c/li\u003e\n\u003cli\u003ea list-binding-pattern with m binding patterns matches a list with n\nmembers if m is less than or equal to m, and the i-th binding pattern matches\nthe i-th member of the list for each i in 1 to m, and either m is equal to n or\nthe list-binding-pattern includes a rest-binding-pattern; if there is a\nrest-binding-pattern \u003ccode\u003e...v\u003c/code\u003e, then a successful match causes a new\nlist value consisting of all members of the matched list except for the the\nfirst m values to be assigned to \u003ccode\u003ev\u003c/code\u003e;\u003c/li\u003e\n\u003cli\u003ea mapping-binding-pattern { f\u003csub\u003e1\u003c/sub\u003e: p\u003csub\u003e1\u003c/sub\u003e, f\u003csub\u003e2\u003c/sub\u003e:\np\u003csub\u003e2\u003c/sub\u003e, ..., f\u003csub\u003en\u003c/sub\u003e: p\u003csub\u003en\u003c/sub\u003e, r } matches a mapping value m\nthat includes fields f\u003csub\u003e1\u003c/sub\u003e, f\u003csub\u003e2\u003c/sub\u003e, ... , f\u003csub\u003en\u003c/sub\u003e if\np\u003csub\u003ei\u003c/sub\u003e matches the value of field f\u003csub\u003ei\u003c/sub\u003e for each i in 1 to n; if\nr is \u003ccode\u003e...v\u003c/code\u003e then a successful match causes a new mapping value\nconsisting of all the other fields to be assigned to \u003ccode\u003ev\u003c/code\u003e; a\nfield-binding-pattern consisting of just a variable-name \u003ccode\u003ex\u003c/code\u003e is\nequivalent to a field-binding-pattern \u003ccode\u003ex: x\u003c/code\u003e;\n\u003c/li\u003e\n\u003cli\u003ean error-binding-pattern error(p\u003csub\u003er\u003c/sub\u003e, f\u003csub\u003e1\u003c/sub\u003e = p\u003csub\u003e1\u003c/sub\u003e,\nf\u003csub\u003e2\u003c/sub\u003e = p\u003csub\u003e2\u003c/sub\u003e, ..., f\u003csub\u003en\u003c/sub\u003e = p\u003csub\u003en\u003c/sub\u003e, r) matches an\nerror value if it has an error reason string that matches p\u003csub\u003er\u003c/sub\u003e and a\ndetail record that has fields f\u003csub\u003e1\u003c/sub\u003e, f\u003csub\u003e2\u003c/sub\u003e, ... , f\u003csub\u003en\u003c/sub\u003e such\nthat p\u003csub\u003ei\u003c/sub\u003e matches the value of field f\u003csub\u003ei\u003c/sub\u003e for each i in 1 to\nn; if r is \u003ccode\u003e...v\u003c/code\u003e then a successful match causes a new mapping value\nconsisting of all fields other than f\u003csub\u003e1\u003c/sub\u003e, f\u003csub\u003e2\u003c/sub\u003e, ... ,\nf\u003csub\u003en\u003c/sub\u003e to be assigned to \u003ccode\u003ev\u003c/code\u003e;\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nAll the variables in a binding-pattern must be distinct e.g. (x, x) is not\nallowed.\n\u003c/p\u003e\n\u003cp\u003e\nGiven a type descriptor for every variable in a binding-pattern, there is a type\ndescriptor for the binding-pattern that will contain a value just in case that\nthe binding pattern successfully matches the value causing each variable to be\nassigned a value belonging to the type descriptor for that variable.\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003efor a capture-binding-pattern, the type descriptor is the type descriptor\nfor that variable;\u003c/li\u003e\n\u003cli\u003efor a wildcard-binding-pattern, the type descriptor is any\u003c/li\u003e\n\u003cli\u003efor a list-binding-pattern, the type descriptor is a tuple type descriptor;\u003c/li\u003e\n\u003cli\u003efor a mapping-binding-pattern, the type descriptor is a record type\ndescriptor;\u003c/li\u003e\n\u003cli\u003efor an error-binding-pattern, the type descriptor is an error type\ndescriptor.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4\u003eTyped binding patterns\u003c/h4\u003e\n\n\u003cpre\nclass=\"grammar\"\u003etyped-binding-pattern := inferable-type-descriptor binding-pattern\ninferable-type-descriptor := type-descriptor | \u003ccode\u003evar\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nA typed-binding-pattern combines a type-descriptor and a binding-pattern, and is\nused to create the variables occurring in the binding-pattern. If var is used\ninstead of a type-descriptor, it means the type is inferred. How the type is\ninferred depends on the context of the typed-binding-pattern. An\ninferable-type-descriptor is an inferable context for a type descriptor, which\nmeans that \u003ccode\u003e*\u003c/code\u003e can be used with the type descriptor to infer certain\nparts of it.\n\u003c/p\u003e\n\u003cp\u003e\nThe simplest and most common form of a typed-binding-pattern is for the binding\npattern to consist of just a variable name. In this case, the variable is\nconstrained to contain only values matching the type descriptor.\n\u003c/p\u003e\n\u003cp\u003e\nWhen the binding pattern is more complicated, the binding pattern must be\nconsistent with the type-descriptor, so that the type-descriptor unambiguously\ndetermines a type for each variable occurring in the binding pattern. A binding\npattern occurring in a typed-binding-pattern must also be irrefutable with\nrespect to the type of value against which it is to be matched. In other words,\nthe compiler will ensure that matching such a binding pattern against a value\nwill never fail at runtime.\n\u003c/p\u003e\n\u003ch4\u003eVariable scoping\u003c/h4\u003e\n\u003cp\u003e\nFor every variable, there is place in the program that creates it. Variables are\nlexically scoped: every variable has a scope which determines the region of the\nprogram within which the variable can be referenced.\n\u003c/p\u003e\n\u003cp\u003e\nThere are two kinds of scope: module scope and block scope. A variable with\nmodule scope can be referenced anywhere within a module. Identifiers with module\nscope are used to identify not only variables but other module-level entities\nsuch as functions.\n\u003c/p\u003e\n\u003cp\u003e\nA variable with block scope can be referenced only within a particular block\n(always delimited with curly braces). Block-scope variables are created by a\nvariety of different constructs, many of which use a typed-binding-pattern.\nParameters are treated as read-only variables with block scope.\n\u003c/p\u003e\n\u003cp\u003e\nA variable with block scope can have the same name as a variable with module\nscope; the former variable will hide the latter variable while the former\nvariable is in scope. However, it is a compile error if a variable with block\nscope has the same name as another variable with block scope and the two scopes\noverlap.\n\u003c/p\u003e\n\u003ch2 id=\"expressions\"\u003e6. Expressions\u003c/h2\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eexpression := \n   literal\n   | list-constructor-expr\n   | mapping-constructor-expr\n   | table-constructor-expr\n   | service-constructor-expr\n   | string-template-expr\n   | xml-expr\n   | new-expr\n   | variable-reference-expr\n   | field-access-expr\n   | annot-access-expr\n   | index-expr\n   | xml-attributes-expr\n   | function-call-expr\n   | method-call-expr\n   | error-constructor-expr\n   | anonymous-function-expr\n   | arrow-function-expr\n   | type-cast-expr\n   | typeof-expr\n   | unary-expr\n   | multiplicative-expr\n   | additive-expr\n   | shift-expr\n   | range-expr\n   | numeric-comparison-expr\n   | is-expr\n   | equality-expr\n   | binary-bitwise-expr\n   | logical-expr\n   | conditional-expr\n   | check-expr\n   | trap-expr\n   | table-query-expr\n   | \u003ccode\u003e(\u003c/code\u003e expression \u003ccode\u003e)\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nFor simplicity, the expression grammar is ambiguous. The following table shows\nthe various types of expression in decreasing order of precedence, together with\nassociativity.\n\u003c/p\u003e\n\u003ctable\u003e\n  \u003ctr\u003e\n   \u003ctd\u003e\u003cstrong\u003eOperator\u003c/strong\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003cstrong\u003eAssociativity\u003c/strong\u003e\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003e\n\u003ccode\u003ex.k\u003c/code\u003e\n\u003cbr /\u003e\n\u003ccode\u003ex.@a\u003c/code\u003e\n\u003cbr /\u003e\n\u003ccode\u003ef(x)\u003c/code\u003e\n\u003cbr /\u003e\n\u003ccode\u003ex.f(y)\u003c/code\u003e\n\u003cbr /\u003e\n\u003ccode\u003ex[y]\u003c/code\u003e\n\u003cbr /\u003e\n\u003ccode\u003enew T(x)\u003c/code\u003e\n   \u003c/td\u003e\n   \u003ctd\u003e\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003e\n\u003ccode\u003e+x\u003c/code\u003e\n\u003cbr /\u003e\n\u003ccode\u003e-x\u003c/code\u003e\n\u003cbr /\u003e\n\u003ccode\u003e~x\u003c/code\u003e\n\u003cbr /\u003e\n\u003ccode\u003e!x\u003c/code\u003e\n\u003cbr /\u003e\n\u003ccode\u003e\u0026lt;T\u003e x\u003c/code\u003e\n\u003cbr /\u003e\n\u003ccode\u003etypeof x\u003c/code\u003e\n   \u003c/td\u003e\n   \u003ctd\u003e\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003e\n\u003ccode\u003ex * y\u003c/code\u003e\n\u003cbr /\u003e\n\u003ccode\u003ex / y\u003c/code\u003e\n\u003cbr /\u003e\n\u003ccode\u003ex % y\u003c/code\u003e\n   \u003c/td\u003e\n   \u003ctd\u003eleft\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003e\u003ccode\u003ex + y\u003c/code\u003e\n\u003cbr /\u003e\n\u003ccode\u003ex - y\u003c/code\u003e\n   \u003c/td\u003e\n   \u003ctd\u003eleft\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003e\n\u003ccode\u003ex \u0026lt;\u0026lt; y\u003c/code\u003e\n\u003cbr /\u003e\n\u003ccode\u003ex \u003e\u003e y\u003c/code\u003e\n\u003cbr /\u003e\n\u003ccode\u003e\u003e\u003e\u003e\u003c/code\u003e\n   \u003c/td\u003e\n   \u003ctd\u003eleft\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003e\n\u003ccode\u003ex ... y\u003c/code\u003e\n\u003cbr /\u003e\n\u003ccode\u003ex ..\u0026lt; y\u003c/code\u003e\n   \u003c/td\u003e\n   \u003ctd\u003enon\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003e\n\u003ccode\u003ex \u0026lt; y\u003c/code\u003e\n\u003cbr /\u003e\n\u003ccode\u003ex \u003e y\u003c/code\u003e\n\u003cbr /\u003e\n\u003ccode\u003ex \u0026lt;= y\u003c/code\u003e\n\u003cbr /\u003e\n\u003ccode\u003ex \u003e= y\u003c/code\u003e\n\u003cbr /\u003e\n\u003ccode\u003ex is y\u003c/code\u003e\n   \u003c/td\u003e\n   \u003ctd\u003enon\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003e\n\u003ccode\u003ex == y\u003c/code\u003e\n\u003cbr /\u003e\n\u003ccode\u003ex != y\u003c/code\u003e\n\u003cbr /\u003e\n\u003ccode\u003ex === y\u003c/code\u003e\n\u003cbr /\u003e\n\u003ccode\u003ex !== y\u003c/code\u003e\n   \u003c/td\u003e\n   \u003ctd\u003eleft\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003e\u003ccode\u003ex \u0026amp; y\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003eleft\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003e\u003ccode\u003ex ^ y\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003eleft\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003e\u003ccode\u003ex | y\u003c/code\u003e\n   \u003c/td\u003e\n   \u003ctd\u003eleft\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003e\u003ccode\u003ex \u0026amp;\u0026amp; y\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003eleft\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003e\u003ccode\u003ex || y\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003eleft\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003e\u003ccode\u003ex ?: y\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003eright\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003e\u003ccode\u003ex ? y : z\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003eright\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003e\u003ccode\u003e(x) =\u003e y\u003c/code\u003e\u003c/td\u003e\n   \u003ctd\u003eright\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003ch3\u003eExpression evaluation\u003c/h3\u003e\n\u003cp\u003e\nWhen the evaluation of an expression completes normally, it produces a result,\nwhich is a value. The evaluation of an expression may also complete abruptly.\nThere are two kinds of abrupt completion: check-fail and panic. With both kinds\nof abrupt completion there is an associated value, which always has basic type\nerror.\n\u003c/p\u003e\n\u003cp\u003e\nThe following sections describes how each kind expression is evaluated, assuming\nthat evaluation of subexpressions complete normally. Except where explicitly\nstated to the contrary, expressions handle abrupt completion of subexpressions\nas follows. If in the course of evaluating an expression E, the evaluation of\nsome subexpression E1 completes abruptly, then then evaluation of E also\ncompletes abruptly in the same way as E1.\n\u003c/p\u003e\n\u003ch3\u003eStatic typing of expressions\u003c/h3\u003e\n\u003cp\u003e\nA type is computed for every expression at compile type; this is called the\nstatic type of the expression. The compiler and runtime together guarantee that\nif the evaluation of an expression at runtime completes normally, then the\nresulting value will belong to the static type. A type is also computed for\ncheck-fail abrupt completion, which will be a (possibly empty) subtype of error;\nhowever, for panic abrupt completion, no type is computed.\n\u003c/p\u003e\n\u003cp\u003e\nThe detailed rules for the static typing of expressions are quite elaborate and\nare not specified completely in this document. This document only mentions some\nkey points that programmers might need to be aware of.\n\u003c/p\u003e\n\u003ch4\u003eContextually expected type\u003c/h4\u003e\n\u003cp\u003e\nFor a context in which an expression occurs, there may be a type descriptor that\ndescribes the static type that the expression is expected to have. This is\ncalled the \u003cem\u003econtextually expected type\u003c/em\u003e. For example, if a variable is\ndeclared by a type descriptor TD, then TD will be the contextually expected type\nfor the expression initializing the variable. A type descriptor must be\nresolved before it can be used to provide a contextually expected type.\u003c/p\u003e\n\u003cp\u003e\nMany kinds of expression that construct values use the contextually expected\ntype to determine the type of value constructed, rather than requiring the type\nto be specified explicitly. For each such kind of expression, there is a set of\nbasic types (most often consisting of a single basic type) that the value\nconstructed by that kind of expression will always belong to. In this case, the\ncontextually expected type is narrowed by intersecting it with this set of basic\ntypes; this narrowed type is called the \u003cem\u003eapplicable\u003c/em\u003e contextually\nexpected type. The narrowing is performed on the type descriptor by first\nnormalizing the type descriptor into a union, where each member of the union is\nnot a union and describes shapes from a single basic type, and then eliminating\nany members of the union with the wrong basic type; if this leaves no members,\nthen it is a compile-time error; if it leaves a single member of the union, then\nthe the applicable contextually expected type is this single member, otherwise\nit is a union of the remaining members.\n\u003c/p\u003e\n\u003cp\u003e\nNote the language provides a way to say that the type of a variable is to be\ninferred from the static type of the expression used to initialize the variable.\nIn this case, there is no contextually expected type for the evaluation of the\nexpression. Not having a contextually expected type is different from having a\ncontextually expected type that allows all values.\n\u003c/p\u003e\n\u003ch4\u003ePrecise and broad types\u003c/h4\u003e\n\u003cp\u003e\nThere is an additional complexity relating to inferring types. Expressions in\nfact have two static types, a precise type and a broad type. Usually, the\nprecise type is used. However, in a few situations, using the precise type would\nbe inconvenient, and so Ballerina uses the broad type. In particular, the broad\ntype is used for inferring the type of an implicitly typed non-final variable.\nSimilarly, the broad type is used when it is necessary to infer the member type\nof the inherent type of a container.\n\u003c/p\u003e\n\u003cp\u003e\nIn most cases, the precise type and the broad type of an expression are the\nsame. For a compound expression, the broad type of an expression is computed\nfrom the broad type of the sub-expressions in the same way as the precise type\nof the expression is computed from the precise type of sub-expressions.\nTherefore in most cases, there is no need to mention the distinction between\nprecise and broad types.\n\u003c/p\u003e\n\u003cp\u003e\nThe most important case where the precise type and the broad type are different\nis literals. The precise type is a singleton type containing just the shape of\nthe value that the literal represents, whereas the broad type is the precise\ntype widened to contain the entire basic type of which it is a subtype. For\nexample, the precise type of the string literal \u003ccode\u003e\"X\"\u003c/code\u003e is the\nsingleton type \u003ccode\u003e\"X\"\u003c/code\u003e, but the broad type is \u003ccode\u003estring\u003c/code\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nFor a type-cast-expr, the precise type and the broad type are the type\nspecified in the cast.\n\u003c/p\u003e\n\u003ch3\u003eCasting and conversion\u003c/h3\u003e\n\u003cp\u003e\nBallerina makes a sharp distinction between type conversion and type casting.\n\u003c/p\u003e\n\u003cp\u003e\nCasting a value does not change the value. Any value always belongs to multiple\ntypes. Casting means taking a value that is statically known to be of one type,\nand using it in a context that requires another type; casting checks that the\nvalue is of that other type, but does not change the value.\n\u003c/p\u003e\n\u003cp\u003e\nConversion is a process that takes as input a value of one type and produces as\noutput a possibly distinct value of another type. Note that conversion does not\nmutate the input value.\n\u003c/p\u003e\n\u003cp\u003e\nBallerina always requires programmers to make conversions explicit, even between\ndifferent types of number; there are no implicit conversions.\n\u003c/p\u003e\n\u003ch3\u003eConstant expressions\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003econst-expr := \n   literal\n   | list-constructor-expr\n   | mapping-constructor-expr\n   | table-constructor-expr\n   | string-template-expr\n   | xml-expr\n   | constant-reference-expr\n   | type-cast-expr\n   | unary-expr\n   | multiplicative-expr\n   | additive-expr\n   | shift-expr\n   | range-expr\n   | numeric-comparison-expr\n   | is-expr\n   | equality-expr\n   | binary-bitwise-expr\n   | logical-expr\n   | conditional-expr\n   | \u003ccode\u003e(\u003c/code\u003e const-expr \u003ccode\u003e)\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nWithin a \u003ccode\u003econst-expr\u003c/code\u003e, any nested expression must also be a\nconst-expr.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003econstant-reference-expr := variable-reference-expr\n\u003c/pre\u003e\n\u003cp\u003e\nA \u003ccode\u003econstant-reference-expr\u003c/code\u003e must reference a constant defined with\n\u003ccode\u003emodule-const-decl\u003c/code\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nA \u003ccode\u003econst-expr\u003c/code\u003e is evaluated at compile-time. The result of a\n\u003ccode\u003econst-expr\u003c/code\u003e is automatically frozen. Note that the syntax of\nconst-expr does not allow for the construction of error values.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003esimple-const-expr :=\n  nil-literal\n  | boolean\n  | [Sign] int-literal\n  | [Sign] floating-point-literal\n  | string-literal\n  | const-reference-expr\n\u003c/pre\u003e\n\u003cp\u003e\nA simple-const-expr is a restricted form of const-expr used in contexts where\nvarious forms of constructor expression would not make sense. Its semantics are\nthe same as a const-expr.\n\u003c/p\u003e\n\u003ch3\u003eLiterals\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eliteral :=\n   nil-literal\n   | boolean-literal\n   | numeric-literal\n   | string-literal\n   | byte-array-literal\nnumeric-literal := int-literal | floating-point-literal\n\u003c/pre\u003e\n\u003cp\u003e\nA numeric-literal represents a value belonging to one of the basic types\nint, float or decimal. The basic type to which the value belongs is determined\nas follows:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eif the numeric-literal includes a \u003ccode\u003eFloatTypeSuffix\u003c/code\u003e, then the\nbasic type is float;\u003c/li\u003e\n\u003cli\u003eif the numeric-literal includes a \u003ccode\u003eDecimalTypeSuffix\u003c/code\u003e, then the\nbasic type is decimal;\u003c/li\u003e\n\u003cli\u003eif the numeric-literal is a \u003ccode\u003eHexFloatingPointLiteral\u003c/code\u003e, then the\nbasic type is float;\u003c/li\u003e\n\u003cli\u003eotherwise, the basic type depends on the applicable expected numeric type\n(where the possible basic types are int, float and decimal):\n\u003cul\u003e\n\u003cli\u003eif the applicable contextually expected type is a subtype of decimal, then\nthe basic type is decimal;\u003c/li\u003e\n\u003cli\u003eif the applicable contextually expected type is a subtype of float, then the\nbasic type is float;\u003c/li\u003e\n\u003cli\u003eotherwise, if the numeric literal is an int-literal, then the basic type is\nint;\u003c/li\u003e\n\u003cli\u003eotherwise, the basic type is float.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nThe precise type of a numeric-literal is the singleton type containing just the\nshape of the value that the numeric-literal represents. The broad type is\nthe basic type of which the precise type is a subset.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003ebyte-array-literal := Base16Literal | Base64Literal\nBase16Literal := \u003ccode\u003ebase16\u003c/code\u003e WS \u003ccode\u003e`\u003c/code\u003e HexGroup* WS \u003ccode\u003e`\u003c/code\u003e\nHexGroup := WS HexDigit WS HexDigit\nBase64Literal := \u003ccode\u003ebase64\u003c/code\u003e WS \u003ccode\u003e`\u003c/code\u003e Base64Group* [PaddedBase64Group] WS \u003ccode\u003e`\u003c/code\u003e\nBase64Group :=\n   WS Base64Char WS Base64Char WS Base64Char WS Base64Char\nPaddedBase64Group :=\n   WS Base64Char WS Base64Char WS Base64Char WS PaddingChar\n   | WS Base64Char WS Base64Char WS PaddingChar WS PaddingChar\nBase64Char := \u003ccode\u003eA\u003c/code\u003e .. \u003ccode\u003eZ\u003c/code\u003e | \u003ccode\u003ea\u003c/code\u003e .. \u003ccode\u003ez\u003c/code\u003e | \u003ccode\u003e0\u003c/code\u003e .. \u003ccode\u003e9\u003c/code\u003e | \u003ccode\u003e+\u003c/code\u003e | \u003ccode\u003e/\u003c/code\u003e\nPaddingChar := \u003ccode\u003e=\u003c/code\u003e\nWS := WhiteSpaceChar*\n\u003c/pre\u003e\n\u003cp\u003e\nThe static type of byte-array-literal is \u003ccode\u003ebyte[N]\u003c/code\u003e, where N is the\nnumber of bytes encoded by the Base16Literal or Base64Literal. The inherent type\nof the array value created is also \u003ccode\u003ebyte[N]\u003c/code\u003e.\n\u003c/p\u003e\n\u003ch3\u003eList constructor\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003elist-constructor-expr := \u003ccode\u003e[\u003c/code\u003e [ expr-list ] \u003ccode\u003e]\u003c/code\u003e\nexpr-list = expression (\u003ccode\u003e,\u003c/code\u003e expression)*\n\u003c/pre\u003e\n\u003cp\u003e\nCreates a new list value. The members of the list come from evaluating each\nexpression in the expr-list in order.\n\u003c/p\u003e\n\u003cp\u003e\nThe inherent type of the newly created list is derived from the applicable\ncontextually expected type. It is an error if there is no contextually expected\ntype. If the applicable contextually expected type is a list type descriptor,\nthen that used as the inherent type. If the applicable contextually expected\ntype is a union type descriptor, then any members of the union that do not\ncontain list shapes of length N will be ignored, where N is the number of\nexpressions in the \u003ccode\u003eexpr-list\u003c/code\u003e; it is a compile-time error if this\ndoes not leave a single list type descriptor, which is then used as the inherent\ntype. The static type of the list-constructor-expr will be the same as the\ninherent type.\n\u003c/p\u003e\n\u003cp\u003e\nThe type that the inherent type requires for each list member provides the\ncontextually expected type for the expression for the member.\n\u003c/p\u003e\n\u003cp\u003e\nSome members of a list can be filled in automatically. A member can be filled in\nautomatically if its type descriptor, as determined by the inherent type of the\nlist, provides a way to create a \u003cem\u003efiller\u003c/em\u003e value. The following table\nspecifies the filler value for each kind of type descriptor that provides one.\n\u003c/p\u003e\n\u003ctable\u003e\n\u003ctr\u003e\n\u003cth\u003eType descriptor\u003c/th\u003e\n\u003cth\u003eFiller value\u003c/th\u003e\n\u003cth\u003eWhen provided\u003c/th\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eboolean\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003efalse\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eint\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e0\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003efloat\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e+0.0f\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003edecimal\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e+0.0d\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003estring\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e\"\"\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003elist type descriptor\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e[]\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eif that is a valid constructor for the type\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003emapping type descriptor\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e{ }\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eif that is a valid constructor for the type\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003etable\u003c/td\u003e\n\u003ctd\u003eempty table (with no rows)\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eobject\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003enew T()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eif this is valid and its static type does not include error, where\n\u003ccode\u003eT\u003c/code\u003e is the object type descriptor (an abstract object type will not\nhave a filler value)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003exml\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003exml``\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003estream\u0026lt;T\u0026gt;\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003enew stream\u0026lt;T\u0026gt;\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003esingleton\u003c/td\u003e\n\u003ctd\u003ethe single value used to specify the type\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd rowspan=\"2\"\u003eunion\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eif \u003ccode\u003e()\u003c/code\u003e is a member of the union\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ethe filler value for basic type B\u003c/td\u003e\n\u003ctd\u003eif all members of the union belong to a single basic type B,\nand the filler value for B also belongs to the union\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eT?\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eany\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eanydata\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ebyte\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e0\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ejson\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\n\u003cp\u003e\nThe inherent type of a list establishes either a fixed length for the list or\njust a minimum length for the list, which may be zero. In the latter case, for\neach \u003cvar\u003ej\u003c/var\u003e greater than \u003cvar\u003em\u003c/var\u003e, where \u003cvar\u003em\u003c/var\u003e is the minimum\nlength of the list, the inherent type of the list must be such that\n\u003cvar\u003ej\u003c/var\u003e-th member can be filled in automatically. In either case, a list\nconstructor may specify only the first \u003cvar\u003ek\u003c/var\u003e members, provided that for\neach \u003cvar\u003ei\u003c/var\u003e from \u003cvar\u003ek\u003c/var\u003e + 1 up to the fixed length of the list, the\n\u003cvar\u003ei\u003c/var\u003e-th member can be filled in automatically.\n\u003c/p\u003e\n\n\u003ch3\u003eMapping constructor\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003emapping-constructor-expr := \u003ccode\u003e{\u003c/code\u003e [field (\u003ccode\u003e,\u003c/code\u003e field)*] \u003ccode\u003e}\u003c/code\u003e\nfield := (literal-field-name | computed-field-name) \u003ccode\u003e:\u003c/code\u003e value-expr\nliteral-field-name := field-name | string-literal\ncomputed-field-name := \u003ccode\u003e[\u003c/code\u003e expression \u003ccode\u003e]\u003c/code\u003e\nvalue-expr := expression\n\u003c/pre\u003e\n\u003cp\u003e\nA mapping-constructor-expr creates a new mapping value. An expression can be\nused to specify the name of a field by enclosing the expression in square\nbrackets.\n\u003c/p\u003e\n\u003cp\u003e\nThe inherent type of the newly created mapping is derived from the applicable\ncontextually expected type. It is an error if there is no contextually expected\ntype. If the applicable contextually expected type is a mapping type descriptor,\nthen that used as the inherent type. If the applicable contextually expected\ntype is a union type descriptor, then any members of the union that are\ninconsistent with the field names specified as a literal-field-name in the\nmapping-constructor-expr will be ignored; it is a compile-time error if this\ndoes not leave a single mapping type descriptor, which is then used as the\ninherent type. The static type of the mapping-constructor-expr will be the same\nas the inherent type.\n\u003c/p\u003e\n\u003cp\u003e\nIf the inherent type descriptor is a record type descriptor, a field will be\nadded to the constructed value using the default value from the type descriptor\nfor any field that is not specified explicitly in the mapping constructor and\nthat has a default value.\n\u003c/p\u003e\n\u003cp\u003e\nThe type that the inherent type requires for each field provides the\ncontextually expected type for the value-expr for that field. The contextually\nexpected type for a computed-field-name is string.\n\u003c/p\u003e\n\n\u003ch3\u003e[Preview] Table constructor\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003etable-constructor-expr :=\n   \u003ccode\u003etable\u003c/code\u003e \u003ccode\u003e{\u003c/code\u003e [column-descriptors [\u003ccode\u003e,\u003c/code\u003e table-rows]] \u003ccode\u003e}\u003c/code\u003e\ncolumn-descriptors := \u003ccode\u003e{\u003c/code\u003e column-descriptor (\u003ccode\u003e,\u003c/code\u003e column-descriptor)* \u003ccode\u003e}\u003c/code\u003e\ncolumn-descriptor := column-constraint* column-name\ncolumn-constraint :=\n   \u003ccode\u003ekey\u003c/code\u003e\n   | \u003ccode\u003eunique\u003c/code\u003e\n   | \u003ccode\u003eauto\u003c/code\u003e auto-kind \nauto-kind := auto-kind-increment\nauto-kind-increment := \u003ccode\u003eincrement\u003c/code\u003e [\u003ccode\u003e(\u003c/code\u003eseed\u003ccode\u003e,\u003c/code\u003e increment\u003ccode\u003e)\u003c/code\u003e]\nseed := integer\nincrement := integer\ntable-rows :=  \u003ccode\u003e[\u003c/code\u003e table-row (\u003ccode\u003e,\u003c/code\u003e table-row)* \u003ccode\u003e]\u003c/code\u003e\ntable-row := \u003ccode\u003e{\u003c/code\u003e expression (\u003ccode\u003e,\u003c/code\u003e expression)* \u003ccode\u003e}\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nThe contextually expected type of the table-constructor-expr determines the\ninherent type of the constructed value.\n\u003c/p\u003e\n\u003cp\u003e\nFor example,\n\u003c/p\u003e\n\n\u003cpre\u003etable {\n  { key firstName, key lastName, position },\n  [ \n    {\"Sanjiva\", \"Weerawarana\", \"lead\" },\n    {\"James\", \"Clark\", \"design co-lead\" }\n  ]\n}\n\u003c/pre\u003e\n\u003ch3\u003eService constructor\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eservice-constructor-expr := annots \u003ccode\u003eservice\u003c/code\u003e service-body-block\nservice-body-block := \u003ccode\u003e{\u003c/code\u003e service-method-defn* \u003ccode\u003e}\u003c/code\u003e\nservice-method-defn :=\n   metadata\n   service-method-defn-quals\n   function identifier function-signature method-body\nservice-method-defn-quals :=\n   [explicit-visibility-qual | \u003ccode\u003eresource\u003c/code\u003e]\n\u003c/pre\u003e\n\u003cp\u003e\nA \u003ccode\u003eservice-constructor-expr\u003c/code\u003e constructs a service value. The result\nof evaluating a service-constructor-expr is a value of type service. If a\nservice-method-defn contains a resource qualifier, then it defines a resource,\notherwise it defines a method. The self variable can be used in a method-body of\na service-method-defn in the same way as for objects.\n\u003c/p\u003e\n\u003cp\u003e\nEach service value has a distinct type descriptor. (Evaluating a service\nconstructor thus has an effect analogous to defining an anonymous object type\nand then creating a value of that type.)\n\u003c/p\u003e\n\u003cp\u003e\nThe return type of a resource must be a subtype of \u003ccode\u003eerror?\u003c/code\u003e and must contain\nnil.\n\u003c/p\u003e\n\u003ch3\u003eString template expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003estring-template-expr := \u003ccode\u003estring\u003c/code\u003e BacktickString\nBacktickString :=\n  \u003ccode\u003e`\u003c/code\u003e BacktickItem* Dollar* \u003ccode\u003e`\u003c/code\u003e\nBacktickItem :=\n   BacktickSafeChar\n   | BacktickDollarsSafeChar\n   | Dollar* interpolation\ninterpolation := \u003ccode\u003e${\u003c/code\u003e expression \u003ccode\u003e}\u003c/code\u003e\nBacktickSafeChar := ^ ( \u003ccode\u003e`\u003c/code\u003e | \u003ccode\u003e$\u003c/code\u003e )\nBacktickDollarsSafeChar :=  \u003ccode\u003e$\u003c/code\u003e+ ^ ( \u003ccode\u003e{\u003c/code\u003e | \u003ccode\u003e`\u003c/code\u003e | \u003ccode\u003e$\u003c/code\u003e)\nDollar := \u003ccode\u003e$\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nA \u003ccode\u003estring-template-expr\u003c/code\u003e interpolates the results of evaluating\nexpressions into a literal string. The static type of the expression in each\ninterpolation must be a simple type and must not be nil. Within a\n\u003ccode\u003eBacktickString\u003c/code\u003e, every character that is not part of an\n\u003ccode\u003einterpolation\u003c/code\u003e is interpreted as a literal character. A\nstring-template-expr is evaluated by evaluating the expression in each\ninterpolation in the order in which they occur, and converting the result of the\neach evaluation to a string as if using by \u003ccode\u003e\u0026lt;string\u003e\u003c/code\u003e. The result\nof evaluating the \u003ccode\u003estring-template-expr\u003c/code\u003e is a string comprising the\nliteral characters and the results of evaluating and converting the\ninterpolations, in the order in which they occur in the\n\u003ccode\u003eBacktickString\u003c/code\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nA literal \u003ccode\u003e`\u003c/code\u003e can be included in string template by using an\ninterpolation \u003ccode\u003e${\"`\"}\u003c/code\u003e.\n\u003c/p\u003e\n\u003ch3\u003eXML expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003exml-expr := \u003ccode\u003exml\u003c/code\u003e BacktickString\n\u003c/pre\u003e\n\u003cp\u003e\nAn XML expression creates an XML value as follows:\n\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe backtick string is parsed to produce a string of literal characters with\ninterpolated expressions\u003c/li\u003e\n\u003cli\u003eThe result of the previous step is parsed as XML content. More precisely, it\nis parsed using the production \u003ccode\u003econtent\u003c/code\u003e in the W3C XML\nRecommendation. For the purposes of parsing as XML, each interpolated expression\nis interpreted as if it were an additional character allowed by the CharData and\nAttValue productions but no other. The result of this step is an XML Infoset\nconsisting of an ordered list of information items such as could occur as the\n[children] property of an element information item, except that interpolated\nexpressions may occur as Character Information Item or in the [normalized value]\nof an Attribute Information Item. Interpolated expressions are not allowed in\nthe value of a namespace attribute.\u003c/li\u003e\n\u003cli\u003eThis infoset is then converted to an XML value, together with an ordered\nlist of interpolated expressions, and for each interpolated expression a\nposition within the XML value at which the value of the expression is to be\ninserted.\u003c/li\u003e\n\u003cli\u003eThe static type of an expression occurring in an attribute value must be a\nsimple type and must not be nil. The static type type of an expression occurring\nin content can either be xml or a non-nil simple type.\u003c/li\u003e\n\u003cli\u003eWhen the xml-expr is evaluated, the interpolated expressions are evaluated\nin the order in which they occur in the \u003ccode\u003eBacktickString\u003c/code\u003e, and\nconverted to strings if necessary. A new copy is made of the XML value and the\nresult of the expression evaluations are inserted into the corresponding\nposition in the newly created XML value. This XML value is the result of the\nevaluation.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003eNew expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003enew-expr := explicit-new-expr | implicit-new-expr\nexplicit-new-expr := new type-descriptor \u003ccode\u003e(\u003c/code\u003e arg-list \u003ccode\u003e)\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nA new-expr constructs a new object.\u003c/p\u003e\n\u003cp\u003e\nAn explicit-new-expr allocates storage for the object and initializes it,\npassing the supplied arg-list to the object's \u003ccode\u003e__init\u003c/code\u003e method. It is\na compile error if the type-descriptor does not specify an object type or if the\narg-list does not match the signature of the object type's \u003ccode\u003e__init\u003c/code\u003e\nmethod. If the result of calling the \u003ccode\u003e__init\u003c/code\u003e method is an error\nvalue e, then the result of evaluating the explicit-new-expr is e; otherwise the\nresult is the newly initialized object.\n\u003c/p\u003e\n\u003cp\u003e\nAn explicit-type-expr specifying a type descriptor T has static type T, except\nthat if the type of the \u003ccode\u003e__init\u003c/code\u003e method is E?, where E is a subtype\nof error, then it has static type T|E.\n\u003c/p\u003e\n\u003cpre\nclass=\"grammar\"\u003eimplicit-new-expr := new [\u003ccode\u003e(\u003c/code\u003e arg-list \u003ccode\u003e)\u003c/code\u003e]\n\u003c/pre\u003e\n\u003cp\u003e\nAn implicit-new-expr is equivalent to an explicit-new-expr that specifies the\napplicable contextually expected type as the type descriptor. An\nimplicit-new-expr consisting of just \u003ccode\u003enew\u003c/code\u003e is equivalent to\n\u003ccode\u003enew()\u003c/code\u003e.\n\u003c/p\u003e\n\u003ch3\u003eVariable reference expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003evariable-reference-expr := variable-reference\nvariable-reference := qualified-identifier\n\u003c/pre\u003e\n\u003cp\u003e\nA variable-reference can refer to a variable, a parameter, a constant (defined\nwith a module constant declaration) or a type (defined with a type definition).\n\u003c/p\u003e\n\u003cp\u003e\nIf the variable-reference references a type defined with a type definition, then\nthe result of evaluating the variable-reference-expr is a typedesc value for\nthat type.\n\u003c/p\u003e\n\u003ch3\u003eField access expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003efield-access-expr := expression \u003ccode\u003e.\u003c/code\u003e field-name\n\u003c/pre\u003e\n\u003cp\u003e\n{MISSING}\n\u003c/p\u003e\n\u003ch3\u003eAnnotation access expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eannot-access-expr := expression \u003ccode\u003e@.\u003c/code\u003e annot-tag-reference\n\u003c/pre\u003e\n\u003cp\u003e\nThe annot-tag-reference must refer to an annotation tag declared with an\nannotation declaration. The static type of expression must be a subtype of\n\u003ccode\u003etypedesc\u003c/code\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nAn \u003ccode\u003eannot-access-expr\u003c/code\u003e is evaluated by first evaluating\n\u003ccode\u003eexpression\u003c/code\u003e resulting in a typedesc value \u003cem\u003et\u003c/em\u003e. If \u003cem\u003et\u003c/em\u003e\nhas an annotation with the tag referenced by \u003ccode\u003eannot-tag-reference\u003c/code\u003e,\nthen the result of the \u003ccode\u003eannot-access-expr\u003c/code\u003e is the value of that\nannotation; otherwise, the result is nil.\n\u003c/p\u003e\n\u003cp\u003e\nThe static type of the \u003ccode\u003eannot-access-expr\u003c/code\u003e is T? where T is the type\nof the annotation tag.\n\u003c/p\u003e\n\u003ch3\u003eIndex expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eindex-expr := expression \u003ccode\u003e[\u003c/code\u003e expression \u003ccode\u003e]\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n{MISSING}\n\u003c/p\u003e\n\u003cp\u003e\nEvaluation of an index-expr that attempts to accessing a list with an out of\nbounds index will complete abruptly with a panic.\n\u003c/p\u003e\n\u003ch3\u003e[Preview] XML attributes expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003exml-attributes-expr := expression \u003ccode\u003e@\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nReturns the attributes map of a singleton xml value, or nil if the operand is\nnot a singleton xml value. The result type is \u003ccode\u003emap\u0026lt;string\u003e?\u003c/code\u003e.\n\u003c/p\u003e\n\u003ch3 id=\"function_call\"\u003eFunction call expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003efunction-call-expr := [\u003ccode\u003estart\u003c/code\u003e] function-reference \u003ccode\u003e(\u003c/code\u003e arg-list \u003ccode\u003e)\u003c/code\u003e\nfunction-reference := variable-reference\narg-list :=\n   positional-args [\u003ccode\u003e,\u003c/code\u003e other-args]\n   | [other-args]\npositional-args := positional-arg (\u003ccode\u003e,\u003c/code\u003e positional-arg)*\npositional-arg := expression\nother-args := named-args | rest-arg\nnamed-args := named-arg (\u003ccode\u003e,\u003c/code\u003e named-arg)*\nnamed-arg := arg-name \u003ccode\u003e=\u003c/code\u003e expression\narg-name := identifier\nrest-arg := \u003ccode\u003e...\u003c/code\u003e expression\n\u003c/pre\u003e\n\u003cp\u003e\nA function-call-expr is evaluated by constructing an argument list and passing\nthe argument list to the function referred to by the variable-name. If the\nfunction terminates normally, then the result of the function-call-expr is the\nreturn value of the function; otherwise the function-call-expr completes\nabruptly with a panic. The static type of the function-call-expr is the return\ntype of the function type.\n\u003c/p\u003e\n\u003cp\u003e\nHowever, if \u003ccode\u003estart\u003c/code\u003e is specified, then the called function is\nexecuted on a new strand, and the result of the \u003ccode\u003efunction-call-expr\u003c/code\u003e\nis a value of type future\u0026lt;T\u003e, where T is the return type of the function\ncalled.\n\u003c/p\u003e\n\u003cp\u003e\nThe variable-reference must refer to a variable with function type. The type\ndescriptor of that function type is used to construct an argument list from the\nspecified arg-list. Note that it is the type descriptor of the declared type of\nthe variable that is used for this purpose, rather than the runtime type\ndescriptor of the referenced function value.\n\u003c/p\u003e\n\u003cp\u003e\nThe expressions occurring in the arg-list are evaluated in the order in which\nthey occur in the arg-list. The result of evaluating each positional-arg is\nadded to the argument list in order. The contextually expected type for the\nexpression in the i-th positional-arg is the type of the i-th parameter.\n\u003c/p\u003e\n\u003cp\u003e\nIf there is a rest-arg, then it is evaluated. The result must be a list value.\nEach member of the list value is added to the argument in the order that it\noccurs. The static type of the list value must be such as to guarantee that the\nresulting argument list will conform to the function's declared param-list. The\nrest-arg is not restricted to supplying the part of the argument list that will\nbe bound to a rest-param, and its static type is not restricted to being an\narray type. If there is rest-arg, then no parameter defaults are added.\n\u003c/p\u003e\n\u003cp\u003e\nIf there is no rest-arg, then each non-rest parameter that was not supplied by\npositional argument is added in order from a named parameter, if there is one,\nand otherwise using the parameter default. The contextually expected type for\nthe expression specifying a named argument is the type declared for the\ncorresponding parameter. A default parameter is computed by calling the closure\nin the type descriptor, passing it the previous arguments in the argument list.\nIt is a compile-time error if there is a non-rest parameter for which there was\nno positional argument and no named argument and which is not defaultable. It is\nalso an error if there is a named argument for a parameter that was supplied by\na positional argument.\n\u003c/p\u003e\n\u003cp\u003e\nWhen a function to be called results from the evaluation of an expression that\nis not merely a variable reference, the function can be called either by first\nstoring the value of the expression in a variable or using the \u003ccode\u003ecall\u003c/code\u003e\nbuilt-in method on functions.\n\u003c/p\u003e\n\n\u003ch3\u003eMethod call expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003emethod-call-expr := [\u003ccode\u003estart\u003c/code\u003e] expression \u003ccode\u003e.\u003c/code\u003e method-name \u003ccode\u003e(\u003c/code\u003e arg-list \u003ccode\u003e)\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nThe basic type of the value that results from evaluating expression determines\nhow the method-name is used to lookup the method to call. If the basic type is\nservice or object, then the method is looked up in the object's methods;\notherwise, the method is looked up in the built-in methods of that basic type. A\nmethod-call-expr cannot be used to call a remote method; it can only be called\nby a remote-method-call-action. A method-call-expr cannot be used to invoke a\nresource.\n\u003c/p\u003e\n\u003cp\u003e\nIf \u003ccode\u003estart\u003c/code\u003e is specified, then the called method is executed on a new\nstrand, and the result of the \u003ccode\u003emethod-call-expr\u003c/code\u003e is a value of type\nfuture\u0026lt;T\u003e, where T is the return type of the method called.\n\u003c/p\u003e\n\u003ch3\u003eError constructor\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eerror-constructor-expr := \u003ccode\u003eerror\u003c/code\u003e \u003ccode\u003e(\u003c/code\u003e error-arg-list \u003ccode\u003e)\u003c/code\u003e\nerror-arg-list :=\n   positional-arg (\u003ccode\u003e,\u003c/code\u003e named-arg)*\n   | [named-arg (\u003ccode\u003e,\u003c/code\u003e named-arg)*]\n\u003c/pre\u003e\n\u003cp\u003e\nAn error-constructor-expr constructs a new error value. The positional-arg, if\npresent, specifies the error reason string. Each named-arg specifies a field of\nthe error detail mapping. The static type of positional-arg must be a subtype of\nstring; the static type of each named-arg must be a pure type. The stack trace\ndescribes the stack at the point where the error constructor was evaluated.\n\u003c/p\u003e\n\u003cp\u003e\nIf there is a contextually expected type and the type of the error reason of\nthe applicable contextually expected error type is a singleton string type, then\nthe positional-arg can be omitted and the error reason will be the single\nstring allowed by the type.\n\u003c/p\u003e\n\u003cp\u003e\nIf there is a contextually expected type and the applicable contextually\nexpected type is an error type (rather than a union) with detail type\n\u003cvar\u003ed\u003c/var\u003e, then the error detail mapping will also have a field for any\ndefaultable fields of \u003cvar\u003ed\u003c/var\u003e for which no named-arg was specified.\n\u003c/p\u003e\n\u003cp\u003e\nEvaluating the error-constructor-expr creates a new detail record. The result of\nevaluating each named-arg and every defaultable arg is cloned using the Clone\nabstract operation, then frozen using the Freeze abstract operation, before\nbeing added to the detail record. The detail record is itself frozen after all\nfields have been added.\n\u003c/p\u003e\n\n\u003ch3\u003eAnonymous function expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eanonymous-function-expr :=\n  annots \u003ccode\u003efunction\u003c/code\u003e function-signature function-body-block\n\u003c/pre\u003e\n\u003cp\u003e\nEvaluating an anonymous-function-expr creates a closure, whose basic type is\nfunction. If function-body-block refers to a block-scope variable defined\noutside of the function-body-block, the closure will capture a reference to that\nvariable; the captured reference will refer to the same storage as the original\nreference not a copy.\n\u003c/p\u003e\n\u003ch3\u003eArrow function expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003earrow-function-expr := arrow-param-list \u003ccode\u003e=\u003e\u003c/code\u003e expression\narrow-param-list :=\n   identifier\n   | \u003ccode\u003e(\u003c/code\u003e[identifier (\u003ccode\u003e,\u003c/code\u003e identifier)*]\u003ccode\u003e)\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nArrow functions provide a convenient alternative to anonymous function\nexpressions that can be used for many simple cases. An arrow function can only\nbe used in a context where a function type is expected. The types of the\nparameters are inferred from the expected function type. The scope of the\nparameters is \u003ccode\u003eexpression\u003c/code\u003e. The static type of the arrow function\nexpression will be a function type whose return type is the static type of\n\u003ccode\u003eexpression\u003c/code\u003e. If the contextually expected type for the\n\u003ccode\u003earrow-function-expr\u003c/code\u003e is a function type with return type T, then the\ncontextually expected type for \u003ccode\u003eexpression\u003c/code\u003e is T.\n\u003c/p\u003e\n\u003ch3\u003eType cast expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003etype-cast-expr := \u003ccode\u003e\u0026lt;\u003c/code\u003e type-descriptor \u003ccode\u003e\u003e\u003c/code\u003e expression\n\u003c/pre\u003e\n\u003cp\u003e\nA \u003ccode\u003etype-cast-expr\u003c/code\u003e casts the value resulting from evaluating\n\u003ccode\u003eexpression\u003c/code\u003e to the type described by the type-descriptor, performing\na numeric conversion if required.\n\u003c/p\u003e\n\u003cp\u003e\nA type-cast-expr is evaluated by first evaluating \u003ccode\u003eexpression\u003c/code\u003e\nresulting in a value v. Let T be the type described by\n\u003ccode\u003etype-descriptor\u003c/code\u003e. If v belongs T, then the result of the\ntype-cast-expr is v. Otherwise, if T includes shapes from exactly one basic\nnumeric type N and v is belongs to another basic numeric type, then let n be\nNumericConvert(N, v); if n is not an error and n belongs to T, then the result\nof the type-cast-expr is n. Otherwise, the evaluation of the type-cast-expr\ncompletes abruptly with a panic.\n\u003c/p\u003e\n\u003cp\u003e\nLet T be the static type described by \u003ccode\u003etype-descriptor\u003c/code\u003e, and let TE\nbe the static type of \u003ccode\u003eexpression\u003c/code\u003e. Then the static type of the\n\u003ccode\u003etype-cast-expr\u003c/code\u003e is the intersection of T and TE', where TE' is TE\nwith its numeric shapes transformed to take account to the possibility of the\nnumeric conversion specified in the previous paragraph.\n\u003c/p\u003e\n\u003cp\u003e\nThe \u003ccode\u003etype-descriptor\u003c/code\u003e provides the contextually expected type for\n\u003ccode\u003eexpression\u003c/code\u003e.\n\u003c/p\u003e\n\u003ch3\u003eTypeof expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003etypeof-expr := \u003ccode\u003etypeof\u003c/code\u003e expression\n\u003c/pre\u003e\n\u003cp\u003e\nThe result of a \u003ccode\u003etypeof-expr\u003c/code\u003e is a typedesc value for the runtime\ntype of v, where v is the result of evaluating \u003ccode\u003eexpression\u003c/code\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nThe runtime type of v is the narrowest type to which v belongs.\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWhen v is a simple value, the resulting typedesc will describe a type\nconsisting of a single shape, which is the shape of the value. The typedesc will\nnot have any annotations. Each evaluation of \u003ccode\u003etypeof\u003c/code\u003e with a simple\nvalue produces a new typedesc value.\u003c/li\u003e\n\u003cli\u003eWhen v is a reference value, each evaluation of \u003ccode\u003etypeof\u003c/code\u003e with an\nidentical reference value produces an identical typedesc value. The type\ndescriptor resulting from \u003ccode\u003etypeof\u003c/code\u003e will be identical to the type\ndescriptor used to construct the value. For containers, this is the same as the\ninherent type, except in the case where the inherent type of a structured value\nhas been changed by freeze or stamp methods. For behavioural values, this is the\nsame as the type descriptor used with new. Any annotations that were attached to\nthe type descriptor used to construct the value will this be available on the\nconstructed value.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nThe static type of \u003ccode\u003etypeof-expr\u003c/code\u003e is typedesc\u0026lt;T\u003e, where T is the\nstatic type of \u003ccode\u003eexpression\u003c/code\u003e.\n\u003c/p\u003e\n\u003ch3\u003eUnary expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eunary-expr :=\n   \u003ccode\u003e+\u003c/code\u003e expression\n   | \u003ccode\u003e-\u003c/code\u003e expression\n   | \u003ccode\u003e~\u003c/code\u003e expression\n   | \u003ccode\u003e!\u003c/code\u003e expression\n\n\u003c/pre\u003e\n\u003cp\u003e\nThe unary \u003ccode\u003e-\u003c/code\u003e operator performs negation. The static type of the\noperand must be a number; the static type of the result is the same basic type\nas the static type of the operand. The semantics for each basic type are as\nfollows:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eint: negation for int is the same as subtraction from zero; an exception is\nthrown on overflow, which happens when the operand is -2\u003csup\u003e63\u003c/sup\u003e\u003c/li\u003e\n\u003cli\u003efloat, decimal: negation for floating point types corresponds to the negate\noperation as defined by IEEE 754-2008 (this is not the same as subtraction from\nzero); no exceptions are thrown\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nThe unary + operator returns the value of its operand expression. The static\ntype of the operand must be a number, and the static type of the result is the\nsame as the static type of the operand expression.\n\u003c/p\u003e\n\u003cp\u003e\nThe ~ operator inverts the bits of its operand expression. The static type of\nthe operand must be int, and the static type of the result is an int.\n\u003c/p\u003e\n\u003cp\u003e\nThe \u003ccode\u003e!\u003c/code\u003e operator performs logical negation. The static type of the\noperand expression must be boolean. The \u003ccode\u003e!\u003c/code\u003e operator returns true if\nits operand is false and false if its operand is true.\n\u003c/p\u003e\n\u003ch3\u003eMultiplicative expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003emultiplicative-expr :=\n   expression \u003ccode\u003e*\u003c/code\u003e expression\n   | expression \u003ccode\u003e/\u003c/code\u003e expression\n   | expression \u003ccode\u003e%\u003c/code\u003e expression\n\u003c/pre\u003e\n\u003cp\u003e\nThe \u003ccode\u003e*\u003c/code\u003e operator performs multiplication; the \u003ccode\u003e/\u003c/code\u003e operator\nperforms division; the \u003ccode\u003e%\u003c/code\u003e operator performs remainder.\n\u003c/p\u003e\n\u003cp\u003e\nThe static type of both operand expressions is required to be the same basic\ntype; this basic type will be the static type of the result. The following basic\ntypes are allowed:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eint\n\u003cul\u003e\n\u003cli\u003e* performs integer multiplication; an exception will be thrown on overflow\u003c/li\u003e\n\u003cli\u003e/ performs integer division, with any fractional part discarded ie with\ntruncation towards zero; an exception will be thrown on division by zero or on\noverflow (which happens if the first operand is -2\u003csup\u003e63\u003c/sup\u003e and the second\noperand is -1)\u003c/li\u003e\n\u003cli\u003e% performs integer remainder consistent with integer division, so that if\nx/y does not throw an exception, then (x/y)*y + (x%y) is equal to x; an\nexception will be thrown if the second operand is zero; if the first operand is\n-2\u003csup\u003e63\u003c/sup\u003e and the second operand is -1, then the result is 0\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003efloat, decimal\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e*\u003c/code\u003e performs the multiplication operation with the destination\nformat being the same as the source format, as defined by IEEE 754-2008; no\nexceptions are thrown\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e/\u003c/code\u003e performs the division operation with the destination format\nbeing the same as the source format, as defined by IEEE 754-2008; no exceptions\nare thrown\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e%\u003c/code\u003e performs a remainder operation; the remainder is not the\nIEEE-defined remainder operation but is instead a remainder operation analogous\nto integer remainder; more precisely,\n\u003cul\u003e\n\u003cli\u003eif x is NaN or y is NaN or x is an infinity or y is a zero, then x % y is\nNaN\u003c/li\u003e\n\u003cli\u003efor finite x, and infinite y, x % y is x\u003c/li\u003e\n\u003cli\u003efor finite x and finite non-zero y, x % y is equal to the result of rounding\nx - (y × n)  to the nearest representable value using the roundTiesToEven\nrounding mode, where n is the integer that is nearest to the mathematical\nquotient of x and y without exceeding it in magnitude; if the result is zero,\nthen its sign is that of x\u003c/li\u003e\n\u003cli\u003eno exceptions are thrown\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eAdditive expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eadditive-expr :=\n   expression \u003ccode\u003e+\u003c/code\u003e expression\n   | expression \u003ccode\u003e-\u003c/code\u003e expression\n\u003c/pre\u003e\n\u003cp\u003e\nThe \u003ccode\u003e+\u003c/code\u003e operator is used for both addition and concatenation; the\n\u003ccode\u003e-\u003c/code\u003e operator is used for subtraction.\n\u003c/p\u003e\n\u003cp\u003e\nIt is required that either\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ethe static type of both operand expressions is the same basic type, in which\ncase this basic type will be the static type of the result, or\u003c/li\u003e\n\u003cli\u003ethe static type of one operand expression must be xml and of the other\noperand expression must be string, in which case the static type of the result\nis xml\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nThe semantics for each basic type is as follows:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eint\n\u003cul\u003e\n\u003cli\u003e+ performs integer addition; an exception will be thrown on overflow\u003c/li\u003e\n\u003cli\u003e- peforns integer subtraction; an exception will be thrown on overflow\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003efloat, decimal\n\u003cul\u003e\n\u003cli\u003e+ performs the addition operation with the destination format being the same\nas the source format, as defined by IEEE 754-2008; no exceptions are thrown\u003c/li\u003e\n\u003cli\u003e - performs the subtraction operation with the destination format being the\nsame as the source format, as defined by IEEE 754-2008; no exceptions are thrown\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003estring, xml\n\u003cul\u003e\n\u003cli\u003eif both operands are a string, then the result is a string that is the\nconcatenation of the operands\u003c/li\u003e\n\u003cli\u003eif both operands are xml, then the result is a new xml sequence that is the\nconcatenation of the operands; the new xml sequence contains a shallow copy of\nboth operands; this operation does not perform a copy of the content or\nattributes of any elements in sequence\u003c/li\u003e\n\u003cli\u003eif one operand is a string and one is xml, the string is treated as if it\nwere an xml sequence with one character item for each code point in the string\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eShift expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eshift-expr :=\n   expression \u003ccode\u003e\u0026lt;\u0026lt;\u003c/code\u003e expression\n   expression \u003ccode\u003e\u003e\u003e\u003c/code\u003e expression\n   expression \u003ccode\u003e\u003e\u003e\u003e\u003c/code\u003e expression\n\u003c/pre\u003e\n\u003cp\u003e\nA shift-expr performs a bitwise shift. Both operand expressions must have static\ntype that is a subtype of int. The left hand operand is the value to be shifted;\nthe right hand value is the shift amount; all except the bottom 6 bits of the\nshift amount are masked out (as if by x \u0026amp; 0x3F). Then a bitwise shift is\nperformed depending on the operator:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;\u0026lt;\u003c/code\u003e performs a left shift, the bits shifted in on the\nright are zero\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u003e\u003e\u003c/code\u003e performs  a signed right shift; the bits shifted in on the\nleft are the same as the most significant bit\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u003e\u003e\u003e\u003c/code\u003e performs a unsigned right shift, the bits shifted in on the\nleft are zero\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nIf the operator is \u003e\u003e or \u003e\u003e\u003e and the left hand operand is a subtype of byte,\nthen the static type of the result is byte; otherwise the static type of the\nresult is int.\n\u003c/p\u003e\n\u003ch3\u003eRange expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003erange-expr :=\n   expression \u003ccode\u003e...\u003c/code\u003e expression\n   | expression \u003ccode\u003e..\u0026lt;\u003c/code\u003e expression\n\u003c/pre\u003e\n\u003cp\u003e\nA range-expr results in a new array of integers in increasing order including\nall integers n such that\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ethe value of the first expression is less than or equal to n, and\u003c/li\u003e\n\u003cli\u003en is\n\u003cul\u003e\n\u003cli\u003eif the operator is \u003ccode\u003e...\u003c/code\u003e, less than or equal to the value of the\nsecond expression\u003c/li\u003e\n\u003cli\u003eif the operator is \u003ccode\u003e..\u0026lt;\u003c/code\u003e, less than the value of the second\nexpression\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nIt is a compile error if the static type of either expression is not a subtype\nof int.\n\u003c/p\u003e\n\u003cp\u003e\nA range-expr is designed to be used in a foreach statement, but it can be used\nanywhere.\n\u003c/p\u003e\n\u003ch3\u003eNumerical comparison expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003enumerical-comparison-expr :=\n   expression \u003ccode\u003e\u0026lt;\u003c/code\u003e expression\n   | expression \u003ccode\u003e\u003e\u003c/code\u003e expression\n   | expression \u003ccode\u003e\u0026lt;=\u003c/code\u003e expression\n   | expression \u003ccode\u003e\u003e=\u003c/code\u003e expression\n\u003c/pre\u003e\n\u003cp\u003e\nA numerical-comparison-expr compares two numbers.\n\u003c/p\u003e\n\u003cp\u003e\nThe static type of both operands must be of the same basic type, which must be\nint, float or decimal. The static type of the result is boolean.\n\u003c/p\u003e\n\u003cp\u003e\nFloating point comparisons follow IEEE, 754-2008, so\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eif either operand is NaN, the result is false\u003c/li\u003e\n\u003cli\u003epositive and negative zero compare equal\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eType test expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eis-expr :=\n   expression \u003ccode\u003eis\u003c/code\u003e type-descriptor\n\u003c/pre\u003e\n\u003cp\u003e\nAn is-expr tests where a value belongs to a type.\n\u003c/p\u003e\n\u003cp\u003e\nAn is-expr is evaluated by evaluating the expression yielding a result v. If v\nbelongs to the type denoted by type-descriptor, then the result of the is-expr\nis true; otherwise the result of the is-expr is false.\n\u003c/p\u003e\n\u003ch3\u003eEquality expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eequality-expr :=\n   expression \u003ccode\u003e==\u003c/code\u003e expression\n   | expression \u003ccode\u003e!=\u003c/code\u003e expression\n   | expression \u003ccode\u003e===\u003c/code\u003e expression\n   | expression \u003ccode\u003e!==\u003c/code\u003e expression\n\u003c/pre\u003e\n\u003cp\u003e\nAn equality-expr tests whether two values are equal. For all four operators, it\nis a compile time error if the intersection of the static types of the operands\nis empty.\n\u003c/p\u003e\n\u003cp\u003e\nThe === operator tests for exact equality.  The !== operator results in the\nnegation of the result of the === operator.  Two values are exactly equal if\nthey have the same basic type T and\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eif T is simple type, the values are identical values within the set of\nvalues allowed for T\u003c/li\u003e\n\u003cli\u003eif T is a reference type, the values refer to the same storage\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nThe == operator tests for deep equality. The != operator results in the negation\nof the result of the == operator. For both == and !=, both operands must have a\nstatic type that is pure. Two values v1, v2 are deeply equal if SameShape(v1,\nv2) is true.\n\u003c/p\u003e\n\u003cp\u003e\nNote that === and == are the same for simple values except as regards floating\npoint zero: == treats positive and negative zero from the same basic type as\nequal whereas === treats them as unequal. Both == and === treat two NaN values\nfrom the same basic type as equal. This means that none of these operators\ncorrespond to operations defined by IEEE 754-2008, because they do not treat NaN\nin the special way defined for those operations.\n\u003c/p\u003e\n\u003ch3\u003eBinary bitwise expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003ebinary-bitwise-expr :=\n   bitwise-and-expr\n   | bitwise-xor-expr\n   | bitwise-or expr\nbitwise-and-expr = expression \u003ccode\u003e\u0026amp;\u003c/code\u003e expression\nbitwise-xor-expr = expression \u003ccode\u003e^\u003c/code\u003e expression\nbitwise-or-expr = expression \u003ccode\u003e|\u003c/code\u003e expression\n\u003c/pre\u003e\n\u003cp\u003e\nA binary-bitwise-expr does a bitwise AND, XOR, or OR operation on its operands.\n\u003c/p\u003e\n\u003cp\u003e\nThe static type of both operands must be a subtype of int.  The static type of\nthe result is as follows:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003efor AND, if the type of one operand is a subtype of byte, then the result\nhas type byte; otherwise, the result has type int;\u003c/li\u003e\n\u003cli\u003efor OR, if the type of both operands have a type that is a subtype of byte,\nthen the result has type byte; otherwise, the result has type int;\u003c/li\u003e\n\u003cli\u003efor XOR, the result has type int.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eLogical expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003elogical-expr :=\n   expression \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e expression\n   | expression \u003ccode\u003e||\u003c/code\u003e expression\n\u003c/pre\u003e\n\u003ch3\u003eConditional expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003econditional-expr :=\n   expression \u003ccode\u003e?\u003c/code\u003e expression \u003ccode\u003e:\u003c/code\u003e expression\n   | expression \u003ccode\u003e?:\u003c/code\u003e expression\n\u003c/pre\u003e\n\u003cp\u003e\nL \u003ccode\u003e?:\u003c/code\u003e R is evaluated as follows:\n\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eEvaluate L to get a value x\u003c/li\u003e\n\u003cli\u003eIf x is not nil, then return x.\u003c/li\u003e\n\u003cli\u003eOtherwise, return the result of evaluating R.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003eCheck expression\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003echeck-expression := \u003ccode\u003echeck\u003c/code\u003e expression\n\u003c/pre\u003e\n\u003cp\u003e\nEvaluates expression resulting in value v. If v has basic type error, then\ncheck-expression completes abruptly with a check-fail with associated value v.\nOtherwise evaluation completes normally with result v.\n\u003c/p\u003e\n\u003cp\u003e\nIf the static type of expression e is T|E, where E is a subtype of error, then\nthe static type of check e is T.\n\u003c/p\u003e\n\u003ch3\u003eTrap expression\u003c/h3\u003e\n\u003cp\u003e\nThe trap expression stops a panic and gives access to the error value associated\nwith the panic.\n\u003c/p\u003e\n\u003cpre\nclass=\"grammar\"\u003etrap-expr := \u003ccode\u003etrap\u003c/code\u003e expression\n\u003c/pre\u003e  \n\u003cp\u003e\nSemantics are:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eEvaluate \u003ccode\u003eexpression\u003c/code\u003e resulting in value v\n\u003cul\u003e\n\u003cli\u003eIf evaluation completes abruptly with panic with associated value e, then\nresult of trap-exp is e\u003c/li\u003e\n\u003cli\u003eOtherwise result of trap-expr  is v\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eIf type of \u003ccode\u003eexpr\u003c/code\u003e is T, then type of \u003ccode\u003etrap expr\u003c/code\u003e is\nT|error.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"actions_statements\"\u003e7. Actions and statements\u003c/h2\u003e\n\u003ch3\u003eActions\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eaction :=\n   remote-method-call-action\n   | worker-receive-action \n   | wait-action\n   | flush-action\n   | synchronous-send-action\n   | check-action\n   | trap-action\n   | \u003ccode\u003e(\u003c/code\u003e action \u003ccode\u003e)\u003c/code\u003e\naction-or-expr := action | expression\ncheck-action := \u003ccode\u003echeck\u003c/code\u003e action\ntrap-action := \u003ccode\u003etrap\u003c/code\u003e action\n\u003c/pre\u003e\n\u003cp\u003e\nActions are an intermediate syntactic category between expressions and\nstatements. Actions are similar to expressions, in that they yield a value.\nHowever, an action cannot be nested inside an expression; it can only occur as\npart of a statement or nested inside other actions. This is because actions are\nshown in the sequence diagram in the graphical syntax.\n\u003c/p\u003e\n\u003cp\u003e\nAn action is evaluated in the same way as an expression. Static typing for\nactions is the same as for expressions.\n\u003c/p\u003e\n\u003cp\u003e\nA \u003ccode\u003echeck-action\u003c/code\u003e and \u003ccode\u003etrap-actio\u003c/code\u003en is evaluated in the\nsame way as a \u003ccode\u003echeck-exp\u003c/code\u003er and \u003ccode\u003etrap-expr\u003c/code\u003e respectively.\n\u003c/p\u003e\n\u003ch3\u003eFunction and worker execution\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003efunction-body-block :=\n   \u003ccode\u003e{\u003c/code\u003e [default-worker-init, named-worker-decl+] default-worker \u003ccode\u003e}\u003c/code\u003e\ndefault-worker-init := sequence-stmt\ndefault-worker := sequence-stmt\nnamed-worker-decl :=\n   \u003ccode\u003eworker\u003c/code\u003e worker-name return-type-descriptor \u003ccode\u003e{\u003c/code\u003e sequence-stmt \u003ccode\u003e}\u003c/code\u003e\nworker-name := identifier\n\u003c/pre\u003e\n\u003cp\u003e\nA worker represents a thread of control running within a function. A statement\nis always executed in the context of a current worker. A worker is in one of\nthree states: running, suspended or terminated. When a worker is in the\nterminated state, it has a termination value. A worker terminates either\nnormally or abnormally. An abnormal termination results from a panic, and in\nthis case the termination value is always an error. If the termination value of\na normal termination is an error, then the worker is said to have terminated\nwith failure; otherwise the worker is said to have terminated with success. Note\nthat an error termination value resulting from a normal termination is\ndistinguished from an error termination value resulting from an abnormal\ntermination.\n\u003c/p\u003e\n\u003cp\u003e\nA function always has a single default worker, which is unnamed. When a function\nis called, the current worker is suspended, and a default worker for the called\nfunction is started. When the default worker terminates, the function returns to\nits caller, and the caller's worker is resumed. If the default worker terminates\nnormally, then its termination value provides the return value of the function.\nIf the default worker terminates abnormally, then the evaluation of the function\ncall expression completes abruptly with a panic and the default worker's\ntermination value provides the associated value for the abrupt completion of the\nfunction call. The function's return type is the same as the return type of the\nfunction's default worker.\n\u003c/p\u003e\n\u003cp\u003e\nThe default worker of a function and the worker that called the function belong\nto the same thread of control, which is called a \u003cem\u003estrand\u003c/em\u003e. Only one\nworker in a strand is running at any given time.\n\u003c/p\u003e\n\u003cp\u003e\nA function also has zero or more named workers. Each named worker runs on its\nown new strand. The termination of a function is independent of the termination\nof its named workers. The termination of a named worker does not automatically\nresult in the termination of its function. When a default worker terminates\ncausing the function to terminate, the function does not automatically wait for\nthe termination of its named workers. There is a wait-action that allows one\nworker to explicitly wait for the termination of another worker.\n\u003c/p\u003e\n\u003cp\u003e\nA named worker has a return type. If the worker terminates normally, the\ntermination value will belong to the return type. If the return type of a worker\nis not specified, it defaults to nil as for functions. A return-type-descriptor\nin a named-worker-decl is an inferable context for a type descriptor, which\nmeans that \u003ccode\u003e*\u003c/code\u003e can be used to infer parts of the type descriptor; in\nparticular, it is convenient to use \u003ccode\u003eerror\u0026lt;*\u0026gt;\u003c/code\u003e to specify the\nerror type.\n\u003c/p\u003e\n\u003cp\u003e\nWhen a function has named workers, the default worker executes in three stages,\nas follows:\n\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe statements in default-worker-init are executed.\u003c/li\u003e\n\u003cli\u003eAll the named workers are started. Each named worker executes its\nsequence-stmt on its strand.\u003c/li\u003e\n\u003cli\u003eThe statements in default-worker are executed. This happens without waiting\nfor the termination of the named workers started in stage 2.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\nVariables declared in default-worker-init are in scope within named workers,\nwhereas variables declared in default-worker are not.\n\u003c/p\u003e\n\u003cp\u003e\nThe execution of a worker's sequence-stmt may result in the execution of a\nstatement that causes the worker to terminate. For example, a return statement\ncauses the worker to terminate. If this does not happen, then the worker\nterminates as soon as it has finished executing its sequence-stmt. In this case,\nthe worker terminates normally, and the termination value is nil. In other\nwords, falling off the end of a worker is equivalent to \u003ccode\u003ereturn;\u003c/code\u003e,\nwhich is in turn equivalent to \u003ccode\u003ereturn ();\u003c/code\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nThe parameters declared for a function are in scope in the function-body-block.\nThey are implicitly final: they can be read but not modified. They are in scope\nfor named workers as well as for the default worker.\n\u003c/p\u003e\n\u003cp\u003e\nThe name of a worker is in-scope as a final local variable. The scope is the\nfunction-body-block with the exception of the default-worker-init. When the\nworker name is accessed using a variable-reference-expr, it has type\nfuture\u0026lt;T\u003e, where T is the return type of the worker.\n\u003c/p\u003e\n\u003cp\u003e\nIn the above, function includes method, and function call includes method call.\n\u003c/p\u003e\n\u003ch3\u003eStatement execution\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003estatement := \n   action-stmt\n   | block-stmt\n   | local-var-decl-stmt\n   | local-type-defn-stmt\n   | xmlns-decl-stmt\n   | assignment-stmt\n   | compound-assignment-stmt\n   | destructuring-assignment-stmt\n   | call-stmt\n   | if-else-stmt\n   | match-stmt\n   | foreach-stmt\n   | while-stmt\n   | break-stmt\n   | continue-stmt\n   | fork-stmt\n   | panic-stmt\n   | lock-stmt\n   | async-send-stmt\n   | return-stmt\n   | transaction-stmt\n   | transaction-control-stmt\n\u003c/pre\u003e\n\u003cp\u003e\nThe execution of any statement may involve the evaluation of actions and\nexpressions, and the execution of substatements. The following sections\ndescribes how each kind of statement is evaluated, assuming that the evaluation\nof those expressions and actions completes normally, and assuming that the\nexecution of any substatements does not cause termination of the current worker.\n Except where explicitly stated to the contrary, statements handle abrupt\ncompletion of the evaluation of expressions and actions as follows. If in the\ncourse of executing a statement, the evaluation of some expression or action\ncompletes abruptly with associated value e, then the current worker is\nterminated with termination value e; if the abrupt termination is a check-fail,\nthen the termination is normal, otherwise the termination is abnormal. If the\nexecution of a substatement causes termination of the current worker, then the\nexecution of the statement terminates at that point.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003esequence-stmt := statement*\nblock-stmt := \u003ccode\u003e{\u003c/code\u003e sequence-stmt \u003ccode\u003e}\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nA \u003ccode\u003esequence-stmt\u003c/code\u003e executes its statements sequentially. A\n\u003ccode\u003eblock-stmt\u003c/code\u003e is executed by executing its \u003ccode\u003esequence-stmt\u003c/code\u003e.\n\u003c/p\u003e\n\u003ch3\u003eFork statement\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003efork-stmt := \u003ccode\u003efork\u003c/code\u003e \u003ccode\u003e{\u003c/code\u003e named-worker-decl+ \u003ccode\u003e}\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nThe fork statement starts one or more named workers, which run in parallel with\neach other, each in its own new strand.\n\u003c/p\u003e\n\u003cp\u003e\nVariables and parameters in scope for the fork-stmt remain in scope within the\nworkers (similar to the situation with parameters and workers in a function\nbody).\n\u003c/p\u003e\n\u003cp\u003e\nThe scope of the worker name declared in a named-worker-decl includes both other\nworkers in the same fork-stmt and the block containing the fork-stmt starting\nfrom the point immediately after the fork-stmt. When a worker-name is in scope\nit can be accessed using a variable-reference-expr, resulting in a value of type\nfuture\u0026lt;T\u003e, where T is the return type of that worker.\n\u003c/p\u003e\n\u003ch3\u003eWait action\u003c/h3\u003e\n\u003cp\u003e\nA wait-action waits for one or more workers to terminate, and gives access to\ntheir termination values.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003ewait-action :=\n   single-wait-waction\n   | multiple-wait-action\n   | alternate-wait-action\n\nwait-future-expr := expression but not mapping-constructor-expr\n\u003c/pre\u003e\n\u003cp\u003e\nA wait-future-expr is used by a wait-action to refer to the worker to be waited\nfor. Its static type must be future\u0026lt;T\u003e for some T. It can use a variable\nreference to refer to an in-scope named-worker-decl, which will be treated as a\nreference to a variable of type future\u0026lt;T\u003e where T is the return value of the\nworker.\n\u003c/p\u003e\n\u003cp\u003e\nNote that it is only possible to wait for a named worker, which will start its\nown strand. It is not possible to wait for a default worker, which runs on an\nexisting strand.\n\u003c/p\u003e\n\u003cp\u003e\nA mapping-constructor-expr is not recognized as a wait-future-expr (it would not\ntype-check in any case).\n\u003c/p\u003e\n\u003ch4\u003eSingle wait action\u003c/h4\u003e\n\n\u003cpre\nclass=\"grammar\"\u003esingle-wait-action := \u003ccode\u003ewait\u003c/code\u003e wait-future-expr\n\u003c/pre\u003e\n\u003cp\u003e\nA single-wait-action waits for a single future.\n\u003c/p\u003e\n\u003cp\u003e\nA single-wait-action is evaluated by evaluating wait-future-expr resulting in a\nvalue f, which must be of basic type future. It then waits until the strand of\nthe future has terminated. If the strand terminates normally, the\nsingle-wait-action completes normally with the termination value of the strand\nas the result. Otherwise, the single-wait-action completes abruptly with a\npanic, with the associated value being the termination value of the strand,\nwhich will be an error.\n\u003c/p\u003e\n\u003cp\u003e\nIf the static type of the wait-future-expr is future\u0026lt;T\u003e , then the static\ntype of the single-wait-action is then T.\n\u003c/p\u003e\n\u003ch4\u003eMultiple wait action\u003c/h4\u003e\n\n\u003cpre\nclass=\"grammar\"\u003emultiple-wait-action := \u003ccode\u003ewait\u003c/code\u003e \u003ccode\u003e{\u003c/code\u003e wait-field (\u003ccode\u003e,\u003c/code\u003e wait-field)* \u003ccode\u003e}\u003c/code\u003e\nwait-field :=\n  variable-name\n  | field-name \u003ccode\u003e:\u003c/code\u003e wait-future-expr\n\u003c/pre\u003e\n\u003cp\u003e\nA multiple-wait-action waits for multiple futures, returning the result as a\nrecord.\n\u003c/p\u003e\n\u003cp\u003e\nA wait-field that is a variable-name \u003ccode\u003ev\u003c/code\u003e is equivalent to a\nwait-field \u003ccode\u003ev: v\u003c/code\u003e, where \u003ccode\u003ev\u003c/code\u003e must be the name of an\nin-scope named worker.\n\u003c/p\u003e\n\u003cp\u003e\nA multiple-wait-action is evaluated by evaluating all of the wait-future-exprs\nresulting in a value of type future for each wait-field. It then waits for all\nof these futures. If all the futures complete normally, then it constructs a\nrecord with a field for each wait-field, whose name is the field-name and whose\nvalue is the completion value of the strand.\n\u003c/p\u003e\n\u003ch4\u003eAlternate wait action \u003c/h4\u003e\n\n\u003cpre\nclass=\"grammar\"\u003ealternate-wait-action := \u003ccode\u003ewait\u003c/code\u003e wait-future-expr (\u003ccode\u003e|\u003c/code\u003e wait-future-expr)+\n\u003c/pre\u003e\n\u003cp\u003e\nAn alternate-wait-action waits for one of multiple futures to terminate.\n\u003c/p\u003e\n\u003cp\u003e\nAn alternate-wait-action is evaluated by first evaluating all of the\nwait-future-exprs, resulting in a set of future values. It then starts waiting\nfor all of the futures. As soon as one of the futures completes normally with a\nnon-error value v, the alternate-wait-action completes normally with result v.\nIf all of the futures complete normally with an error, then it completes\nnormally with result e, where e is the termination value of the last future to\ncomplete.\n\u003c/p\u003e\n\u003cp\u003e\nIf the static type of the wait-future-exprs is future\u0026lt;T1\u003e, future\u0026lt;T2\u003e, ...,\nfuture\u0026lt;Tn\u003e, then the static type of the alternative-wait action is T1|T1|. .\n.Tn\n\u003c/p\u003e\n\u003ch3\u003eWorker message passing\u003c/h3\u003e\n\u003cp\u003e\nMessages can be sent between workers.\n\u003c/p\u003e\n\u003cp\u003e\nSends and receives are matched up at compile-time. This allows the connection\nbetween the send and the receive to be shown in the sequence diagram. It is also\nguarantees that any sent message will be received, provided that neither the\nsending nor the receiving worker terminate abnormally or with an error.\n\u003c/p\u003e\n\u003cp\u003e\nMessages can only be sent between workers that are peers of each other. The\ndefault worker and the named workers in a function are peers of each other. The\nworkers created in a fork-stmt are also peers of each other. The workers created\nin a fork-stmt are not peers of the default worker and named workers created by\na function.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003epeer-worker := worker-name | \u003ccode\u003edefault\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nA worker-name refers to a worker named in a named-worker-decl, which must be in\nscope; default refers to the default worker. The referenced worker must be a\npeer worker.\n\u003c/p\u003e\n\u003cp\u003e\nEach worker maintains a separate logical queue for each peer worker to which it\nsends messages; a sending worker sends a message by adding it to the queue; a\nreceiving worker receives a message by removing it from the sending worker's\nqueue for that worker; messages are removed in the order in which they were\nadded to the queue.\n\u003c/p\u003e\n\u003ch4\u003eSend action and send statement\u003c/h4\u003e\n\n\u003cpre\nclass=\"grammar\"\u003esync-send-action := expression \u003ccode\u003e-\u003e\u003e\u003c/code\u003e peer-worker\nasync-send-stmt := expression \u003ccode\u003e-\u003e\u003c/code\u003e peer-worker \u003ccode\u003e;\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nThe sync-send-action and async-send-stmt send a message to another worker. In\nboth cases, the message is the result of applying the Clone abstract operation\nto the result of evaluating expr. The message is sent to the worker identified\nby peer-worker.\n\u003c/p\u003e\n\u003cp\u003e\nIn both cases, the message is added to the message queue maintained by the\nsending  worker for messages to be sent to the sending worker. Conceptually, the\nmessage is added to the queue even if the receiving worker has already\nterminated.\n\u003c/p\u003e\n\u003cp\u003e\nFor each async-send-stmt and sync-send-action S, the compiler determines a\nunique corresponding receive-action R, such that a message sent by S will be\nreceived by R, unless R's worker has terminated abnormally or with failure. It\nis a compile-time error if this cannot be done. The compiler determines a\n\u003cem\u003efailure type\u003c/em\u003e for the corresponding receive-action. If the\nreceive-action was not executed and its worker terminated normally, then the\ntermination value of the worker will belong to the failure type. The failure\ntype will be a (possibly empty) subtype of error.\n\u003c/p\u003e\n\u003cp\u003e\nThe execution of the async-send-stmt completes as soon as the message is added\nto the queue. A subsequent flush action can be used to check whether the message\nwas received.\n\u003c/p\u003e\n\u003cp\u003e\nThe sync-send-action is evaluated by waiting until the receiving worker either\nexecutes a receive action that receives the queued message or terminates. The\nevaluation of sync-send-action completes as follows:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eif the queued message was received, then normally with result nil;\u003c/li\u003e\n\u003cli\u003eotherwise\n\u003cul\u003e\n\u003cli\u003eif the receiving worker terminated with failure, then normally with the\nresult being the the termination value of the receiving worker, which will be an\nerror;\u003c/li\u003e\n\u003cli\u003eif the receiving worker terminated abnormally, then abruptly with a panic,\nwith the associated value being the termination value of the receiving worker.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nThe static type of the sync-send-action is F|() where F is the failure type of\nthe corresponding receive action. If F is empty, then this static type will be\nequivalent to ().\n\u003c/p\u003e\n\u003cp\u003e\nThe contextually expected type used to interpret \u003ccode\u003eexpression\u003c/code\u003e is the\ncontextually expected type from the corresponding receive-action.\n\u003c/p\u003e\n\u003cp\u003e\nIf the receive-action corresponding to an async-send-stmt has a non-empty\nfailure type, then it is a compile-time error unless it can be determined that a\nsync-send-action or a flush-action will be executed before the sending worker\nterminates with success.\n\u003c/p\u003e\n\u003cp\u003e\nIf a worker W is about to terminate normally and there are messages still to be\nsent in a queue (which must be the result of executing an async-send-stmt), then\nthe worker waits until the messages have been received or some receiving worker\nterminates. If a receiving worker R terminates without the message being\nreceived, R must have terminated abnormally, because the rule in the preceding\nparagraph. In this case, W terminates abnormally and W will use R's termination\nvalue as its termination value.\n\u003c/p\u003e\n\u003ch4\u003eReceive action\u003c/h4\u003e\n\n\u003cpre\nclass=\"grammar\"\u003ereceive-action := single-receive-action | multiple-receive-action\n\u003c/pre\u003e\n\u003ch5\u003eSingle receive action\u003c/h5\u003e\n\n\u003cpre\nclass=\"grammar\"\u003esingle-receive-action := \u003ccode\u003e\u0026lt;-\u003c/code\u003e peer-worker\n\u003c/pre\u003e\n\u003cp\u003e\nA single-receive-action receives a message from a single worker.\n\u003c/p\u003e\n\u003cp\u003e\nFor each single-receive-action R receiving from worker W, the compiler\ndetermines a \u003cem\u003ecorresponding send set\u003c/em\u003e. The corresponding send set S is a\nset of sync-send-actions and async-send-stmts in W, such that\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ein any execution of W that terminates successfully, exactly one member of S\nis executed and is executed once only\u003c/li\u003e\n\u003cli\u003eif R is evaluated, it will receive the single message sent by a member of S,\nunless W has terminated abnormally or with failure.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nThe compiler terminates a failure type for the corresponding send set. If no\nmember of the corresponding send set was executed/evaluated and the sending\nworker terminated normally, then the termination value of the sending worker\nwill belong to the failure type. The failure type will be a (possibly empty)\nsubtype of error.\n\u003c/p\u003e\n\u003cp\u003e\nA single-receive-action is evaluated by waiting until there is a message\navailable in the queue or the sending worker terminates.  The evaluation of\nsingle-receive-action completes as follows:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eif a message becomes available in the queue, then the first available\nmessage is removed and the evaluation completes normally with the result being\nthat message;\u003c/li\u003e\n\u003cli\u003eotherwise\n\u003cul\u003e\n\u003cli\u003eif the sending worker terminated with failure, then normally with the result\nbeing the the termination value of the sending worker, which will be an error;\u003c/li\u003e\n\u003cli\u003eif the sending worker terminated abnormally, then abruptly with a panic,\nwith the associated value being the termination value of the sending worker.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nThe static type of the single-receive-action is T|F where T is the union of the\nstatic type of the expressions in the corresponding send set and F is the\nfailure type of the corresponding send set.\n\u003c/p\u003e\n\u003ch5\u003eMultiple receive action\u003c/h5\u003e\n\n\u003cpre\nclass=\"grammar\"\u003emultiple-receive-action :=\n   \u003ccode\u003e\u0026lt;-\u003c/code\u003e  \u003ccode\u003e{\u003c/code\u003e receive-field (\u003ccode\u003e,\u003c/code\u003e receive-field)* \u003ccode\u003e}\u003c/code\u003e\nreceive-field :=\n   peer-worker\n   | field-name \u003ccode\u003e:\u003c/code\u003e peer-worker\n\u003c/pre\u003e\n\u003cp\u003e\nA multiple-receive-action receives a message from multiple workers.\n\u003c/p\u003e\n\u003cp\u003e\nA peer-worker can occur at most once in a multiple-receive-action.\n\u003c/p\u003e\n\u003cp\u003e\nA receive-field consisting of a peer-worker \u003ccode\u003eW\u003c/code\u003e is equivalent to a\nfield \u003ccode\u003eW:W\u003c/code\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nThe compiler determines a corresponding send set for each receive field, in the\nsame way as for a single-receive-action. A multiple-receive-action is evaluated\nby waiting until there is a message available in the queue for every\npeer-worker.  If any of the peer workers W terminate before a message becomes\navailable, then the evaluation of the multiple-receive-action completes as\nfollows\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eif the sending worker terminated with failure, then normally with the result\nbeing the the termination value of the sending worker, which will be an error;\u003c/li\u003e\n\u003cli\u003eif the sending worker terminated abnormally, then abruptly with a panic,\nwith the associated value being the termination value of the sending worker.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nOtherwise, the result of the evaluation of multiple-receive-action completes by\nremoving the first message from each queue and constructing a record with one\nfield for each receive-field, where the value of the record is the message\nreceived.\n\u003c/p\u003e\n\u003cp\u003e\nThe contextually expected typed for the multiple-receive-action determines a\ncontextually expected type for each receive-field, in the same way as for a\nmapping constructor. The contextually expected type for each receive-field\nprovides the contextually expected type for the expression in each member of the\ncorresponding send set.\n\u003c/p\u003e\n\u003cp\u003e\nThe static type of multiple-receive-action is R|F where\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eR is a record type, where R is determined in the same way as for a mapping\nconstructor, where the static type of each field comes from the union of the\nstatic types of the expressions in each member of the corresponding send set and\nthe contextually expected type is the contextually expected type of the\nmultiple-receive-action\u003c/li\u003e\n\u003cli\u003eF is the union of the failure types for the corresponding send set for each\nreceive-field\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003eFlush action\u003c/h4\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eflush-action := \u003ccode\u003eflush\u003c/code\u003e [peer-worker]\n\u003c/pre\u003e\n\u003cp\u003e\nIf peer-worker is specified, then flush waits until the queue of messages to be\nreceived by peer-worker is empty or until the peer-worker terminates.\n\u003c/p\u003e\n\u003cp\u003e\nSend-receive correspondence for async-send-stmt implies that the queue will\neventually become empty, unless the peer-worker terminates abnormally or with\nfailure. The evaluation of flush-action completes as follows:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eif the queue of messages is empty, then normally with result nil;\u003c/li\u003e\n\u003cli\u003eotherwise\n\u003cul\u003e\n\u003cli\u003eif the peer-worker terminated with failure, then normally with the result\nbeing the the termination value of the peer-worker, which will be an error;\u003c/li\u003e\n\u003cli\u003eif the peer-worker terminated abnormally, then abruptly with a panic, with\nthe associated value being the termination value of the peer-worker.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nIf the flush-action has a preceding async-send-stmt without any intervening\nsync-send-action or other flush-action, then the static type of the flush-action\nis F|(), where F is the failure type of the receive-action corresponding to that\nasync-send-stmt. Otherwise, the static type of the flush-action is nil.\n\u003c/p\u003e\n\u003cp\u003e\nIf peer-worker is omitted, then the flush-action flushes the queues to all other\nworkers. In this case, the static type will be the union of the static type of\nflush on each worker separately.\n\u003c/p\u003e\n\u003ch4\u003eSend-receive correspondence\u003c/h4\u003e\n\u003cp\u003e\nThis section provides further details about how compile-time correspondence is\nestablished between sends and receive. This is based on the concept of the index\nof a message in its queue: a message has index n in its queue if it is the nth\nmessage added to the queue during the current execution of the worker.\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA send action/statement has index i in its queue if the message that it adds\nto the queue is always the i-th message added to the queue during the execution\nof its worker. It is a compile time error if a send statement or action does not\nhave an index in its queue.\u003c/li\u003e\n\u003cli\u003eA receive action has index i in a queue if any message that it removes from\nthe queue is always the i-th message removed from the queue during the execution\nof its worker. It is a compile time error if a receive action does not have an\nindex in each of its queues.\u003c/li\u003e\n\u003cli\u003eA send action/statement and a receive action correspond if they have the\nsame index in a queue.\u003c/li\u003e\n\u003cli\u003eIt is a compile time error if two or more receive actions have the same\nindex in a queue.\u003c/li\u003e\n\u003cli\u003eA send action/statement is in the same send set as another send\naction/statement if they have the same index in a queue. It is allowed for a\nsend set to have more than one member.\u003c/li\u003e\n\u003cli\u003eThe maximum index that a receive action has in a queue must be the same as\nthe maximum index that a send action or statement has in that queue.\u003c/li\u003e\n\u003cli\u003eIt is a compile time error if it is possible for a worker to terminate with\nsuccess before it has executed all its receive actions.\u003c/li\u003e\n\u003cli\u003eIt is a compile time error if it is possible for a worker to terminate with\nsuccess before it has executed one member from every send set.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eLocal variable declaration statements\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003elocal-var-decl-stmt :=\n   local-init-var-decl-stmt\n   | local-no-init-var-decl-stmt\nlocal-init-var-decl-stmt :=\n   annots [\u003ccode\u003efinal\u003c/code\u003e] typed-binding-pattern \u003ccode\u003e=\u003c/code\u003e action-or-expr \u003ccode\u003e;\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nA \u003ccode\u003elocal-var-decl-stmt\u003c/code\u003e is used to declare variables with a scope\nthat is local to the block in which they occur.\n\u003c/p\u003e\n\u003cp\u003e\nThe scope of variables declared in a \u003ccode\u003elocal-var-decl-stmt\u003c/code\u003e starts\nimmediately after the statement and continues to the end of the block statement\nin which it occurs.\n\u003c/p\u003e\n\u003cp\u003e\nA local-init-var-decl-stmt is executed by evaluating the action-or-expr\nresulting in a value, and then matching the typed-binding-pattern to the value,\ncausing assignments to the variables occurring in the typed-binding-pattern. The\ntyped-binding-pattern is used unconditionally, meaning that it is a compile\nerror if the static types do not guarantee the success of the match. If the\ntyped-binding-pattern uses \u003ccode\u003evar\u003c/code\u003e, then the type of the variable is\ninferred from the static type of the action-or-expr; if the\nlocal-init-var-decl-stmt includes final, the precise type is used, and otherwise\nthe broad type is used. If the typed-binding-pattern specifies a\ntype-descriptor, then that type-descriptor provides the contextually expected\ntype for action-or-expr.\n\u003c/p\u003e\n\u003cp\u003e\nIf \u003ccode\u003efinal\u003c/code\u003e is specified, then the variables declared must not be\nassigned to outside the local-init-var-decl-stmt.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003elocal-no-init-var-decl-stmt :=\n   annots [\u003ccode\u003efinal\u003c/code\u003e] type-descriptor variable-name \u003ccode\u003e;\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nA local variable declared \u003ccode\u003elocal-no-init-var-decl-stmt\u003c/code\u003e must be\ndefinitely assigned at each point that the variable is referenced. This means\nthat the compiler must be able to verify that the local variable will have been\nassigned before that point. If \u003ccode\u003efinal\u003c/code\u003e is specified, then the\nvariable must not be assigned more than once.\n\u003c/p\u003e\n\u003ch3\u003eImplicit variable type narrowing\u003c/h3\u003e\n\u003cp\u003e\nUsually the type of a reference to a variable is determined by the variable's\ndeclaration, either explicitly specified by a type descriptor or inferred from\nthe static type of the initializer.\n\u003c/p\u003e\n\u003cp\u003e\nIn addition, this section defines cases where a variable is used in certain\nkinds of boolean expression in a conditional context, and it can be proved at\ncompile time that the value stored in local variable or parameter will, within a\nparticular region of code, always belong to a type that is narrower that the\nstatic type of the variable. In these cases, references to the variable within\nparticular regions of code will have a static type that is narrower that the\nvariable type.\n\u003c/p\u003e\n\u003cp\u003e\nGiven an expression E with static type boolean, and a variable x with static\ntype Tx, we define how to determine\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ea narrowed type for x implied by truth of E and\u003c/li\u003e\n\u003cli\u003ea narrowed type for x implied by falsity of E\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nbased on the syntactic form of E as follows.\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf E has the form x is T, then\n\u003cul\u003e\n\u003cli\u003ethe narrowed type for x implied by truth of E is the intersection of Tx and\nT\u003c/li\u003e\n\u003cli\u003ethe narrowed type for x implied by falsity of E is Tx with T removed\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eIf E has the form x == E1 or E1 == x where the static type of E1 is an\nexpression whose static type is a singleton simple type T1, then\n\u003cul\u003e\n\u003cli\u003ethe narrowed type for x implied by truth of E is the intersection of Tx and\nT1\u003c/li\u003e\n\u003cli\u003ethe narrowed type for x implied by falsity of E is Tx with T1 removed\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eIf E has the form x != E1 or E1 != x where the static type of E1 is an\nexpression whose static type is a singleton simple type T1, then\n\u003cul\u003e\n\u003cli\u003ethe narrowed type for x implied by truth of E is Tx with T1 removed\u003c/li\u003e\n\u003cli\u003ethe narrowed type for x implied by falsity of E is the intersection of Tx\nand T1\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eIf E has the form !E1, then\n\u003cul\u003e\n\u003cli\u003ethe narrowed type for x implied by truth of E is the narrowed type for x\nimplied by falsity of E1\u003c/li\u003e\n\u003cli\u003ethe narrowed type for x implied by falsity of E is the narrowed type for x\nimplied by truth of E1\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eIf E has the form E1 \u0026amp;\u0026amp; E2\n\u003cul\u003e\n\u003cli\u003ethe narrowed type for x implied by truth of E is the intersection of T1 and\nT2, where T1 is the narrowed type for x implied by the truth of T1 and T2 is the\nnarrowed type for x implied by the truth of T2\u003c/li\u003e\n\u003cli\u003ethe narrowed type for x implied by falsity of E is T1|T2, where T1 is the\nnarrowed type for x implied by the falsity of E1, and T2 is the intersection of\nT3 and T4, where T3 is the narrowed type for x implied by the truth of E1 and T4\nis  the narrowed type for x implied by the falsity of E2\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eIf E has the form E1 || E2, then\n\u003cul\u003e\n\u003cli\u003e the narrowed type for x implied by truth of E is T1|T2, where T1 is the\nnarrowed type for x implied by the truth of E1, and T2 is the intersection of T3\nand T4, where T3 is the narrowed type for x implied by the falsity of E1 and T4\nis the narrowed type for x implied by the truth of E2\u003c/li\u003e\n\u003cli\u003ethe narrowed type for x implied by falsity of E is the intersection of T1\nand T2, where T1 is narrowed type for x implied by the falsity of E1 and T2 is\nthe narrowed type for x implied by the falsity of E2\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eIf E has any other form, then\n\u003cul\u003e\n\u003cli\u003ethe narrowed type for x implied by the truth of E is Tx\u003c/li\u003e\n\u003cli\u003ethe narrowed type for x implied by the falsity of E is Tx\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nNarrowed types apply to regions of code as follows:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ein an expression E1 || E2, the narrowed types implied by the falsity of E1\napply within E2\u003c/li\u003e\n\u003cli\u003ein an expression E1 \u0026amp;\u0026amp; E2, the narrowed types implied by the truth of E1\napply within E2\u003c/li\u003e\n\u003cli\u003ein an expression E1 ? E2 : E3, the narrowed types implied by the truth of E1\napply within E2 and the narrowed types implied by the falsity of E1 apply within\nE3\u003c/li\u003e\n\u003cli\u003ein a statement if E1 { B1 } else { B2 }, the narrowed types implied by the\ntruth of E1 apply within B1 and the narrowed types implied by the falsity of E1\napply within E2\u003c/li\u003e\n\u003cli\u003ein a match-clause P if E =\u003e { B }, the narrowed types implied by the truth\nof E apply within B\u003c/li\u003e\n\u003cli\u003ethe narrowed type for a variable x no longer applies as soon as there is a\npossibility of x being assigned to\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eLocal type definition statement\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003elocal-type-defn-stmt :=\n   annots \u003ccode\u003etype\u003c/code\u003e identifier type-descriptor \u003ccode\u003e;\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nA local-type-defn-stmt binds the identifier to a type descriptor within the\nscope of the current block. The type-descriptor is resolved when the statement\nis executed.\n\u003c/p\u003e\n\u003ch3\u003eXML namespace declaration statement\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003exmlns-decl-stmt := \u003ccode\u003exmlns\u003c/code\u003e xml-namespace [ \u003ccode\u003eas\u003c/code\u003e identifier ] \u003ccode\u003e;\u003c/code\u003e\nxml-namespace := simple-const-expr\n\u003c/pre\u003e\n\u003cp\u003e\nThe xml-decl-stmt is used to declare a XML namespace. If the identifier is\nomitted then the default namespace is defined. Once a default namespace is\ndefined, it is applicable for all XML values in the current scope. If an\nidentifier is provided then that identifier is the namespace prefix used to\nqualify elements and/or attribute names.  The static type of the\nsimple-const-expr must be a subtype of string.\n\u003c/p\u003e\n\u003ch3\u003eAssignment statement\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eassignment-stmt := lhs \u003ccode\u003e=\u003c/code\u003e action-or-expr \u003ccode\u003e;\u003c/code\u003e\nlhs :=\n   variable-reference\n   | lhs \u003ccode\u003e.\u003c/code\u003e field-name\n   | lhs \u003ccode\u003e[\u003c/code\u003e expression \u003ccode\u003e]\u003c/code\u003e\n   | lhs \u003ccode\u003e@\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nAn \u003ccode\u003elhs\u003c/code\u003e evaluates to a storage location, into which a value can be\nstored and from which a value can be fetched.\n\u003c/p\u003e\n\u003cp\u003e\nWhen a list value has an inherent type that is not fixed length. then attempting\nto write a member of a list at an index \u003cem\u003ei\u003c/em\u003e that is greater than or equal\nto the current length of the list will first increase the length of the list to\n\u003cem\u003ei\u003c/em\u003e + 1, with the newly added members of the array being filled in\nautomatically.\n\u003c/p\u003e\n\u003cp\u003e\nThe type of lhs provides the contextually expected type for action-or-expr.\n\u003c/p\u003e\n\u003ch3\u003eCompound assignment statement\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003ecompound-assignment-stmt := \n   lhs CompoundAssignmentOperator action-or-expr \u003ccode\u003e;\u003c/code\u003e\nCompoundAssignmentOperator := BinaryOperator \u003ccode\u003e=\u003c/code\u003e\nBinaryOperator := \u003ccode\u003e+\u003c/code\u003e | \u003ccode\u003e-\u003c/code\u003e | \u003ccode\u003e*\u003c/code\u003e | \u003ccode\u003e/\u003c/code\u003e | \u003ccode\u003e\u0026amp;\u003c/code\u003e | \u003ccode\u003e|\u003c/code\u003e | \u003ccode\u003e^\u003c/code\u003e | \u003ccode\u003e\u0026lt;\u0026lt;\u003c/code\u003e | \u003ccode\u003e\u003e\u003e\u003c/code\u003e | \u003ccode\u003e\u003e\u003e\u003e\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nThese statements update the value of the LHS variable to the value that results\nfrom applying the corresponding binary operator to the value of the variable and\nthe value of the expression.\n\u003c/p\u003e\n\u003ch3\u003eDestructuring assignment statement\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003edestructure-assignment-stmt :=\n   binding-pattern-not-variable-reference \u003ccode\u003e=\u003c/code\u003e action-or-expr \u003ccode\u003e;\u003c/code\u003e\nbinding-pattern-not-variable-reference :=\n   wildcard-binding-pattern\n   | list-binding-pattern\n   | mapping-binding-pattern\n   | error-binding-pattern\n\u003c/pre\u003e\n\u003cp\u003e\nA destructuring assignment is executed by evaluating the action-or-expr\nresulting in a value v, and then matching the binding pattern to v, causing\nassignments to the variables occurring in the binding pattern.\n\u003c/p\u003e\n\u003cp\u003e\nThe binding-pattern has a static type implied by the static type of the\nvariables occurring in it. The static type of action-or-expr must be a subtype\nof this type.\n\u003c/p\u003e\n\u003ch3\u003eAction statement\u003c/h3\u003e\n\n\u003cpre class=\"grammar\"\u003eaction-stmt := action \u003ccode\u003e;\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nAn action-stmt is a statement that is executed by evaluating an action and\ndiscarding the resulting value, which must be nil. It is a compile-time error if\nthe static type of an action in an action-stmt is not nil.\n\u003c/p\u003e\n\u003ch3\u003eCall statement\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003ecall-stmt := call-expr \u003ccode\u003e;\u003c/code\u003e\ncall-expr :=\n   function-call-expr\n   | method-call-expr\n   | \u003ccode\u003echeck\u003c/code\u003e call-expr\n   | \u003ccode\u003etrap\u003c/code\u003e call-expr\n\u003c/pre\u003e\n\u003cp\u003e\nA call-stmt is executed by evaluating call-expr as an expression and discarding\nthe resulting value, which must be nil.  It is a compile-time error if the\nstatic type of the call-expr in an call-stmt is not nil.\n\u003c/p\u003e\n\u003ch3\u003eRemote method call action\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eremote-method-call-action :=\n   [\u003ccode\u003estart\u003c/code\u003e] expression \u003ccode\u003e-\u003e\u003c/code\u003e method-name \u003ccode\u003e(\u003c/code\u003e arg-list \u003ccode\u003e)\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nCalls a remote method. This works the same as a method call expression, except\nthat it is used only for a method with the \u003ccode\u003eremote\u003c/code\u003e modifier.\n\u003c/p\u003e\n\u003cp\u003e\nIf \u003ccode\u003estart\u003c/code\u003e is specified, then the called method is executed on a new\nstrand, and the result of the \u003ccode\u003eremote-method-call-expr\u003c/code\u003e is a value of type\nfuture\u0026lt;T\u003e, where T is the return type of the method called.\n\u003c/p\u003e\n\n\u003ch3\u003eConditional statement\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eif-else-stmt :=\n   \u003ccode\u003eif\u003c/code\u003e expression block-stmt \n   [ \u003ccode\u003eelse\u003c/code\u003e \u003ccode\u003eif\u003c/code\u003e expression block-stmt ]* \n   [ \u003ccode\u003eelse\u003c/code\u003e block-stmt ]\n\u003c/pre\u003e\n\u003cp\u003e\nThe if-else statement is used for conditional execution.\n\u003c/p\u003e\n\u003cp\u003e\nThe static type of the expression following \u003ccode\u003eif\u003c/code\u003e must be boolean.\nWhen an expression is true then the corresponding block statement is executed\nand the if statement completes. If no expression is true then, if the else block\nis present, the corresponding block statement is executed.\n\u003c/p\u003e\n\u003ch3\u003eMatch statement\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003ematch-stmt := \u003ccode\u003ematch\u003c/code\u003e action-or-expr \u003ccode\u003e{\u003c/code\u003e match-clause+ \u003ccode\u003e}\u003c/code\u003e\nmatch-clause :=\n  match-pattern-list [match-guard] \u003ccode\u003e=\u003e\u003c/code\u003e block-stmt\nmatch-guard := \u003ccode\u003eif\u003c/code\u003e expression\n\u003c/pre\u003e\n\u003cp\u003e\nA match statement selects a block statement to execute based on which patterns a\nvalue matches.\n\u003c/p\u003e\n\u003cp\u003e\nA match-stmt is executed as follows:\n\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ethe expression is evaluated resulting in some value v;\u003c/li\u003e\n\u003cli\u003efor each match-clause in order:\n\u003col\u003e\n\u003cli\u003ea match of match-pattern against v is attempted\u003c/li\u003e\n\u003cli\u003eif the attempted match fails, the execution of the match-stmt continues to\nthe next match-clause\u003c/li\u003e\n\u003cli\u003eif the attempted match succeeds, then the variables in match-pattern are\ncreated\u003c/li\u003e\n\u003cli\u003eif there is a match-guard, then the expression in match-guard is executed\nresulting in a value b\u003c/li\u003e\n\u003cli\u003eif b is false, then the execution of the match-stmt continues to the next\nmatch-clause\u003c/li\u003e\n\u003cli\u003eotherwise, the block-stmt in the match-clause is executed\u003c/li\u003e\n\u003cli\u003eexecution of the match-stmt completes\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\nThe scope of any variables created in a match-pattern-list of a match-clause is\nboth the match-guard, if any, and the block-stmt in that match-clause. The\nstatic type of the expression in match-guard must be a subtype of boolean.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003ematch-pattern-list := \n  match-pattern (\u003ccode\u003e|\u003c/code\u003e match-pattern)*\n\u003c/pre\u003e\n\u003cp\u003e\nA match-pattern-list can be matched against a value. An attempted match can\nsucceed or fail. A match-pattern-list is matched against a value by attempting\nto match each match-pattern until a match succeeds.\n\u003c/p\u003e\n\u003cp\u003e\nAll the match-patterns in a given match-pattern-list must bind the same set of\nvariables.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003ematch-pattern :=\n  \u003ccode\u003evar\u003c/code\u003e binding-pattern\n   | wildcard-match-pattern\n   | const-pattern\n   | list-match-pattern\n   | mapping-match-pattern\n   | error-match-pattern\n\u003c/pre\u003e\n\u003cp\u003e\nA match-pattern combines the destructuring done by a binding-pattern with the\nability to match a constant value.\n\u003c/p\u003e\n\u003cp\u003e\nNote that an identifier can be interpreted in two different ways within a\nmatch-pattern:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ein the scope of a \u003ccode\u003evar\u003c/code\u003e, an identifier names a variable which is\nto be bound to a part of the matched value when a pattern match succeeds;\u003c/li\u003e\n\u003cli\u003eoutside the scope of a var, an identifier references a constant that a value\nmust match for the pattern match to succeed.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nA match-pattern must be linear: a variable that is to be bound cannot occur more\nthan once in a match-pattern.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003econst-pattern := simple-const-expr\n\u003c/pre\u003e\n\u003cp\u003e\nA const-pattern denotes a single value. Matching a const-pattern against a value\nsucceeds if the value has the same shape as the value denoted by the\nconst-pattern. A variable-reference in a const-pattern must refer to a constant.\nSuccessfully matching a const-pattern does not cause any variables to be\ncreated.\n\u003c/p\u003e\n\u003cp\u003e\nMatching a wildcard-match-pattern against a value succeeds if the value belongs to\ntype any, in other words if the basic type of the value is not error.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003ewildcard-match-pattern := \u003ccode\u003e_\u003c/code\u003e\nlist-match-pattern := \u003ccode\u003e[\u003c/code\u003e list-member-match-patterns \u003ccode\u003e]\u003c/code\u003e\nlist-member-match-patterns :=\n   match-pattern (\u003ccode\u003e,\u003c/code\u003e match-pattern)* [\u003ccode\u003e,\u003c/code\u003e rest-match-pattern]\n   | [ rest-match-pattern ]\nmapping-match-pattern := \u003ccode\u003e{\u003c/code\u003e field-match-patterns \u003ccode\u003e}\u003c/code\u003e\nfield-match-patterns :=\n   field-match-pattern (\u003ccode\u003e,\u003c/code\u003e field-match-pattern)* [\u003ccode\u003e,\u003c/code\u003e rest-match-pattern]\n   | [ rest-match-pattern ] \nfield-match-pattern := field-name \u003ccode\u003e:\u003c/code\u003e match-pattern\nrest-match-pattern := \u003ccode\u003e...\u003c/code\u003e \u003ccode\u003evar\u003c/code\u003e variable-name\nerror-match-pattern := \u003ccode\u003eerror\u003c/code\u003e \u003ccode\u003e(\u003c/code\u003e error-arg-list-match-pattern \u003ccode\u003e)\u003c/code\u003e\nerror-arg-list-match-pattern :=\n   simple-match-pattern (\u003ccode\u003e,\u003c/code\u003e named-arg-match-pattern)* [\u003ccode\u003e,\u003c/code\u003e rest-match-pattern]\n   | named-arg-match-pattern (\u003ccode\u003e,\u003c/code\u003e named-arg-match-pattern)* [\u003ccode\u003e,\u003c/code\u003e rest-match-pattern]\n   | [ rest-match-pattern]\nsimple-match-pattern :=\n   wildcard-match-pattern\n   | const-pattern\n   | \u003ccode\u003evar\u003c/code\u003e variable-name\nnamed-arg-match-pattern := arg-name \u003ccode\u003e=\u003c/code\u003e match-pattern\n\u003c/pre\u003e\n\n\u003cp\u003e\nMatching a \u003ccode\u003emapping-match-pattern\u003c/code\u003e against a mapping value succeeds\nif and only every \u003ccode\u003efield-match-pattern\u003c/code\u003e matches against a field of\nthe value. The variable in the \u003ccode\u003erest-match-pattern\u003c/code\u003e, if specified, is\nbound to a new mapping that contains just the fields for which that did not\nmatch a \u003ccode\u003efield-match-pattern\u003c/code\u003e.\n\u003c/p\u003e\n\n\u003ch3\u003eForeach statement\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eforeach-stmt :=\n   \u003ccode\u003eforeach\u003c/code\u003e typed-binding-pattern \u003ccode\u003ein\u003c/code\u003e action-or-expr block-stmt\n\u003c/pre\u003e\n\u003cp\u003e\nA foreach statement iterates over a sequence, executing a block statement once\nfor each member of the sequence.\n\u003c/p\u003e\n\u003cp\u003e\nThe scope of any variables created in typed-binding-pattern is block-stmt. These\nvariables are implicitly final.\n\u003c/p\u003e\n\u003cp\u003e\nIn more detail, a foreach statement executes as follows:\n\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eevaluate the expression resulting in a value c\u003c/li\u003e\n\u003cli\u003ecreate an iterator object i from c as follows\n\u003col\u003e\n\u003cli\u003eif c is a basic type that is iterable, then i is the result of calling\nc.iterator()\u003c/li\u003e\n\u003cli\u003eif c is an object and c belongs to Iterable\u0026lt;T\u003e for some T, then i is the\nresult of calling c.__iterator()\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003ecall i.next() resulting in a value n\u003c/li\u003e\n\u003cli\u003eif n is nil, then terminate execution of the foreach statement\u003c/li\u003e\n\u003cli\u003ematch typed-binding-pattern to n.value causing assignments to any variables\nthat were created in typed-binding-pattern\u003c/li\u003e\n\u003cli\u003eexecute block-stmt with the variable bindings from step 5 in scope; in the\ncourse of so doing\n\u003col\u003e\n\u003cli\u003ethe execution of a break-stmt terminates execution of the foreach statement\u003c/li\u003e\n\u003cli\u003ethe execution of a continue-stmt causes execution to proceed immediately to\nstep 3\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003ego back to step 3\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\nIn step 2, the compiler will give an error if the static type of expression is\nnot suitable for 2a or 2b.\n\u003c/p\u003e\n\u003cp\u003e\nIn step 5, the typed-binding-pattern is used unconditionally, and the compiler\nwill check that the static types guarantee that the match will succeed. If the\ntyped-binding-pattern uses var, then the type will be inferred from the type of\n\u003ccode\u003eexpression\u003c/code\u003e.\n\u003c/p\u003e\n\u003ch3\u003eWhile statement\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003ewhile-stmt := \u003ccode\u003ewhile\u003c/code\u003e expression block-stmt\n\u003c/pre\u003e\n\u003cp\u003e\nA while statement repeatedly executes a block statement so long as a\nboolean-valued expression evaluates to true.\n\u003c/p\u003e\n\u003cp\u003e\nIn more detail, a while statement executes as follows:\n\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eevaluate expression;\u003c/li\u003e\n\u003cli\u003eif expression evaluates to false, terminate execution of the while\nstatement;\u003c/li\u003e\n\u003cli\u003eexecute block-stmt; in the course of so doing\n\u003col\u003e\n\u003cli\u003ethe execution of a break-stmt results in termination of execution of the\nwhile statement\u003c/li\u003e\n\u003cli\u003ethe execution of a continue-stmt causes execution to proceed immediately to\nstep 1\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003ego back to step 1.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\nThe static type of \u003ccode\u003eexpression\u003c/code\u003e must be a subtype of boolean.\n\u003c/p\u003e\n\u003ch3\u003eContinue statement\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003econtinue-stmt := \u003ccode\u003econtinue\u003c/code\u003e \u003ccode\u003e;\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nA continue statement is only allowed if it is lexically enclosed within a\nwhile-stmt or a foreach-stmt. Executing a continue statement causes execution of\nthe nearest enclosing while-stmt or foreach-stmt to jump to the end of the\noutermost block-stmt in the while-stmt or foreach-stmt.\n\u003c/p\u003e\n\u003ch3\u003eBreak statement\u003c/h3\u003e\n\n\u003cpre class=\"grammar\"\u003ebreak-stmt := \u003ccode\u003ebreak\u003c/code\u003e \u003ccode\u003e;\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nA break statement is only allowed if it is lexically enclosed within a\nwhile-stmt or a foreach-stmt. Executing a break statement causes the nearest\nenclosing while-stmt or foreach-stmt to terminate.\n\u003c/p\u003e\n\u003ch3\u003e[Experimental] Lock statement\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003elock-stmt := \u003ccode\u003elock\u003c/code\u003e block-stmt\n\u003c/pre\u003e\n\u003cp\u003e\nA lock statement is used to execute a series of assignment statements in a\nserialized manner. For each variable that is used as an L-value within the block\nstatement, this statement attempts to first acquire a lock and the entire\nstatement executes only after acquiring all the locks. If a lock acquisition\nfails after some have already been acquired then all acquired locks are released\nand the process starts again.\n\u003c/p\u003e\n\u003cp\u003e\n\u003cstrong\u003eNote\u003c/strong\u003e \u003cem\u003eThe design of shared data access is likely to change\nin a future version.\u003c/em\u003e\n\u003c/p\u003e\n\u003ch3\u003ePanic statement\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003epanic-stmt := \u003ccode\u003epanic\u003c/code\u003e expression \u003ccode\u003e;\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nA panic statement terminates the current worker abnormally. The result of\nevaluating \u003ccode\u003eexpression\u003c/code\u003e provides the termination value of the worker.\n\u003c/p\u003e\n\u003cp\u003e\nThe static type of \u003ccode\u003eexpression\u003c/code\u003e must be a subtype of error.\n\u003c/p\u003e\n\u003ch3\u003eReturn statement\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003ereturn-stmt := \u003ccode\u003ereturn\u003c/code\u003e [ action-or-expr ] \u003ccode\u003e;\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nA return statement terminates the current worker normally.The result of\nevaluating the action-or-expr provides the termination value of the worker. If\naction-or-expr is omitted, then the termination value is nil.\n\u003c/p\u003e\n\u003ch2 id=\"built-in_methods\"\u003e8. Built-in methods\u003c/h2\u003e\n\u003cp\u003e\nThe following built-in methods are available.\n\u003c/p\u003e\n\u003ch3\u003eGeneric methods\u003c/h3\u003e\n\u003cp\u003e\nThe following methods are provided on a variety of different basic types, with a\nconsistent semantics.\n\u003c/p\u003e\n\u003ch4\u003elength\u003c/h4\u003e\n\u003cp\u003e\nThe length method returns an integer representing the number of items that a\nvalue contains, where the meaning of item depends on the basic type of value.\nThe following list specifies the basic types for which it is provided, and the\nmeaning on each basic type:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003estring: is the number of code points in the string\u003c/li\u003e\n\u003cli\u003elist: the number of members of the list\u003c/li\u003e\n\u003cli\u003emapping: the length of a mapping is the number of members in the mapping\u003c/li\u003e\n\u003cli\u003etable: the number of rows in the table\u003c/li\u003e\n\u003cli\u003exml: the number of content items in this XML value, where each character,\nelement, comment and processing instructions is counted as a single content item\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003eiterator\u003c/h4\u003e\n\u003cp\u003e\nThe iterator method is provided for all iterable basic types. It returns a new\nobject belonging to the Iterator\u0026lt;T\u003e abstract type, where T depends on the\nbasic type as follows:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003estring: T is string; it will iterate over the substrings of length 1\u003c/li\u003e\n\u003cli\u003elist: T is the union of the type of members of the list\u003c/li\u003e\n\u003cli\u003emapping: T is (string, M) where M is the union of the types of the members\nof the mapping\u003c/li\u003e\n\u003cli\u003etable: T is a record representing a single row\u003c/li\u003e\n\u003cli\u003exml: T is string|xml\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003efreeze, clone, unfrozenClone\u003c/h4\u003e\n\u003cp\u003e\nThe freeze, clone and unfrozenClone built-in methods work in a similar way. They\nare provided on all structural types other than error, and all basic types other\nthan nil. When applied to a value v, the method starts by checking whether v is\na pure value; if it is not, the method returns an error. (If v belongs to type\nanydata, then it is guaranteed that v is a pure value.) Otherwise, the method\nreturns Freeze(v), Clone(v) or UnfrozenClone(v).\n\u003c/p\u003e\n\u003cp\u003e\nThe static type of the return type of applying one of these methods to an\nexpression of type T is T if T is a subtype of anydata, and otherwise is\nT|error.\n\u003c/p\u003e\n\u003ch4\u003eisFrozen\u003c/h4\u003e\n\u003cp\u003e\nThe isFrozen method is provided on all structural types other than error. When\napplied to a value v, it returns true if the value is frozen and false\notherwise.\n\u003c/p\u003e\n\u003ch3\u003eFloating point methods\u003c/h3\u003e\n\u003cp\u003e\nThe following  built-in methods are provided on both the decimal and float basic\ntypes. They all return boolean.\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eisFinite: true iff this is neither infinity nor NaN\u003c/li\u003e\n\u003cli\u003eisInfinite: true iff this is infinity (plus or minus)\u003c/li\u003e\n\u003cli\u003eisNaN: true iff this is NaN\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eError methods\u003c/h3\u003e\n\u003cp\u003e\nThe following  built-in methods are provided on the error basic type:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ereason: returns the error's reason string\u003c/li\u003e\n\u003cli\u003edetail: returns the error's detail record as a frozen mapping\u003c/li\u003e\n\u003cli\u003estackTrace: returns an object representing the stack trace of the error\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eFunction methods\u003c/h3\u003e\n\u003cp\u003e\nThe following built-in method is provided on the function basic type:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecall: \u003ccode\u003ef.call(args)\u003c/code\u003e means the same as \u003ccode\u003ef(args)\u003c/code\u003e; this\nallows f to be an arbitrary expression\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eTypedesc methods\u003c/h3\u003e\n\u003cp\u003e\nThe stamp and convert methods are provided on typedesc values. They both take a\nsingle parameter of type anydata, and return a value of type T|error where T is\nthe type denoted by the typedesc value.\n\u003c/p\u003e\n\u003ch4\u003estamp\u003c/h4\u003e\n\u003cp\u003e\nThe stamp method takes a single argument of type anydata.\n\u003c/p\u003e\n\u003cp\u003e\nt.stamp(v) works as follows\n\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eIt checks that v is a tree. If v is a reference value, and the graph\nstructure of v is not a tree, then stamp returns an error.\u003c/li\u003e\n\u003cli\u003eIf the shape of v is not a member of the set of shapes denoted by t (i.e. v\ndoes not look like t), then stamp will attempt to modify it so that it is by\nusing numeric conversions (as defined by the NumericConvert operation) on\nmembers of containers and by adding fields for which a default value is defined.\nIf this fails or can be done in more than one way, then stamp will return an\nerror. Frozen structures will not be modified, nor will new structures be\ncreated.\u003c/li\u003e\n\u003cli\u003eAt this point, v looks like t. Now stamp narrows the inherent type of v, and\nrecursively of any members of v, so that the v belongs to t, and then returns v.\nAny frozen values in v are left unchanged by this.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4\u003econvert\u003c/h4\u003e\n\u003cp\u003e\nThe convert method takes a single argument of type anydata. It is similar to\nstamp, but it does not modify its argument.\n\u003c/p\u003e\n\u003cp\u003e\nt.convert(v) works as follows:\n\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eIt checks that v is a tree. If v is a reference value, and the graph\nstructure of v is not a tree, then convert returns an error.\u003c/li\u003e\n\u003cli\u003econvert now creates a new value that has the same shape as v, except\npossibly for differences in numeric types and for the addition of fields for\nwhich a default value is defined, but belongs to type\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"module_level\"\u003e9. Module-level declarations\u003c/h2\u003e\n\u003cp\u003e\nEach source part in a Ballerina module must match the production\n\u003ccode\u003emodule-part\u003c/code\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nThe import declarations must come before other declarations; apart from this,\nthe order of the definitions and declarations at the top-level of a module is\nnot significant.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003emodule-part := import-decl* other-decl*\nother-decl := metadata other-decl-item\nother-decl-item :=\n   module-type-defn\n   | module-const-decl\n   | module-var-decl\n   | listener-decl\n   | function-defn\n   | outside-method-defn\n   | service-decl\n   | xmlns-decl-stmt\n   | annotation-decl\n\u003c/pre\u003e\n\u003ch3\u003eModule and program execution\u003c/h3\u003e\n\u003cp\u003e\nCreating a Ballerina program from a collection of modules requires that one\nmodule is identified as the \u003cem\u003eroot\u003c/em\u003e module. The modules comprising the\nprogram consist of the root module together with transitive closure of its\nimported modules.\n\u003c/p\u003e\n\u003cp\u003e\nIf the root module of the program has a function called \u003ccode\u003emain\u003c/code\u003e, then\nit must be public and its return type must both be a subtype of\n\u003ccode\u003eerror?\u003c/code\u003e and contain nil. Any parameters must have a type that is a\nsubtype of anydata; they are not restricted to strings.\n\u003c/p\u003e\n\u003cp\u003e\nIf the root module does not have a function called \u003ccode\u003emain\u003c/code\u003e, then there\nmust be at least one service declared in at least one of the program's modules.\n\u003c/p\u003e\n\u003cp\u003e\nWhen a Ballerina program is executed, the arguments to main come from the\ncommand line made available by the operating system. The format of the command\nline is operating system dependent, but is typically some sort of string or\narray of strings. The implementation should make use of the declared parameter\ntypes of main in attempting to convert the                  supplied command\nline into an argument list acceptable to main. It may also make use of\nannotations on main.\n\u003c/p\u003e\n\u003cp\u003e\nThe execution of a program can terminate in one of three ways: success, failure\nor abnormal. In the failure and abnormal cases, there is an associated error\nvalue. For the failure case, the type of the error value can be determined at\ncompile time.\n\u003c/p\u003e\n\u003cp\u003e\nThe execution of a Ballerina has two or three consecutive phases:\n\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003einit\u003c/li\u003e\n\u003cli\u003emain\u003c/li\u003e\n\u003cli\u003elisten\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\nThere is always an init phase. There must be at least one of the main or listen\nphases, and there may be both.\n\u003c/p\u003e\n\u003cp\u003e\nIn the init phase, every module comprising the program is initialized, in such\nan order than a module is always initialized after all the modules it imports\nhave been initialized. If a module fails to initialize, then the program\nterminates.\n\u003c/p\u003e\n\u003cp\u003e\nThe main phase happens only if the root module has a main function. In this\ncase, the main function is executed with arguments converted from the supplied\ncommand line. If the main function returns an error, then the program\nterminates.\n\u003c/p\u003e\n\u003cp\u003e\nIf the main function returns nil and there is no listener registered with any\nmodule, then the program terminates successfully.\n\u003c/p\u003e\n\u003cp\u003e\nOtherwise the listen phase happens. In  this phase, all the listeners that have\nbeen registered with any of the modules are started, by calling their\n\u003ccode\u003e__start\u003c/code\u003e method. (If there was no main function, then the successful\ninitialization of the required service declaration will ensure that at least one\nlistener will have been registered.)\n\u003c/p\u003e\n\u003cp\u003e\nThe listen phase continues to execute until either the program explicitly exits,\nby calling a standard library function, or the user explicitly requests the\ntermination the program using an implementation-dependent operating system\nfacility (such as a signal on a POSIX system). In the latter case, the program\nwill call the __stop request on each registered listener before terminating.\n\u003c/p\u003e\n\u003ch3\u003eImport declaration\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eimport-decl := \n   \u003ccode\u003eimport\u003c/code\u003e [org-name \u003ccode\u003e/\u003c/code\u003e] pkg-name [\u003ccode\u003eversion\u003c/code\u003e sem-ver] \n   [\u003ccode\u003eas\u003c/code\u003e module-identifier] \u003ccode\u003e;\u003c/code\u003e\nmodule-identifier := identifier\norg-name := identifier\npkg-name := identifier (\u003ccode\u003e.\u003c/code\u003e identifier)*\nsem-ver := major-num [\u003ccode\u003e.\u003c/code\u003e minor-num [\u003ccode\u003e.\u003c/code\u003e patch-num]]\nmajor-num := DecimalNumber\nminor-num := DecimalNumber\npatch-num := DecimalNumber\n\nqualified-identifier := [module-identifier \u003ccode\u003e:\u003c/code\u003e] identifier\n\u003c/pre\u003e\n\u003cp\u003e\nA module-identifier in a qualified-identifier must refer to a module-identifier\nspecified in an import-declaration in the same source part.\n\u003c/p\u003e\n\u003ch3\u003eModule type definition\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003emodule-type-defn :=\n   metadata\n   \u003ccode\u003epublic\u003c/code\u003e? \u003ccode\u003etype\u003c/code\u003e identifier type-descriptor \u003ccode\u003e;\u003c/code\u003e\n\u003c/pre\u003e\n\u003ch3\u003eModule variable declaration\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003emodule-var-decl :=\n   metadata\n   [\u003ccode\u003efinal\u003c/code\u003e]\n   typed-binding-pattern \u003ccode\u003e=\u003c/code\u003e expression \u003ccode\u003e;\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nThe scope of variables declared in a module-var-decl is the entire module. Note\nthat module variables are not allowed to be public. If final is specified, then\nit is not allowed to assign to the variable. If the typed-binding-pattern uses\n\u003ccode\u003evar\u003c/code\u003e, then the type of the variable is inferred from the static type\nof \u003ccode\u003eexpression\u003c/code\u003e; if the module-var-decl includes \u003ccode\u003efinal\u003c/code\u003e,\nthe precise type is used, and otherwise the broad type is used. If the\ntyped-binding-pattern specifies a type-descriptor, then that type-descriptor\nprovides the contextually expected type for action-or-expr.\n\u003c/p\u003e\n\u003ch3\u003eModule constant declaration\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003emodule-const-decl :=\n   metadata\n   \u003ccode\u003epublic\u003c/code\u003e? \u003ccode\u003econst\u003c/code\u003e [type-descriptor] identifier \u003ccode\u003e=\u003c/code\u003e const-expr \u003ccode\u003e;\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nA module-const-decl declares a compile-time constant. A compile-time constant is\nan named immutable value, known at compile-time. A compile-time constant can be\nused like a variable, and can also be referenced in contexts that require a\nvalue that is known at compile-time, such as in a type-descriptor or in a\nmatch-pattern.\n\u003c/p\u003e\n\u003cp\u003e\nThe type of the constant is the singleton type containing just the shape of the\nvalue named by the constant. The type of the constant determines the static type\nof a variable-reference-expr that references this constant.\n\u003c/p\u003e\n\u003cp\u003e\nIf type-descriptor is present, then it provides the contextually expected type\nfor the interpretation of const-expr. It is a compile-time error if the static\ntype of const-expr is not a subtype of that type. The type-descriptor must\nspecify a type that is a subtype of anydata. Note that the type-descriptor does\nnot specify the type of the constant, although the type of the constant will all\nbe a subtype of the type specified by the type-descriptor.\n\u003c/p\u003e\n\u003ch3\u003eListener declaration\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003elistener-decl :=\n   metadata\n   \u003ccode\u003epublic\u003c/code\u003e? \u003ccode\u003elistener\u003c/code\u003e [type-descriptor] identifier \u003ccode\u003e=\u003c/code\u003e expression \u003ccode\u003e;\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nA \u003ccode\u003elistener-decl\u003c/code\u003e defines a module listener.\n\u003c/p\u003e\n\u003cp\u003e\nA module listener is an object value that belongs to the Listener abstract\nobject type and is managed as part of the module's lifecycle. A module may have\nmultiple listeners.\n\u003c/p\u003e\n\u003cp\u003e\nA module-listener can be referenced by a variable-reference, but cannot be\nmodified. It is this similar to a final variable declaration, except that it\nalso registers the value with the module as a listener.\n\u003c/p\u003e\n\u003cp\u003e\nA module listener has a static type, which must be a subtype of the Listener\ntype. If the type-descriptor is present it specifies the module listener's\nstatic type; if it is not present, the the static type of the listener is the\nstatic type of \u003ccode\u003eexpression\u003c/code\u003e.\n\u003c/p\u003e\n\u003ch3\u003eFunction definition\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003efunction-defn := \n   metadata\n   [\u003ccode\u003epublic\u003c/code\u003e]\n   \u003ccode\u003efunction\u003c/code\u003e identifier function-signature function-body\nfunction-body := function-body-block | external-function-body\nexternal-function-body := \u003ccode\u003e=\u003c/code\u003e annots \u003ccode\u003eexternal\u003c/code\u003e \u003ccode\u003e;\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nAn \u003ccode\u003eextern-function-body\u003c/code\u003e means that the implementation of the\nfunction is not provided in the Ballerina source module.\n\u003c/p\u003e\n\u003ch3\u003eService declaration\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eservice-decl :=\n  metadata\n  \u003ccode\u003eservice\u003c/code\u003e [identifier] \u003ccode\u003eon\u003c/code\u003e expression-list service-body-block\nexpression-list := expression (\u003ccode\u003e,\u003c/code\u003e expression)*\n\u003c/pre\u003e\n\u003cp\u003e\nCreates a service and attaches it to one or more listeners.\n\u003c/p\u003e\n\u003cp\u003e\nThis works as follows:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eservice-body is the same as what goes inside a service constructor\u003c/li\u003e\n\u003cli\u003eexpression is evaluated to an object obj that matches the Listener interface\nor an error; if its an error then module initialization panics\u003c/li\u003e\n\u003cli\u003eobj is registered with the module as one of its endpoints (registering the\nsame object multiple times is the same as registering it once)\u003c/li\u003e\n\u003cli\u003eservice-body-block is evaluated as in a service-constructor to get a service\nvalue s;  the parameter type of obj.__attach determines the contextually\nexpected type\u003c/li\u003e\n\u003cli\u003eidentifier, if present, works as a final variable whose value is s\u003c/li\u003e\n\u003cli\u003es is attached to obj using obj.__attach; the identifier is supplied as an\nargument to obj.attach along with s (nil if not present)\u003c/li\u003e\n\u003cli\u003eif __attach returns an error, then module initialization panics\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"querying\"\u003e10. [Experimental] Querying\u003c/h2\u003e\n\u003cp\u003e\nBallerina tables and streams are designed for processing data at rest and data\nin motion, respectively.\n\u003c/p\u003e\n\u003ch3\u003eTable query expressions\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003etable-query-expr := \n   \u003ccode\u003efrom\u003c/code\u003e query-source [query-join-type query-join-source] \n      [query-select] [query-group-by] [query-order-by]\n      [query-having] [query-limit]\nquery-source := identifier [\u003ccode\u003eas\u003c/code\u003e identifier] [query-where]\nquery-where := \u003ccode\u003ewhere\u003c/code\u003e expression\nquery-join-type := [([\u003ccode\u003eleft\u003c/code\u003e | \u003ccode\u003eright\u003c/code\u003e | \u003ccode\u003efull\u003c/code\u003e] \u003ccode\u003eouter\u003c/code\u003e)| \u003ccode\u003einner\u003c/code\u003e] \u003ccode\u003ejoin\u003c/code\u003e\nquery-join-source := query-source \u003ccode\u003eon\u003c/code\u003e expression\nquery-select := \u003ccode\u003eselect\u003c/code\u003e (\u003ccode\u003e*\u003c/code\u003e | query-select-list)\nquery-select-list := \n   expression [\u003ccode\u003eas\u003c/code\u003e identifier] (, expression [\u003ccode\u003eas\u003c/code\u003e identifier])*\nquery-group-by := \u003ccode\u003egroup\u003c/code\u003e \u003ccode\u003eby\u003c/code\u003e identifier (\u003ccode\u003e,\u003c/code\u003e identifier)*\nquery-order-by :=\n   \u003ccode\u003eorder\u003c/code\u003e \u003ccode\u003eby\u003c/code\u003e identifier [(\u003ccode\u003eascending\u003c/code\u003e | \u003ccode\u003edescending\u003c/code\u003e)]\n      (\u003ccode\u003e,\u003c/code\u003e identifier [(\u003ccode\u003eascending\u003c/code\u003e | \u003ccode\u003edescending\u003c/code\u003e)])*\nquery-having := \u003ccode\u003ehaving\u003c/code\u003e expression\nquery-limit := \u003ccode\u003elimit\u003c/code\u003e int-literal\n\u003c/pre\u003e\n\u003cp\u003e\nQuery expressions being language integrated SQL-like querying to Ballerina\ntables.\n\u003c/p\u003e\n\u003ch3\u003eStreaming queries\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eforever-stmt :=\n   \u003ccode\u003eforever\u003c/code\u003e \u003ccode\u003e{\u003c/code\u003e \n      streaming-query-pattern+\n   \u003ccode\u003e}\u003c/code\u003e\nstreaming-query-pattern :=\n   streaming-query-expr \u003ccode\u003e=\u003e\u003c/code\u003e \u003ccode\u003e(\u003c/code\u003e array-type-descriptor identifier \u003ccode\u003e)\u003c/code\u003e\n      block-stmt\nstreaming-query-expr :=\n   \u003ccode\u003efrom\u003c/code\u003e (sq-source [query-join-type sq-join-source]) | sq-pattern\n      [query-select] [query-group-by] [query-order-by]\n      [query-having] [query-limit] \n      [sq-output-rate-limiting]\nsq-source := \n   identifier [query-where] [sq-window [query-where]] \n      [\u003ccode\u003eas\u003c/code\u003e identifier]*\nsq-window := \u003ccode\u003ewindow\u003c/code\u003e function-call-exp\nsq-join-source := sq-source \u003ccode\u003eon\u003c/code\u003e expression\nsq-output-rate-limiting := \n   sq-time-or-event-output | sq-snapshot-output\nsq-time-or-event-output := \n   (\u003ccode\u003eall\u003c/code\u003e | \u003ccode\u003elast\u003c/code\u003e | \u003ccode\u003efirst\u003c/code\u003e) \u003ccode\u003eevery\u003c/code\u003e int-literal (time-scale | \u003ccode\u003eevents\u003c/code\u003e)\nsq-snapshot-output :=\n   \u003ccode\u003esnapshot\u003c/code\u003e \u003ccode\u003eevery\u003c/code\u003e int-literal time-scale\ntime-scale := \u003ccode\u003eseconds\u003c/code\u003e | \u003ccode\u003eminutes\u003c/code\u003e | \u003ccode\u003ehours\u003c/code\u003e | \u003ccode\u003edays\u003c/code\u003e | \u003ccode\u003emonths\u003c/code\u003e | \u003ccode\u003eyears\u003c/code\u003e\nsq-pattern := [\u003ccode\u003eevery\u003c/code\u003e] sp-input [sp-within-clause]\nsp-within-clause := \u003ccode\u003ewithin\u003c/code\u003e expression\nsp-input :=\n   sp-edge-input (\u003ccode\u003efollowed\u003c/code\u003e \u003ccode\u003eby\u003c/code\u003e) | \u003ccode\u003e,\u003c/code\u003e streaming-pattern-input\n   | \u003ccode\u003enot\u003c/code\u003e sp-edge-input (\u003ccode\u003eand\u003c/code\u003e sp-edge-input) | (\u003ccode\u003efor\u003c/code\u003e simple-literal)\n   | [sp-edge-input ( \u003ccode\u003eand\u003c/code\u003e | \u003ccode\u003eor\u003c/code\u003e ) ] sp-edge-input\n   | \u003ccode\u003e(\u003c/code\u003e sp-input \u003ccode\u003e)\u003c/code\u003e\nsp-edge-input :=\n   identifier [query-where] [int-range-expr] [\u003ccode\u003eas\u003c/code\u003e identifier]\n\u003c/pre\u003e\n\u003cp\u003e\nThe forever statement is used to execute a set of streaming queries against some\nnumber of streams concurrently and to execute a block of code when a pattern\nmatches. The statement will never complete and therefore the worker containing\nit will never complete. See section 10 for details.\n\u003c/p\u003e\n\u003ch2 id=\"transactions\"\u003e11. [Experimental] Transactions\u003c/h2\u003e\n\n\u003cpre\nclass=\"grammar\"\u003etransaction-stmt := \u003ccode\u003etransaction\u003c/code\u003e trans-conf? block-stmt trans-retry?\ntransaction-control-stmt := retry-stmt | abort-stmt\ntrans-conf := trans-conf-item (\u003ccode\u003e,\u003c/code\u003e trans-conf-item)*\ntrans-conf-item := trans-retries | trans-oncommit | trans-onabort\ntrans-retries := \u003ccode\u003eretries\u003c/code\u003e \u003ccode\u003e=\u003c/code\u003e expression\ntrans-oncommit := \u003ccode\u003eoncommit\u003c/code\u003e \u003ccode\u003e=\u003c/code\u003e identifier\ntrans-onabort := \u003ccode\u003eonabort\u003c/code\u003e \u003ccode\u003e=\u003c/code\u003e identifier\ntrans-retry := \u003ccode\u003eonretry\u003c/code\u003e block-stmt\nretry-stmt := \u003ccode\u003eretry\u003c/code\u003e \u003ccode\u003e;\u003c/code\u003e\nabort-stmt := \u003ccode\u003eabort\u003c/code\u003e \u003ccode\u003e;\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nA transaction statement is used to execute a block of code within a 2PC\ntransaction. A transaction can be established by this statement or it may\ninherit one from the current worker.\n\u003c/p\u003e\n\u003ch3\u003eInitiated transactions\u003c/h3\u003e\n\u003cp\u003e\nIf no transaction context is present in the worker then the transaction\nstatement starts a new transaction (i.e., becomes the initiator) and executes\nthe statements within the transaction statement.\n\u003c/p\u003e\n\u003cp\u003e\nUpon completion of the block the transaction is immediately tried to be\ncommitted. If the commit succeeds, then if there's an on-commit handler\nregistered that function gets invoked to signal that the commit succeeded. If\nthe commit fails, and if the transaction has not been retried more times than\nthe value of the retries configuration, then the on-retry block is executed and\nthe transaction block statement will execute again in its entirety. If there are\nno more retries available then the commit is aborted the on-abort function is\ncalled.\n\u003c/p\u003e\n\u003cp\u003e\nThe transaction can also be explicitly aborted using an abort statement, which\nwill call the on-abort function and give up the transaction (without retrying).\n\u003c/p\u003e\n\u003cp\u003e\nIf a retry statement is executed if the transaction has not been retried more\ntimes than the value of the retries configuration, then the on-retry block is\nexecuted and the transaction block statement will execute again in its entirety.\n\u003c/p\u003e\n\u003ch3\u003eParticipated transactions\u003c/h3\u003e\n\u003cp\u003e\nIf a transaction context is present in the executing worker context, then the\ntransaction statement joins that transaction and becomes a participant of that\nexisting transaction. In this case, retries will not occur as the transaction is\nunder the control of the initiator. Further, if the transaction is locally\naborted (by using the abort statement), the transaction gets marked for abort\nand the participant will fail the transaction when it is asked to prepare for\ncommit by the coordinator of the initiator. When the initiating coordinator\ndecides to abort the transaction it will notify all the participants globally\nand their on-abort functions will be invoked. If the initiating coordinator\ndecides to retry the transaction then a new transaction is created and the\nprocess starts with the entire containing executable entity (i.e. resource or\nfunction) being re-invoked with the new transaction context.\n\u003c/p\u003e\n\u003cp\u003e\nWhen the transaction statement reaches the end of the block the transaction is\nmarked as ready to commit. The actual commit will happen when the coordinator\nsends a commit message to the participant and after the commit occurs the\non-commit function will be invoked. Thus, reaching the end of the transaction\nstatement and going past does not have the semantic of the transaction being\ncommitted nor of it being aborted. Thus, if statements that follow the\ntransaction statement they are unaware whether the transaction has committed or\naborted.\n\u003c/p\u003e\n\u003cp\u003e\nWhen in a participating transaction, a retry statement is a no-op.\n\u003c/p\u003e\n\u003ch3\u003eTransaction propagation\u003c/h3\u003e\n\u003cp\u003e\nThe transaction context in a worker is always visible to invoked functions. Thus\nany function invoked within a transaction, which has a transaction statement\nwithin it, will behave according to the \"participated transactions\" semantics\nabove.\n\u003c/p\u003e\n\u003cp\u003e\nThe transaction context is also propagated over the network via the Ballerina\nMicrotransaction Protocol [XXX].\n\u003c/p\u003e\n\u003ch2 id=\"metadata\"\u003e12. Metadata\u003c/h2\u003e\n\u003cp\u003e\nBallerina allows metadata to be attached to a construct by specifying the\nmetadata before the construct.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003emetadata := [DocumentationString] annots\n\u003c/pre\u003e\n\u003cp\u003e\nThere are two forms of metadata: documentation and annotations.\n\u003c/p\u003e\n\u003ch3\u003eAnnotations\u003c/h3\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eannots := annotation*\nannotation := \u003ccode\u003e@\u003c/code\u003e annot-tag-reference annot-value\n\u003c/pre\u003e\n\u003cp\u003e\nAnnotations provide structured metadata about a particular construct. Multiple\nannotations can be applied to a single construct. An annotation consists of a\ntag and a value.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eannotation-decl :=\n   metadata\n   [\u003ccode\u003epublic\u003c/code\u003e] [\u003ccode\u003econst\u003c/code\u003e] \u003ccode\u003eannotation\u003c/code\u003e [type-descriptor] annot-tag \n   [\u003ccode\u003eon\u003c/code\u003e annot-attach-points]\nannot-tag := identifier\n\u003c/pre\u003e\n\u003cp\u003e\nAn annotation-decl declares an annotation tag. Annotations tags are in a\nseparate namespace and cannot conflict with other module level declarations and\ndefinitions.\n\u003c/p\u003e\n\u003cp\u003e\nThe type-descriptor specifies the type of the annotation tag. The type must be a\nsubtype of one of the following three types: \u003ccode\u003etrue\u003c/code\u003e,\n\u003ccode\u003emap\u0026lt;anydata\u003e\u003c/code\u003e, \u003ccode\u003emap\u0026lt;anydata\u003e[]\u003c/code\u003e. If the\ntype-descriptor is omitted, then the type is \u003ccode\u003etrue\u003c/code\u003e.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eannot-tag-reference := qualified-identifier\nannot-value := [mapping-constructor-expr]\n\u003c/pre\u003e\n\u003cp\u003e\nAn annot-tag-reference in an annotation must refer to an annot-tag declared in\nan annotation declaration. If the annotation includes a\nmapping-constructor-expr, then the value of the annotation is the mapping value\nresulting from evaluating the mapping-constructor-expr; otherwise the value is\nthe boolean value \u003ccode\u003etrue\u003c/code\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nFor every construct that has an annotation with a particular tag, there is an\neffective value for that annotation tag, which is constructed from all the\nannotations with that tag that were attached to that construct. The effective\nvalue belongs to the type of the annotation tag.\n\u003c/p\u003e\n\u003cp\u003e\nThe type of the annotation tag constrains both the annotation value and the\noccurrence of multiple annotations with the same tag on a single construct as\nfollows.\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf the type of the annotation tag is T[] for some T, then the\nmapping-constructor-expr must be specified and its static type must be a subtype\nof T; multiple annotations are allowed; the effective value is a list of all\nannotations with the tag in the order specified.\u003c/li\u003e\n\u003cli\u003eOtherwise, multiple annotations with this tag are not allowed and the\neffective value for the tag is the value of the single annotation with the tag.\n\u003cul\u003e\n\u003cli\u003eIf the type of the annotation tag is true, then the mapping-constructor-expr\nmust not be specified.\u003c/li\u003e\n\u003cli\u003eOtherwise, the mapping-constructor-expr must be specified and its static\ntype must be a subtype of the type of the annotation tag.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nIf the annotation-decl for a tag specifies \u003ccode\u003econst\u003c/code\u003e, then a\nmapping-constructor-expr in annotations with that tag must be a const-expr and\nis evaluated at compile-time with the semantics of a const-expr. Otherwise, the\nmapping-constructor-expr is evaluated when the annotation is evaluated and the\nresulting value is automatically frozen.\n\u003c/p\u003e\n\u003cp\u003e\nAn annotation applied to a module-level declaration is evaluated when the module\nis initialized. An annotation applied to a service constructor is evaluated when\nthe service constructor is evaluated. An annotation occurring within a type\ndescriptor is evaluated when the type descriptor is resolved.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eannot-attach-points := annot-attach-point (\u003ccode\u003e,\u003c/code\u003e annot-attach-point)*\nannot-attach-point :=\n   dual-attach-point\n   | source-only-attach-point\ndual-attach-point := [\u003ccode\u003esource\u003c/code\u003e] dual-attach-point-ident\ndual-attach-point-ident :=\n   [\u003ccode\u003eobject\u003c/code\u003e] \u003ccode\u003etype\u003c/code\u003e\n   | [\u003ccode\u003eobject\u003c/code\u003e|\u003ccode\u003eresource\u003c/code\u003e] \u003ccode\u003efunction\u003c/code\u003e\n   | \u003ccode\u003eparameter\u003c/code\u003e\n   | \u003ccode\u003ereturn\u003c/code\u003e\n   | \u003ccode\u003eservice\u003c/code\u003e\n   | \u003ccode\u003elistener\u003c/code\u003e\nsource-only-attach-point := \u003ccode\u003esource\u003c/code\u003e source-only-attach-point-ident\nsource-only-attach-point-ident :=\n   \u003ccode\u003eannotation\u003c/code\u003e\n   | \u003ccode\u003eexternal\u003c/code\u003e\n   | \u003ccode\u003evar\u003c/code\u003e\n   | \u003ccode\u003econst\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nThe \u003ccode\u003eannot-attach-points\u003c/code\u003e specify the constructs to which an\nannotation can be attached.\n\u003c/p\u003e\n\u003cp\u003e\nWhen an attachment point is prefixed with \u003ccode\u003esource\u003c/code\u003e, then the\nannotation is attached to a fragment of the source rather than to any runtime\nvalue, and thus is not available at runtime. If any of the attachment points\nspecify \u003ccode\u003esource\u003c/code\u003e, the annotation-decl must specify\n\u003ccode\u003econst\u003c/code\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nWhen an attachment point is not prefixed with source, then the annotation is\naccessible at runtime by applying the annotation access operator to a typedesc\nvalue.\n\u003c/p\u003e\n\u003cp\u003e\nThe available attachment points are described in the following table.\n\u003c/p\u003e\n\u003ctable\u003e\n  \u003ctr\u003e\n   \u003ctd\u003e\u003cstrong\u003eAttachment point name\u003c/strong\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003cstrong\u003eSyntactic attachment point(s)\u003c/strong\u003e\u003c/td\u003e\n   \u003ctd\u003e\u003cstrong\u003eAttached to which type descriptor at runtime\u003c/strong\u003e\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003etype\u003c/td\u003e\n   \u003ctd\u003emodule-type-defn\u003c/td\u003e\n   \u003ctd\u003edefined  type\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003eobject type\u003c/td\u003e\n   \u003ctd\u003emodule-type-defn whose type descriptor is a non-abstract object type\ndescriptor\u003c/td\u003e\n   \u003ctd\u003edefined type (which will be type of objects constructed using this type)\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003efunction\u003c/td\u003e\n   \u003ctd\u003efunction-defn, method-decl, method-defn, outside-method-defn,\nanonymous-function-expr, service-method-defn\u003c/td\u003e\n   \u003ctd\u003etype of function\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003eresource function\u003c/td\u003e\n   \u003ctd\u003eservice-method-defn with resource modifier\u003c/td\u003e\n   \u003ctd\u003etype of function, on service value\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003ereturn\u003c/td\u003e\n   \u003ctd\u003ereturns-type-descriptor\u003c/td\u003e\n   \u003ctd\u003eindirectly to type of function\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003eparameter\u003c/td\u003e\n   \u003ctd\u003eindividual-param, rest-param\u003c/td\u003e\n   \u003ctd\u003eindirectly to type of function\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003eservice\u003c/td\u003e\n   \u003ctd\u003eservice-decl, service-constructor-expr\u003c/td\u003e\n   \u003ctd\u003etype of service\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003elistener\u003c/td\u003e\n   \u003ctd\u003elistener-decl\u003c/td\u003e\n   \u003ctd\u003etype of object\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003evar\u003c/td\u003e\n   \u003ctd\u003emodule-var-decl, local-var-decl-stmt\u003c/td\u003e\n   \u003ctd\u003enone\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003econst\u003c/td\u003e\n   \u003ctd\u003emodule-const-decl\u003c/td\u003e\n   \u003ctd\u003enone\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003eannotation\u003c/td\u003e\n   \u003ctd\u003eannotation-decl\u003c/td\u003e\n   \u003ctd\u003enone\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n   \u003ctd\u003eexternal\u003c/td\u003e\n   \u003ctd\u003eexternal-function-body\u003c/td\u003e\n   \u003ctd\u003enone\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cp\u003e\nA documentation string is an item of metadata that can be associated with\nmodule-level Ballerina constructs and with method declarations. The purpose of\nthe documentation strings for a module is to enable a programmer to use the\nmodule. Information not useful for this purpose should be provided in in\ncomments.\n\u003c/p\u003e\n\u003cp\u003e\nA documentation string has the format of one or more lines each of which has a\n\u003ccode\u003e#\u003c/code\u003e optionally preceded by blank space.\n\u003c/p\u003e\n\u003cp\u003e\nThe documentation statement is used to document various Ballerina constructs.\n\u003c/p\u003e\n\n\u003cpre\nclass=\"grammar\"\u003eDocumentationString := DocumentationLine +\nDocumentationLine := BlankSpace* \u003ccode\u003e#\u003c/code\u003e [Space] DocumentationContent\nDocumentationContent := (^ 0xA)* 0xA\nBlankSpace := Tab | Space\nSpace := 0x20\nTab := 0x9\n\u003c/pre\u003e\n\u003cp\u003e\nA \u003ccode\u003eDocumentationString\u003c/code\u003e is recognized only at the beginning of a\nline. The content of a documentation string is the concatenation of the\n\u003ccode\u003eDocumentationContent\u003c/code\u003e of each \u003ccode\u003eDocumentationLine\u003c/code\u003e in the\n\u003ccode\u003eDocumentationString\u003c/code\u003e. Note that a single space following the # is\nnot treated as part of the DocumentationContent.\n\u003c/p\u003e\n\u003cp\u003e\nThe content of a \u003ccode\u003eDocumentationString\u003c/code\u003e is parsed as Ballerina\nFlavored Markdown (BFM). BFM is also used for a separate per-module\ndocumentation file, conventionally called \u003ccode\u003eModule.md\u003c/code\u003e.\n\u003c/p\u003e\n\u003ch3\u003eBallerina Flavored Markdown\u003c/h3\u003e\n\u003cp\u003e\nBallerina Flavored Markdown is GitHub Flavored Markdown, with some additional\nconventions.\n\u003c/p\u003e\n\u003cp\u003e\nIn the documentation string attached to a function or method, there must be\ndocumentation for each parameter, and for the return value if the return value\nis not nil. The documentation for the parameters and a return value must consist\nof a Markdown list, where each list item must have the form \u003ccode\u003eident -\ndoc\u003c/code\u003e, where ident is either the parameter name or return, and doc is the\ndocumentation of that parameter or of the return value.\n\u003c/p\u003e\n\u003cp\u003e\nThe documentation for an object must contain a list of fields rather than\nparameters. Private fields should not be included in the list.\n\u003c/p\u003e\n\u003cp\u003e\nBFM also provides conventions for referring to Ballerina-defined names from\nwithin documentation strings in a source file. An identifier in backticks\n\u003ccode\u003e`X`\u003c/code\u003e, when preceded by one of the following words:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003etype\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eendpoint\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eservice\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evariable\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evar\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eannotation\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emodule\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efunction\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eparameter\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nis assumed to be a reference to a Ballerina-defined name of the type indicated\nby the word. In the case of \u003ccode\u003eparameter\u003c/code\u003e, the name must be unqualified\nand be the name of a parameter of the function to which the documentation string\nis attached. For other cases, if the name is unqualified it must refer to a\npublic name of the appropriate type in the source file's module; if it is a\nqualified name M:X, then the source file must have imported M, and X must refer\nto a public name of an appropriate type in M. BFM also recognizes\n\u003ccode\u003e`f()`\u003c/code\u003e as an alternative to \u003ccode\u003efunction `f`\u003c/code\u003e. In both\ncases, f can have any of the following forms (where m is a module import, x is a\nfunction name, t is an object type name, and y is a method name):\n\u003c/p\u003e\n\n\u003cpre\n\u003e    x()\n    m:x()\n    t.y()\n    m:t.y()\n\u003c/pre\u003e\n\u003cp\u003e\nExample\n\u003c/p\u003e\n\n\u003cpre\n\u003e    # Adds parameter `x` and parameter `y`\n    # + x - one thing to be added\n    # + y - another thing to be added\n    # + return - the sum of them\n    function add (int x, int y) returns int  { return x + y; }\n\u003c/pre\u003e\n\u003ch2 id=\"references\"\u003eA. References\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eUnicode\u003c/li\u003e\n\u003cli\u003eXML\u003c/li\u003e\n\u003cli\u003eJSON\u003c/li\u003e\n\u003cli\u003eRFC 3629 UTF-8\u003c/li\u003e\n\u003cli\u003eIEEE 754-2008\u003c/li\u003e\n\u003cli\u003eGitHub Markdown\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"changes\"\u003eB. Changes since previous versions\u003c/h2\u003e\n\u003ch3\u003eSummary of changes from 0.990 to 2019R1\u003c/h3\u003e\n\u003cp\u003e\nThe specification has switched to a new versioning scheme. The \u003cvar\u003en\u003c/var\u003e-th\nversion of the specification released in year 20\u003cvar\u003exy\u003c/var\u003e will be labelled\n20\u003cvar\u003exy\u003c/var\u003eR\u003cvar\u003en\u003c/var\u003e.\n\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eTuples types now use square brackets, rather than parentheses, as do tuple\nbinding patterns and tuple match patterns. Array constructors and tuple\nconstructors are now unified into list constructors, which use square brackets.\nTuple types can have zero members or one member, and can use \u003ccode\u003eT...\u003c/code\u003e\nsyntax allow trailing members of a specified type.\u003c/li\u003e\n\u003cli\u003eThe way that record type descriptors express openness has changed. Instead\nof the \u003ccode\u003e!...\u003c/code\u003e syntax, there are two flavours of record type\ndescriptor, which use different delimiters: \u003ccode\u003erecord {| |}\u003c/code\u003e allows any\nmapping that has exclusively the specified fields, whereas \u003ccode\u003erecord {\n}\u003c/code\u003e allows any mapping that includes the specified fields; the former can\nuse the \u003ccode\u003eT...\u003c/code\u003e syntax, whereas the latter cannot. The\n\u003ccode\u003e!...\u003c/code\u003e is no longer allowed for record binding patterns and record\nmatch patterns.\u003c/li\u003e\n\u003cli\u003eThe syntax for an array with an array length that is inferred has changed\nfrom \u003ccode\u003eT[!...]\u003c/code\u003e to \u003ccode\u003eT[*]\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eA type descriptor of \u003ccode\u003eerror\u0026lt;*\u0026gt;\u003c/code\u003e can be used to specify an\nerror type whose subtype is inferred.\u003c/li\u003e\n\u003cli\u003eA new expression can no longer be used to create values of structural types;\nit is only allowed for objects.\u003c/li\u003e\n\u003cli\u003eSymbolic string literals \u003ccode\u003e'ident\u003c/code\u003e have been removed (compile time\nconstants provide a more convenient approach).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003euntaint\u003c/code\u003e expression has been removed (this will be handled by\nannotations instead).\u003c/li\u003e\n\u003cli\u003eThe syntax for named arguments in a function call has reverted to\n\u003ccode\u003earg=\u003c/code\u003e from \u003ccode\u003earg:\u003c/code\u003e, since the latter caused syntactic\nambiguities.\u003c/li\u003e\n\u003cli\u003eThe syntax for error constructors specifies fields of the error detail\nseparately as named arguments, rather than specifying the error detail as a\nsingle argument; the syntax for binding patterns and match patterns for error\nvalues has also changed accordingly.\u003c/li\u003e\n\u003cli\u003eThe error reason argument can be omitted from an error constructor if it\ncan be determined from the contextually expected type.\u003c/li\u003e\n\u003cli\u003eThe syntax for annotation declarations has been revised; the places where\nannotations are allowed has been revised to match the possible attachment\npoints.\u003c/li\u003e\n\u003cli\u003eAn \u003ccode\u003e@.\u003c/code\u003e binary operator has been added for accessing annotations\nat runtime.\u003c/li\u003e\n\u003cli\u003eA unary \u003ccode\u003etypeof\u003c/code\u003e operator has been added.\u003c/li\u003e\n\u003cli\u003eThe \u003ccode\u003etypedesc\u003c/code\u003e type now takes an optional type parameter.\u003c/li\u003e\n\u003cli\u003eThe type parameters for \u003ccode\u003efuture\u003c/code\u003e and \u003ccode\u003estream\u003c/code\u003e are now\noptional.\u003c/li\u003e\n\u003cli\u003eThe syntax for a function with an external implementation has changed to use\n\u003ccode\u003e=external\u003c/code\u003e in place of the curly braces.\u003c/li\u003e\n\u003cli\u003eA numeric literal can use a suffix of \u003ccode\u003ed\u003c/code\u003e or \u003ccode\u003ef\u003c/code\u003e to\nindicate that it represents a value belonging to the decimal or float type\nrespectively.\u003c/li\u003e\n\u003cli\u003eRecord type descriptors may now specify a default value for fields.\u003c/li\u003e\n\u003cli\u003eProviding a default value for a parameter no longer affects whether a function\ncall must supply the argument for that parameter positionally or by name. Instead\nthe argument for any parameter can be supplied either positionally or by name.\nTo avoid ambiguity, all arguments specified positionally must be specified before\narguments specified by name.\u003c/li\u003e\n\u003cli\u003eExpressions specifying the default value for function parameters are not\ncompile time constants, and are evaluated each time they are used to supply a\nmissing argument.\u003c/li\u003e\n\u003cli\u003eIn the argument list of a function or method call, positional arguments are\nnow required to be specified before named arguments.\u003c/li\u003e\n\u003cli\u003eTypes may now be defined within a block.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003eSummary of changes from 0.980 to 0.990\u003c/h3\u003e\n\u003cp\u003e\n\u003cstrong\u003eStructural types and values\u003c/strong\u003e\n\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eConcepts relating to typing of mutable structural values have been changed\nin order to make type system sound.\u003c/li\u003e\n\u003cli\u003eThe \u003ccode\u003ematch\u003c/code\u003e statement has been redesigned.\u003c/li\u003e\n\u003cli\u003eThe \u003ccode\u003ebut\u003c/code\u003e expression has been removed.\u003c/li\u003e\n\u003cli\u003eThe \u003ccode\u003eis\u003c/code\u003e expression for dynamic type testing has been added.\u003c/li\u003e\n\u003cli\u003eThe type-cast-expr \u0026lt;T\u003eE now performs unsafe type casts.The only\nconversions it performs are numeric conversions.\u003c/li\u003e\n\u003cli\u003eThe \u003ccode\u003eanydata\u003c/code\u003e type has been added, which is a union of simple and\nstructural types.\u003c/li\u003e\n\u003cli\u003eRecords are now by default open to \u003ccode\u003eanydata|error\u003c/code\u003e, rather than\n\u003ccode\u003eany\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eType parameters for built-in types (map, stream, future), which previously\ndefaulted to any, are now required.\u003c/li\u003e\n\u003cli\u003eThe type parameter for json (e.g. json\u0026lt;T\u003e) is not allowed any more.\u003c/li\u003e\n\u003cli\u003eType for table columns are restricted to subtype of anydata|error.\u003c/li\u003e\n\u003cli\u003eThere are now two flavors of equality operator: == and != for deep equality\n(which is allowed only for \u003ccode\u003eanydata\u003c/code\u003e), and ===  and !== for exact\nequality.\u003c/li\u003e\n\u003cli\u003eThere is a built-in clone operation for performing a deep copy on values of\ntype anydata.\u003c/li\u003e\n\u003cli\u003eThere is a built-in freeze operation for making structural values deeply\nimmutable.\u003c/li\u003e\n\u003cli\u003eCompile-time constants (which are always a subtype of anydata and frozen)\nhave been added.\u003c/li\u003e\n\u003cli\u003eSingleton types have been generalized: any compile-time constant can be made\ninto a singleton value.\u003c/li\u003e\n\u003cli\u003eVariables can be declared final, with a similar semantic to Java.\u003c/li\u003e\n\u003cli\u003eErrors are now immutable.\u003c/li\u003e\n\u003cli\u003eModule variables are not allowed to be public: only compile-time constants\ncan be public.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\n\u003cstrong\u003eError handling\u003c/strong\u003e\n\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe \u003ccode\u003eany\u003c/code\u003e type no longer includes \u003ccode\u003eerror\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003echeck\u003c/code\u003e is now an expression.\u003c/li\u003e\n\u003cli\u003eExceptions have been replaced by panics\n\u003col\u003e\n\u003cli\u003ethe \u003ccode\u003ethrow\u003c/code\u003e statement has been replaced by the \u003ccode\u003epanic\u003c/code\u003e\nstatement\u003c/li\u003e\n\u003cli\u003ethe\u003ccode\u003e try\u003c/code\u003e statement has been replaced by the \u003ccode\u003etrap\u003c/code\u003e\nexpression\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003eObject constructors (which could not return errors) have been replaced by\n\u003ccode\u003e__init\u003c/code\u003e methods (which can return errors).\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\n\u003cstrong\u003eConcurrency\u003c/strong\u003e\n\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eWorkers in functions have been redesigned. In particular, workers now have a\nreturn value.\u003c/li\u003e\n\u003cli\u003eThe \u003ccode\u003edone\u003c/code\u003e statement has been removed.\u003c/li\u003e\n\u003cli\u003eThe fork/join statement has been redesigned.\u003c/li\u003e\n\u003cli\u003eA syntactic category between expression and statement, called action, has\nbeen added.\u003c/li\u003e\n\u003cli\u003eA synchronous message send action has been added.\u003c/li\u003e\n\u003cli\u003eA flush action has been added to flush asynchronously sent messages.\u003c/li\u003e\n\u003cli\u003eA wait action has been added to wait for a worker and get its return value.\u003c/li\u003e\n\u003cli\u003eFutures have been unified with workers. A future\u0026lt;T\u003e represents a value to\nbe returned by a named worker.\u003c/li\u003e\n\u003cli\u003eError handling of message send/receive has been redesigned.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\n\u003cstrong\u003eEndpoints and services\u003c/strong\u003e\n\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eClient endpoints have been replaced by client objects, and actions on client\nendpoints have been replaced by remote methods on client objects. Remote methods\nare called using a remote method call action, which replaces the action\ninvocation statement.\u003c/li\u003e\n\u003cli\u003eModule endpoint declaration has been replaced by module listener\ndeclaration, which uses the Listener built-in object type.\u003c/li\u003e\n\u003cli\u003eThe service type has been added as a new basic type of behavioural value,\ntogether with service constructor expressions for creating service values.\u003c/li\u003e\n\u003cli\u003eModule service definitions have been redesigned.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\n\u003cstrong\u003eMiscellaneous changes\u003c/strong\u003e\n\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ePublic/private visibility qualifiers must be repeated on an outside method\ndefinition.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003eSummary of changes from 0.970 to 0.980\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eThe decimal type has been added.\u003c/li\u003e\n\u003cli\u003eThere are no longer any implicit numeric conversions.\u003c/li\u003e\n\u003cli\u003eThe type of a numeric literal can be inferred from the context.\u003c/li\u003e\n\u003cli\u003eThe error type is now a distinct basic type.\u003c/li\u003e\n\u003cli\u003eThe byte type has been added as a predefined subtype of int; blobs have been\nreplaced by arrays of bytes.\u003c/li\u003e\n\u003cli\u003eThe syntax of string templates and xml literals has been revised and\nharmonized.\u003c/li\u003e\n\u003cli\u003eThe syntax of anonymous functions has been revised to provide two\nalternative syntaxes: a full syntax similar to normal function definitions and a\nmore convenient arrow syntax for when the function body is an expression.\u003c/li\u003e\n\u003cli\u003eThe cases of a match statement are required to be exhaustive.\u003c/li\u003e\n\u003cli\u003eThe + operator is specified to do string and xml concatenation as well as\naddition.\u003c/li\u003e\n\u003cli\u003eBitwise operators have been added (\u003ccode\u003e\u0026lt;\u0026lt;\u003c/code\u003e, \u003ccode\u003e\u003e\u003e\u003c/code\u003e,\n\u003ccode\u003e\u003e\u003e\u003e\u003c/code\u003e, \u003ccode\u003e\u0026amp;\u003c/code\u003e, \u003ccode\u003e|\u003c/code\u003e, \u003ccode\u003e^\u003c/code\u003e,\n\u003ccode\u003e~\u003c/code\u003e) rather than = after the argument name.\u003c/li\u003e\n\u003cli\u003eIn a function call or method call, named arguments have changed to use\n\u003ccode\u003e:\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eA statement with \u003ccode\u003echeck\u003c/code\u003e always handles an error by returning it,\nnot by throwing it.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003echeck\u003c/code\u003e is allowed in compound assignment statements.\u003c/li\u003e\n\u003cli\u003eMethod names are now looked up differently from field names; values of types\nother than objects can now have built-in methods.\u003c/li\u003e\n\u003cli\u003eThe \u003ccode\u003elengthof\u003c/code\u003e unary expression has been removed; the length\nbuilt-in method can be used instead.\u003c/li\u003e\n\u003cli\u003eThe semantics of \u0026lt;T\u003eexpr have been specified.\u003c/li\u003e\n\u003cli\u003eThe value space for tuples and arrays is now unified, in the same way as the\nvalue space for records and maps was unified. This means that tuples are now\nmutable. Array types can now have a length.\u003c/li\u003e\n\u003cli\u003eThe \u003ccode\u003enext\u003c/code\u003e keyword has been changed to \u003ccode\u003econtinue\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eThe syntax and semantics of destructuring is now done in a consistent way\nfor the but expression, the match statement, the foreach statement,\ndestructuring assignment statements and variable declarations.\u003c/li\u003e\n\u003cli\u003eThe implied initial value is not used as a default initializer in variable\ndeclarations. A local variable whose declaration omits the initializer must be\ninitialized by an assignment before it is used. A global variable declaration\nmust always have an initializer. A new expression can be used with any reference\ntype that has an implicit initial value.\u003c/li\u003e\n\u003cli\u003ePostfix increment and decrement statements have been removed.\u003c/li\u003e\n\u003cli\u003eThe \u003ccode\u003e...\u003c/code\u003e and \u003ccode\u003e..\u0026lt;\u003c/code\u003e operators have been added for\ncreating integer ranges; this replaces the foreach statement's special treatment\nof integer ranges.\u003c/li\u003e\n\u003cli\u003eAn object type can be declared to be abstract, meaning it cannot be used\nwith \u003ccode\u003enew\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eBy default,  a record type now allows extra fields other than those\nexplicitly mentioned; \u003ccode\u003eT...\u003c/code\u003e requires extra fields to be of type T\nand \u003ccode\u003e!...\u003c/code\u003e disallows extra fields.\u003c/li\u003e\n\u003cli\u003eIn a mapping constructor, an expression can be used for the field name by\nenclosing the expression in square brackets (as in ECMAScript).\u003c/li\u003e\n\u003cli\u003eInteger arithmetic operations are specified to throw an exception on\noverflow.\u003c/li\u003e\n\u003cli\u003eThe syntax for documentation strings has changed.\u003c/li\u003e\n\u003cli\u003eThe deprecated construct has been removed (data related to deprecation will\nbe provided by an annotation; documentation related to deprecation will be part\nof the documentation string).\u003c/li\u003e\n\u003cli\u003eThe order of fields, methods and constructors in object types is no longer\nconstrained.\u003c/li\u003e\n\u003cli\u003eA function or method can be defined as \u003ccode\u003eextern\u003c/code\u003e. The\n\u003ccode\u003enative\u003c/code\u003e keyword has been removed.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"contributors\"\u003eC. Other contributors\u003c/h2\u003e\n\u003cp\u003e\nThe following contributed to establishing the design principles of the language:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFrank Leymann, \u003ca href=\"mailto:frank.leymann@iaas.uni-stuttgart.de\"\u003efrank.leymann@iaas.uni-stuttgart.de\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eSrinath Perera, \u003ca href=\"mailto:srinath@wso2.com\"\u003esrinath@wso2.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eKasun Indrasiri, \u003ca href=\"mailto:kasun@wso2.com\"\u003ekasun@wso2.com\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nThe following also contributed to the language in a variety of ways (in\nalphabetical order):\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eShafreen Anfar, \u003ca href=\"mailto:shafreen@wso2.com\"\u003eshafreen@wso2.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eAfkham Azeez, \u003ca href=\"mailto:azeez@wso2.com\"\u003eazeez@wso2.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eAnjana Fernando, \u003ca href=\"mailto:anjana@wso2.com\"\u003eanjana@wso2.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eChanaka Fernando, \u003ca href=\"mailto:chanakaf@wso2.com\"\u003echanakaf@wso2.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eJoseph Fonseka, \u003ca href=\"mailto:joseph@wso2.com\"\u003ejoseph@wso2.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ePaul Fremantle, \u003ca href=\"mailto:paul@wso2.com\"\u003epaul@wso2.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eAntony Hosking, \u003ca href=\"mailto:antony.hosking@anu.edu.au\"\u003eantony.hosking@anu.edu.au\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTyler Jewell, \u003ca href=\"mailto:tylerjewell@gmail.com\"\u003etylerjewell@gmail.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eAnupama Pathirage, \u003ca href=\"mailto:anupama@wso2.com\"\u003eanupama@wso2.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eManuranga Perera, \u003ca href=\"mailto:manu@wso2.com\"\u003emanu@wso2.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eSupun Thilina Sethunga, \u003ca href=\"mailto:supuns@wso2.com\"\u003esupuns@wso2.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eSriskandarajah Suhothayan, \u003ca href=\"mailto:suho@wso2.com\"\u003esuho@wso2.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eIsuru Udana, \u003ca href=\"mailto:isuruu@wso2.com\"\u003eisuruu@wso2.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eRajith Lanka Vitharana, \u003ca href=\"mailto:rajithv@wso2.com\"\u003erajithv@wso2.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eMohanadarshan Vivekanandalingam, \u003ca href=\"mailto:mohan@wso2.com\"\u003emohan@wso2.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eLakmal Warusawithana, \u003ca href=\"mailto:lakmal@wso2.com\"\u003elakmal@wso2.com\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eAyoma Wijethunga, \u003ca href=\"mailto:ayoma@wso2.com\"\u003eayoma@wso2.com\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/spec/lang/[...slug]","query":{"slug":["2019R1","index"]},"buildId":"XA3UMLKYkN8BkU_Lfr_oH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>