{"pageProps":{"frontmatter":{"layout":"ballerina-java-interoperability-left-nav-pages-swanlake","title":"The Bindgen Tool","description":"The bindgen tool is a CLI tool, which generates Ballerina bindings for Java classes.","keywords":"ballerina, programming language, java, interoperability, bindgen","permalink":"/learn/java-interoperability/the-bindgen-tool/","active":"the-bindgen-tool","intro":"The bindgen tool is a CLI tool, which generates Ballerina bindings for Java classes.","redirect_from":["/learn/tooling-guide/cli-tools/bindgen-tool/","/learn/tooling-guide/cli-tools/bindgen-tool","/learn/cli-documentation/bindgen-tool/","/learn/cli-documentation/bindgen-tool","/learn/cli-documentation/the-bindgen-tool/","/learn/cli-documentation/the-bindgen-tool"]},"content":"\nThe following sections explain how the `bindgen` tool works.\n\n## The `bindgen` command\n\n```sh\nballerina bindgen [(-cp|--classpath) <classpath>...]\n                  [(-mvn|--maven) <groupId>:<artifactId>:<version>]\n                  [(-o|--output) <output-path>]\n                  [--public]\n                  (<class-name>...)\n```\n\n`(-cp|--classpath) <classpath>...`\nThis optional parameter could be used to specify one or more comma-delimited classpaths for retrieving the Java libraries required for the generation of the Ballerina bindings. The classpath could be provided as comma-separated paths of JAR files or as comma-separated paths of directories containing all the relevant Java libraries. If the Ballerina bindings are to be generated from a standard Java library, from a library available inside the Ballerina SDK, or a platform library specified in the `Ballerina.toml`, then you need not specify the classpath explicitly.\n\n`(-mvn|--maven) <groupId>:<artifactId>:<version>`\nThis optional parameter could be used to specify a Maven dependency required for the generation of the Ballerina bindings. Here, the specified library and its transitive dependencies will be resolved into the `target/platform-libs` directory of the Ballerina package. If the tool is not executed inside a package or if the output path does not point to a package, the `target/platform-libs` directory structure will be created in the output path to store the Maven dependencies. The tool will also update the `Ballerina.toml` file with the platform libraries if the command is executed inside a Ballerina package.\n\n`(-o|--output) <output>`\nThis optional parameter could be used to generate all the bindings inside a single directory instead of generating module-level mappings. This option could be used in instances where all the mappings are required inside a single module. The specified directory doesn't always have to be inside a Ballerina package.\n\n`--public`\nSet the visibility modifier of the generated binding classes to public. This flag will be applicable only if the bindings are generated inside a single directory.\n\n`<class-name>...`\nOne or more space-separated fully-qualified Java class names for which the Ballerina bridge code is to be generated. These class names should be provided at the end of the command.\n\n## Generated bridge code\n\nWhen the tool is run, a `.bal` file will be created to represent each Java class. This would contain the respective Ballerina binding class along with the required Java interoperability mappings. By default, these `.bal` files will be generated inside separate modules representing each Java package. If the `[(-o|--output) <output-path>]` option is used, they will be generated inside a single directory.\n\nApart from creating bindings for the specified Java classes, the command will also generate empty Ballerina binding classes for dependent Java classes. A Java class would be considered dependent if it is used inside one of the generated Ballerina binding classes.\n\nA set of additional `.bal` files will be generated to store the error types used within the Ballerina binding classes.\n\nThe generated bindings will be inside the specified output directory as follows.\n```sh\n<module-dir>\n    ├── <class-name>.bal // generated classes\n    ├── ...\n    ├── <class-name>.bal // generated dependent classes\n    ├── ...\n    ├── <class-name>.bal // generated error types\n    └── ...\n```\n\n## Java to Ballerina mapping\n\n### Java classes\nA Java class will be mapped to a Ballerina class. This Ballerina class will have the same name as the Java class.\n\nE.g., the generated Ballerina class of the `java.util.ArrayDeque` class will be as follows.\n```ballerina\n@java:Binding {\n    'class: \"java.util.ArrayDeque\"\n}\ndistinct class ArrayDeque {\n\n    *java:JObject;\n    *AbstractCollection;\n\n    public handle jObj;\n\n    function init(handle obj) {\n        self.jObj = obj;\n    }\n\n    ...\n};\n```\nIf there are multiple classes with the same simple name, they need to be generated using a single execution. The tool will then apply a numerical identifier at the end of duplicated class names. This could be manually changed into something meaningful if required.\n\nThe format for specifying inner classes using the command is `<package-name>.ClassName$InnerClassName`. The dollar sign might have to be escaped using the backslash key.\n\nE.g., the command to generate bindings for `java.lang.Character.Subset` class will be as follows.\n```sh\n> bal bindgen java.lang.Character\\$Subset\n```\n\nWhen referring to a Java code to figure out the imported classes, you should be cautious about the Java classes from the `java.lang` package since these will not be visible as imports in the Java code. However, you need not generate bindings for the `java.lang.String` class since it is mapped into the Ballerina `string` type from within the generated Ballerina bindings.\n\n### Constructors\nConstructors of Java classes will be mapped to functions outside the Ballerina class. These function names are comprised of the constructor name prefixed with the `new` keyword. If there are multiple constructors, they will be suffixed with an auto-incremented number.\n\nE.g., generated constructors of the `java.util.ArrayDeque` class will be as follows.\n```ballerina\nfunction newArrayDeque1() returns ArrayDeque {\n   ...\n}\n\nfunction newArrayDeque2(int arg0) returns ArrayDeque {\n   ...\n}\n\nfunction newArrayDeque3(Collection arg0) returns ArrayDeque {\n   ...\n}\n```\n\n### Methods\nAll public methods will be exposed through Ballerina bindings. Instance methods will reside inside the Ballerina class and these would take the name of the Java method. However, if there are overloaded methods, a numeric suffix will be appended at the end of the name.\n\nE.g., some of the generated instance methods of the `java.util.ArrayDeque` class will be as follows.\n```ballerina\nclass ArrayDeque {\n   ...\n\n   function add(Object arg0) returns boolean {\n       ...\n   }\n\n   function isEmpty() returns boolean {\n       ...\n   }\n};\n```\nStatic methods would reside outside the Ballerina class as functions, which take the name of the Java method with the Java simple class name appended at the beginning as a prefix.\n\nE.g., a generated static method `randomUUID()` of the `java.util.UUID` class will be as follows. Here, the Ballerina equivalent of calling `UUID.randomUUID()` in Java will be `UUID_randomUUID()`.\n```ballerina\nfunction UUID_randomUUID() returns UUID {\n   ...\n}\n```\n\n### Fields\nAll public fields of a Java class will be exposed through Ballerina bindings in the form of getters and setters. Instance fields will have the respective getter and setter methods inside the Ballerina class, whereas, the static fields will have getter and setter functions outside the Ballerina class.\n\nThe getter and setter functions of an instance field will take the name of the field prefixed with a `get` or `set` at the beginning.\n\nE.g., `get<FIELD_NAME>()` and `set<FIELD_NAME>(<type> arg)`\n\nFor a static field, the getter and setter (if the field is not final) functions will take the name of the field with a `get` or `set` prefix along with the Java simple class name appended at the beginning.\n\nE.g., `<Class_Name>_get<FIELD_NAME>()` and `<Class_Name>_set<FIELD_NAME>(<type> arg)`\n\n### Java exceptions\nWhen generating Ballerina bindings, Java exceptions will be mapped onto Ballerina errors. They will have identical names as that of the corresponding Java exceptions. Instead of returning a generic error from the Java side, the bindings will return a more meaningful error representing the exact Java exception.\n\nE.g., the following `IOException` will be returned from the `read()` function in the `java.io.FileInputStream` Ballerina binding class.\n\n```ballerina\nfunction read() returns int|IOException {\n    int|error externalObj = java_io_FileInputStream_read(self.jObj);\n    if (externalObj is error) {\n        IOException e = error IOException(IOEXCEPTION, externalObj, message = externalObj.message());\n        return e;\n    } else {\n        return externalObj;\n    }\n}\n```\n\n>**Note:** If a Java exception class is explicitly generated as a Ballerina binding class, it would follow the naming convention `JException` or `JError`. For instance, the binding class's name for `java.io.FileNotFoundException` would be `JFileNotFoundException`.\n\n### Dependent classes\nWhen there are dependent Java classes present inside generated Ballerina bindings (as parameters or return types), the `bindgen` tool generates an empty Ballerina binding class to represent each one of these classes. This will represent a Java class mapping without the constructors, methods, or field bindings. If one of these classes is required later, the `bindgen` tool could be re-run to generate the complete implementation of the Ballerina bindings.\n\nE.g., the generated dependent class representing `java.util.List` will be as follows.\n```ballerina\ndistinct class List {\n\n   *java:JObject;\n\n   public handle jObj;\n\n   function init(handle obj) {\n       self.jObj = obj;\n   }\n\n   function toString() returns string {\n       return java:toString(self.jObj) ?: \"null\";\n   }\n};\n```\n\n### Type mappings\nGenerated Ballerina bindings will support the following type mappings between Java and Ballerina.\n- Ballerina primitive - Java primitive\n- Ballerina string type - Java String class\n- Ballerina binding class - Java class\n\nThe Ballerina binding classes will store a handle reference of the Java object using its `jObj` field.\n\nThe following table summarizes how Java primitive types are mapped to the corresponding Ballerina primitive types. This is applicable when mapping a return type of a Java method to a Ballerina type.\n\nJava type | Ballerina type\n---------- | --------------\nboolean | boolean\nbyte | byte\nint, short, char, long | int\nfloat, double | float\n\n## Support for Java subtyping\nBallerina bindings provide support for Java subtyping with the aid of type inclusions in the language.\n\nE.g., a Ballerina binding class mapping the `java.io.FileInputStream` Java class could be assigned to a Ballerina binding class mapping the `java.io.InputStream` as follows.\n```ballerina\nInputStream inputStream = check newFileInputStream3(\"sample.txt\");\n```\n\n## Support for Java casting\nThe `ballerina/jballerina.java` module of the Ballerina standard library provides the `cast` function to support Java casting. This could be used to cast Ballerina binding classes into their subtypes based on assignability.\n\nE.g., a Ballerina binding class instance mapping the `java.io.InputStream` Java class `inputStream` could be cast onto a Ballerina binding class mapping the `java.io.FileInputStream` Java class as follows.\n```ballerina\nFileInputStream fileInputStream = check java:cast(inputStream);\n```\n","id":"the-bindgen-tool"},"__N_SSG":true}