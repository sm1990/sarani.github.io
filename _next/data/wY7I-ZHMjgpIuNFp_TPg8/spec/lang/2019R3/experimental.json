{"pageProps":{"frontmatter":{"permalink":"/spec/lang/2019R3/experimental/","redirect_from":["/spec/lang/v2019R3/experimental.html","/spec/lang/2019R3/experimental.html"]},"content":"<html lang=\"en\">\n<head>\n  <title>Ballerina 1.0 Experimental Features</title>\n  <meta charset=\"utf-8\">\n  <link rel=\"shortcut icon\" href=\"/img/favicon.ico\">\n  <style type=\"text/css\">\n    body { font-family: sans-serif; line-height: 1.38;  }\n    pre.grammar code, code.grammar { background-color: #D0D0D0; }\n    pre, code { font-family: Consolas, monospace; }\n    table { border: solid thin; border-collapse: collapse; }\n    td, th { border: solid thin; padding: 0.5em; }\n    p.status { font-size: large; font-weight: bold; }\n  </style>\n<link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/css?family=Roboto:100,100i,300,300i,400,400i,500,500i,700,700i,900,900i&amp;display=swap\">\n<link rel=\"stylesheet\" href=\"style/ballerina-language-specification.css\">\n<script src=\"https://code.jquery.com/jquery-2.2.4.min.js\"></script><script src=\"style/ballerina-language-specification.js\"></script>\n</head>\n<body>\n<h1>Ballerina 1.0 Experimental Features</h1>\n<p>\nPrimary contributors:\n</p>\n<ul>\n<li>Sanjiva Weerawarana, <a href=\"mailto:sanjiva@weerawarana.org\">sanjiva@weerawarana.org</a>\n</li>\n<li>Sameera Jayasoma, <a href=\"mailto:sameera@wso2.com\">sameera@wso2.com</a>\n</li>\n<li>Hasitha Aravinda, <a href=\"mailto:hasitha@wso2.com\">hasitha@wso2.com</a>\n</li>\n</ul>\n<p>\nCopyright Â© 2018, 2019 <a href=\"https://wso2.com/\">WSO2</a>\n</p>\n<p>\nLicensed under the <a href=\"https://creativecommons.org/licenses/by-nd/4.0/\">Creative Commons\nAttribution-NoDerivatives 4.0 International</a> license\n</p>\n\n<section class=\"toc\"><h2>Table of contents</h2>\n<ul>\n<li>1. <a href=\"#introduction\">Introduction</a>\n</li>\n<li>2. <a href=\"#value_types\">Values, types and variables</a><ul><li>2.1 <a href=\"#section_2.1\">Behavioral values</a><ul><li>2.1.1 <a href=\"#section_2.1.1\">Streams</a>\n</li></ul>\n</li></ul>\n</li>\n<li>3. <a href=\"#expressions\">Expressions</a><ul><li>3.1 <a href=\"#section_3.1\">Table query expressions</a>\n</li></ul>\n</li>\n<li>4. <a href=\"#actions_statements\">Actions and statements</a><ul>\n<li>4.1 <a href=\"#section_4.1\">Lock statement</a>\n</li>\n<li>4.2 <a href=\"#section_4.2\">Forever statement</a>\n</li>\n<li>4.3 <a href=\"#transactions\">Transaction statement</a><ul>\n<li>4.3.1 <a href=\"#section_4.3.1\">Initiated transactions</a>\n</li>\n<li>4.3.2 <a href=\"#section_4.3.2\">Participated transactions</a>\n</li>\n<li>4.3.3 <a href=\"#section_4.3.3\">Transaction propagation</a>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>5. <a href=\"#lang_library\">Lang library</a>\n</li>\n</ul></section>\n\n<section>\n<h2 id=\"introduction\">1. Introduction</h2>\n<p>This document describes features implemented experimentally in\nBallerina 1.0.</p>\n\n</section>\n\n<section>\n<h2 id=\"value_types\">2. Values, types and variables</h2>\n\n<section>\n<h3 id=\"section_2.1\">2.1 Behavioral values</h3>\n\n<pre class=\"grammar\">behavioral-type-descriptor :=\n   <em>...</em>\n   | stream-type-descriptor\n</pre>\n\n<section>\n<h4 id=\"section_2.1.1\">2.1.1 Streams</h4>\n\n<pre class=\"grammar\">stream-type-descriptor := <code>stream</code> [type-parameter]\n</pre>\n<p>\nA value of type <code>stream&lt;T&gt;</code> is a distributor for values of type\n<code>T</code>: when a value v of type T is put into the stream, a function will\nbe called for each subscriber to the stream with v as an argument. T must be a\npure type.\n</p>\n<p>\nA value belongs to a type <code>stream</code> (without the type-parameter)\nif it has basic type stream.\n</p>\n<p>\nA new stream can be constructed using a <code>new</code> expression.\n</p>\n\n</section>\n</section>\n</section>\n\n<section>\n<h2 id=\"expressions\">3. Expressions</h2>\n\n<pre class=\"grammar\">expression := \n   <em>...</em>\n   | table-query-expr\n</pre>\n\n<section>\n<h3 id=\"section_3.1\">3.1 Table query expressions</h3>\n\n<pre class=\"grammar\">table-query-expr := \n   <code>from</code> query-source [query-join-type query-join-source] \n      [query-select] [query-group-by] [query-order-by]\n      [query-having] [query-limit]\nquery-source := identifier [<code>as</code> identifier] [query-where]\nquery-where := <code>where</code> expression\nquery-join-type := [([<code>left</code> | <code>right</code> | <code>full</code>] <code>outer</code>)| <code>inner</code>] <code>join</code>\nquery-join-source := query-source <code>on</code> expression\nquery-select := <code>select</code> (<code>*</code> | query-select-list)\nquery-select-list := \n   expression [<code>as</code> identifier] (<code>,</code> expression [<code>as</code> identifier])*\nquery-group-by := <code>group</code> <code>by</code> identifier (<code>,</code> identifier)*\nquery-order-by :=\n   <code>order</code> <code>by</code> identifier [(<code>ascending</code> | <code>descending</code>)]\n      (<code>,</code> identifier [(<code>ascending</code> | <code>descending</code>)])*\nquery-having := <code>having</code> expression\nquery-limit := <code>limit</code> int-literal\n</pre>\n<p>\nQuery expressions bring language integrated SQL-like querying to Ballerina\ntables.\n</p>\n</section>\n</section>\n\n<section>\n<h2 id=\"actions_statements\">4. Actions and statements</h2>\n\n<pre class=\"grammar\">statement := \n   <em>...</em>\n   | lock-stmt\n   | forever-stmt\n   | transaction-stmt\n   | transaction-control-stmt\n</pre>\n\n<section>\n<h3 id=\"section_4.1\">4.1 Lock statement</h3>\n\n<pre class=\"grammar\">lock-stmt := <code>lock</code> block-stmt\n</pre>\n<p>\nA lock statement is used to execute a series of assignment statements in a\nserialized manner. For each variable that is used as an L-value within the block\nstatement, this statement attempts to first acquire a lock and the entire\nstatement executes only after acquiring all the locks. If a lock acquisition\nfails after some have already been acquired then all acquired locks are released\nand the process starts again.\n</p>\n</section>\n<section>\n<h3 id=\"section_4.2\">4.2 Forever statement</h3>\n\n<pre class=\"grammar\">forever-stmt :=\n   <code>forever</code> <code>{</code> \n      streaming-query-pattern+\n   <code>}</code>\nstreaming-query-pattern :=\n   streaming-query-expr <code>=&gt;</code> <code>(</code> array-type-descriptor identifier <code>)</code>\n      block-stmt\nstreaming-query-expr :=\n   <code>from</code> (sq-source [query-join-type sq-join-source]) | sq-pattern\n      [query-select] [query-group-by] [query-order-by]\n      [query-having] [query-limit] \n      [sq-output-rate-limiting]\nsq-source := \n   identifier [query-where] [sq-window [query-where]] \n      [<code>as</code> identifier]*\nsq-window := <code>window</code> function-call-expr\nsq-join-source := sq-source <code>on</code> expression\nsq-output-rate-limiting := \n   sq-time-or-event-output | sq-snapshot-output\nsq-time-or-event-output := \n   (<code>all</code> | <code>last</code> | <code>first</code>) <code>every</code> int-literal (time-scale | <code>events</code>)\nsq-snapshot-output :=\n   <code>snapshot</code> <code>every</code> int-literal time-scale\ntime-scale := <code>seconds</code> | <code>minutes</code> | <code>hours</code> | <code>days</code> | <code>months</code> | <code>years</code>\nsq-pattern := [<code>every</code>] sp-input [sp-within-clause]\nsp-within-clause := <code>within</code> expression\nsp-input :=\n   sp-edge-input ((<code>followed</code> <code>by</code>) | <code>,</code>) sp-input\n   | <code>not</code> sp-edge-input (<code>and</code> sp-edge-input) | (<code>for</code> int-literal time-scale)\n   | [sp-edge-input ( <code>and</code> | <code>or</code> ) ] sp-edge-input\n   | <code>(</code> sp-input <code>)</code>\nsp-edge-input :=\n   identifier [query-where] [sp-int-range-expr] [<code>as</code> identifier]\nsp-int-range-expr :=\n   <code>[</code> expression <code>..</code> [expression] <code>]</code>\n</pre>\n<p>\nThe forever statement is used to execute a set of streaming queries against some\nnumber of streams concurrently and to execute a block of code when a pattern\nmatches. The statement will never complete and therefore the worker containing\nit will never complete.\n</p>\n</section>\n<section>\n<h3 id=\"transactions\">4.3 Transaction statement</h3>\n\n<pre class=\"grammar\">transaction-stmt := <code>transaction</code> trans-conf? block-stmt trans-retry?\ntransaction-control-stmt := retry-stmt | abort-stmt\ntrans-conf := trans-conf-item (<code>,</code> trans-conf-item)*\ntrans-conf-item := trans-retries | trans-oncommit | trans-onabort\ntrans-retries := <code>retries</code> <code>=</code> expression\ntrans-oncommit := <code>oncommit</code> <code>=</code> identifier\ntrans-onabort := <code>onabort</code> <code>=</code> identifier\ntrans-retry := <code>onretry</code> block-stmt\nretry-stmt := <code>retry</code> <code>;</code>\nabort-stmt := <code>abort</code> <code>;</code>\n</pre>\n<p>\nA transaction statement is used to execute a block of code within a 2PC\ntransaction. A transaction can be established by this statement or it may\ninherit one from the current worker.\n</p>\n<section>\n<h4 id=\"section_4.3.1\">4.3.1 Initiated transactions</h4>\n<p>\nIf no transaction context is present in the worker then the transaction\nstatement starts a new transaction (i.e., becomes the initiator) and executes\nthe statements within the transaction statement.\n</p>\n<p>\nUpon completion of the block the transaction is immediately tried to be\ncommitted. If the commit succeeds, then if there's an on-commit handler\nregistered that function gets invoked to signal that the commit succeeded. If\nthe commit fails, and if the transaction has not been retried more times than\nthe value of the retries configuration, then the on-retry block is executed and\nthe transaction block statement will execute again in its entirety. If there are\nno more retries available then the commit is aborted the on-abort function is\ncalled.\n</p>\n<p>\nThe transaction can also be explicitly aborted using an abort statement, which\nwill call the on-abort function and give up the transaction (without retrying).\n</p>\n<p>\nIf a retry statement is executed if the transaction has not been retried more\ntimes than the value of the retries configuration, then the on-retry block is\nexecuted and the transaction block statement will execute again in its entirety.\n</p>\n</section>\n<section>\n<h4 id=\"section_4.3.2\">4.3.2 Participated transactions</h4>\n<p>\nIf a transaction context is present in the executing worker context, then the\ntransaction statement joins that transaction and becomes a participant of that\nexisting transaction. In this case, retries will not occur as the transaction is\nunder the control of the initiator. Further, if the transaction is locally\naborted (by using the abort statement), the transaction gets marked for abort\nand the participant will fail the transaction when it is asked to prepare for\ncommit by the coordinator of the initiator. When the initiating coordinator\ndecides to abort the transaction it will notify all the participants globally\nand their on-abort functions will be invoked. If the initiating coordinator\ndecides to retry the transaction then a new transaction is created and the\nprocess starts with the entire containing executable entity (i.e. resource or\nfunction) being re-invoked with the new transaction context.\n</p>\n<p>\nWhen the transaction statement reaches the end of the block the transaction is\nmarked as ready to commit. The actual commit will happen when the coordinator\nsends a commit message to the participant and after the commit occurs the\non-commit function will be invoked. Thus, reaching the end of the transaction\nstatement and going past does not have the semantic of the transaction being\ncommitted nor of it being aborted. Thus, if statements that follow the\ntransaction statement they are unaware whether the transaction has committed or\naborted.\n</p>\n<p>\nWhen in a participating transaction, a retry statement is a no-op.\n</p>\n</section>\n<section>\n<h4 id=\"section_4.3.3\">4.3.3 Transaction propagation</h4>\n<p>\nThe transaction context in a worker is always visible to invoked functions. Thus\nany function invoked within a transaction, which has a transaction statement\nwithin it, will behave according to the \"participated transactions\" semantics\nabove.\n</p>\n<p>\nThe transaction context is also propagated over the network via the Ballerina\nMicrotransaction Protocol [XXX].\n</p>\n</section>\n</section>\n</section>\n\n<section>\n<h2 id=\"lang_library\">5. Lang library</h2>\n\n<p>The stream basic type has a lang library module <code><a href=\"/spec/lang/2019R3/lib/stream.bal\" type=\"text/plain\">lang.stream</a></code>.</p>\n\n</section>\n\n</body>\n</html>\n"},"__N_SSG":true}